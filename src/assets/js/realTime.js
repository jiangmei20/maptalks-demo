/* 未能缩小。正在返回未缩小的内容。(maptalks能参考的内容)
(926,17-18): run-time warning JS1004: Expected ';': p
(1115,9-10): run-time warning JS1004: Expected ';': t
(1390,43-44): run-time warning JS1195: Expected expression: >
(1417,6-7): run-time warning JS1195: Expected expression: )
(1752,17-18): run-time warning JS1004: Expected ';': d
(2720,17-18): run-time warning JS1004: Expected ';': n
(2762,13-14): run-time warning JS1004: Expected ';': _
(3108,13-14): run-time warning JS1004: Expected ';': d
(3114,13-14): run-time warning JS1004: Expected ';': e
(3335,26-27): run-time warning JS1004: Expected ';': m
(3335,35-36): run-time warning JS1004: Expected ';': o
(3335,38-39): run-time warning JS1006: Expected ')': m
(3335,51-52): run-time warning JS1004: Expected ';': )
(3339,37-38): run-time warning JS1004: Expected ';': l
(3423,21-22): run-time warning JS1004: Expected ';': z
(3426,21-22): run-time warning JS1004: Expected ';': n
(3429,21-22): run-time warning JS1004: Expected ';': s
(3566,21-22): run-time warning JS1004: Expected ';': z
(3569,21-22): run-time warning JS1004: Expected ';': n
(3572,21-22): run-time warning JS1004: Expected ';': s
(3872,13-14): run-time warning JS1004: Expected ';': c
(5439,17-18): run-time warning JS1004: Expected ';': s
(5482,63-64): run-time warning JS1195: Expected expression: >
(5486,26-27): run-time warning JS1195: Expected expression: )
(5487,29-30): run-time warning JS1004: Expected ';': s
(5492,22-23): run-time warning JS1195: Expected expression: )
(5496,14-15): run-time warning JS1195: Expected expression: )
(5499,5-6): run-time warning JS1002: Syntax error: }
(5500,36-37): run-time warning JS1004: Expected ';': {
(5502,13-14): run-time warning JS1004: Expected ';': m
(5514,9-10): run-time warning JS1004: Expected ';': _
(5515,9-10): run-time warning JS1004: Expected ';': _
(5516,9-10): run-time warning JS1004: Expected ';': _
(5517,9-10): run-time warning JS1004: Expected ';': _
(5518,9-10): run-time warning JS1004: Expected ';': _
(5519,9-10): run-time warning JS1004: Expected ';': _
(5520,9-10): run-time warning JS1004: Expected ';': _
(5521,9-10): run-time warning JS1004: Expected ';': _
(5522,9-10): run-time warning JS1004: Expected ';': _
(5523,9-10): run-time warning JS1004: Expected ';': _
(5539,13-14): run-time warning JS1004: Expected ';': p
(5603,17-18): run-time warning JS1004: Expected ';': s
(5647,63-64): run-time warning JS1195: Expected expression: >
(5651,26-27): run-time warning JS1195: Expected expression: )
(5652,29-30): run-time warning JS1004: Expected ';': s
(5654,22-23): run-time warning JS1195: Expected expression: )
(5658,14-15): run-time warning JS1004: Expected ';': )
(5670,58-59): run-time warning JS1195: Expected expression: )
(5675,9-10): run-time warning JS1002: Syntax error: }
(5677,31-32): run-time warning JS1197: Too many errors. The file might not be a JavaScript file: ,
(6,6667-6674): run-time error JS1137: 'default' is a new reserved word and should not be used as an identifier: default
(6,7219-7226): run-time error JS1137: 'default' is a new reserved word and should not be used as an identifier: default
(6,9027-9034): run-time error JS1137: 'default' is a new reserved word and should not be used as an identifier: default
(6,13548-13555): run-time error JS1137: 'default' is a new reserved word and should not be used as an identifier: default
(6,13565-13572): run-time error JS1137: 'default' is a new reserved word and should not be used as an identifier: default
(6,151078-151081): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
(6,171681-171683): run-time error JS1137: 'in' is a new reserved word and should not be used as an identifier: in
(6,176486-176493): run-time error JS1137: 'default' is a new reserved word and should not be used as an identifier: default
(6,223816-223819): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
(6,223891-223894): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
(6,223915-223918): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
(6,223990-223993): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
(6,224010-224013): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
(6,224036-224039): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
(6,224126-224129): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
(6,224153-224156): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
(3609,25-28): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
(3609,33-36): run-time error JS1137: 'new' is a new reserved word and should not be used as an identifier: new
 */
/*!
 * maptalks v0.49.1
 * LICENSE : BSD-3-Clause
 * (c) 2016-2022 maptalks.org
 */
!function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.maptalks = {})
}(this, function(t) {
    "use strict";
    var D = "_maptalks__internal_layer_"
        , I = ["MultiPoint", "MultiLineString", "MultiPolygon", "GeometryCollection"]
        , j = ["FeatureCollection", "Feature", "Point", "LineString", "Polygon"].concat(I)
        , z = ["markerFile", "polygonPatternFile", "linePatternFile", "markerFillPatternFile", "markerLinePatternFile"]
        , Z = [["markerWidth", "markerHeight"], [], [null, "lineWidth"], [], [null, "markerLineWidth"]]
        , H = {
        lineWidth: 1,
        lineOpacity: 1,
        lineDx: 1,
        lineDy: 1,
        polygonOpacity: 1,
        markerWidth: 1,
        markerHeight: 1,
        markerDx: 1,
        markerDy: 1,
        markerOpacity: 1,
        markerFillOpacity: 1,
        markerLineWidth: 1,
        markerLineOpacity: 1,
        textSize: 1,
        textOpacity: 1,
        textHaloRadius: 1,
        textWrapWidth: 1,
        textLineSpacing: 1,
        textDx: 1,
        textDy: 1
    }
        , G = ["lineColor", "polygonFill", "markerFill", "markerLineColor", "textFill"];
    function F() {
        return Date.now()
    }
    function m(t) {
        for (var e = 1; e < arguments.length; e++) {
            var i, n = arguments[e];
            for (i in n)
                t[i] = n[i]
        }
        return t
    }
    function V(t) {
        return null == t
    }
    function P(t) {
        return "number" == typeof t && !isNaN(t)
    }
    function N(t) {
        return (0 | t) === t
    }
    function W(t) {
        return "object" == typeof t && !!t
    }
    function b(t) {
        return !V(t) && ("string" == typeof t || null !== t.constructor && t.constructor === String)
    }
    function p(t) {
        return !V(t) && ("function" == typeof t || null !== t.constructor && t.constructor === Function)
    }
    var B = Object.prototype.hasOwnProperty;
    function J(t, e) {
        return B.call(t, e)
    }
    var q = Math.PI / 180;
    function Y(t) {
        return t * q
    }
    function X(t) {
        return t / q
    }
    var K, Q, $ = "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0) && !process.versions.electron && !process.versions.nw && !process.versions["node-webkit"];
    function tt(t) {
        var e = "data:image/svg+xml";
        return 4 < t.length && ".svg" === t.slice(-4) ? 1 : t.slice(0, e.length) === e ? 2 : 0
    }
    function et(t, e) {
        $ && et.node ? et.node(t, e) : t.src = e[0]
    }
    !function() {
        if ($)
            return K = function(t) {
                return setTimeout(t, 16)
            }
                ,
                Q = clearTimeout;
        var e, i;
        function t(t) {
            return setTimeout(t, 1e3 / 30)
        }
        function n(t) {
            return window["webkit" + t] || window["moz" + t] || window["ms" + t]
        }
        i = "undefined" != typeof window ? (e = window.requestAnimationFrame || n("RequestAnimationFrame") || t,
            window.cancelAnimationFrame || n("CancelAnimationFrame") || n("CancelRequestAnimationFrame") || function(t) {
                window.clearTimeout(t)
            }
        ) : (e = t,
            clearTimeout),
            K = function(t) {
                return e(t)
            }
            ,
            Q = function(t) {
                t && i(t)
            }
    }();
    var it = 0;
    function nt() {
        return it++
    }
    function rt(t) {
        return t && b(t) ? JSON.parse(t) : t
    }
    function ot(t) {
        for (var e = 1; e < arguments.length; e++) {
            var i = arguments[e];
            if (i)
                for (var n = 0, r = i.length; n < r; n++)
                    t.push(i[n])
        }
        return t.length
    }
    function st(t, e) {
        t = e.indexOf(t);
        -1 < t && e.splice(t, 1)
    }
    function at(t, e, i) {
        if (!Array.isArray(t))
            return i ? e.call(i, t) : e(t);
        for (var n, r = [], o = 0, s = t.length; o < s; o++)
            V(n = t[o]) ? r.push(null) : Array.isArray(n) ? r.push(at(n, e, i)) : (n = i ? e.call(i, n) : e(n),
                r.push(n));
        return r
    }
    function r(t, e) {
        return void 0 === t ? e : t
    }
    function ht(t) {
        return Math.sign ? Math.sign(t) : 0 === (t = +t) || isNaN(t) ? Number(t) : 0 < t ? 1 : -1
    }
    function lt(t) {
        if (Math.log2)
            return Math.log2(t);
        var t = Math.log(t) * Math.LOG2E
            , e = Math.round(t);
        return Math.abs(e - t) < 1e-14 ? e : t
    }
    function ut(t, e, i) {
        return t * (1 - i) + e * i
    }
    function ct(t, e, i) {
        if (t === i || t === e)
            return t;
        i -= e;
        return ((t - e) % i + i) % i + e
    }
    function dt(t, e, i) {
        return Math.min(i, Math.max(e, t))
    }
    function L(t) {
        return Array.isArray(t) && 0 < t.length
    }
    var gt = /^([a-z][a-z\d+\-.]*:)?\/\//i;
    var pt = /^url\((['"])(.+)\1\)$/i
        , ft = /^url\(([^'"].*[^'"])\)$/i;
    function mt(t) {
        return b(t) ? ft.test(t) ? 1 : pt.test(t) ? 2 : 3 : 0
    }
    function _t(t) {
        var e = mt(t);
        return 3 === e ? t : 1 === e ? ft.exec(t)[1] : 2 === e ? pt.exec(t)[2] : t
    }
    function yt(t) {
        if ("undefined" != typeof window && window.btoa)
            return window.btoa(t);
        for (var e, i, n = String(t), r = "", o = 0, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; n.charAt(0 | o) || (s = "=",
        o % 1); r += s.charAt(63 & e >> 8 - o % 1 * 8)) {
            if (255 < (i = n.charCodeAt(o += .75)))
                throw new Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
            e = e << 8 | i
        }
        return r
    }
    function vt(t, e) {
        for (var i = atob(t), t = new ArrayBuffer(i.length), n = new Uint8Array(t), r = 0; r < i.length; r++)
            n[r] = 255 & i.charCodeAt(r);
        return new Blob([t],{
            type: e
        })
    }
    function xt(t, e, i, n) {
        return Math.atan2(n - e, i - t)
    }
    var wt = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    function Ct(t, e) {
        if (!t && !e)
            return !0;
        if (!t || !e)
            return !1;
        for (var i in t)
            if ("center" === i) {
                if (!e[i] || !Pt(t[i][0], e[i][0]) || !Pt(t[i][1], e[i][1]))
                    return !1
            } else if (t[i] !== e[i])
                return !1;
        return !0
    }
    function Pt(t, e, i) {
        return e - (i = null == i ? 1e-6 : i) <= t && t <= e + i
    }
    function bt(e, i, n, r) {
        e = e || 100,
            i = i || 4;
        var o = this;
        return i *= 2,
        this._flashTimeout && clearTimeout(this._flashTimeout),
            this._flashTimeout = setTimeout(function t() {
                if (0 === i)
                    return o.show(),
                        void (n && (r ? n.call(r) : n()));
                i % 2 == 0 ? o.hide() : o.show(),
                    i--,
                    o._flashTimeout = setTimeout(t, e)
            }, e),
            this
    }
    var Mt = ["Unknown", "Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon", "GeometryCollection"];
    function St(t) {
        return new Function("f","var p = (f && f.properties || {}); return " + Tt(t))
    }
    function Tt(t) {
        if (!t)
            return "true";
        var e = t[0];
        return t.length <= 1 ? "any" === e ? "false" : "true" : "(" + ("==" === e ? kt(t[1], t[2], "===", !1) : "!=" === e ? kt(t[1], t[2], "!==", !1) : "<" === e || ">" === e || "<=" === e || ">=" === e ? kt(t[1], t[2], e, !0) : "any" === e ? Rt(t.slice(1), "||") : "all" === e ? Rt(t.slice(1), "&&") : "none" === e ? Ot(Rt(t.slice(1), "||")) : "in" === e ? At(t[1], t.slice(2)) : "!in" === e ? Ot(At(t[1], t.slice(2))) : "has" === e ? Lt(t[1]) : "!has" === e ? Ot(Lt(t[1])) : "true") + ")"
    }
    function Et(t) {
        return "$" === t[0] ? "f." + t.substring(1) : "p[" + JSON.stringify(t) + "]"
    }
    function kt(t, e, i, n) {
        var r = Et(t)
            , t = "$type" === t ? Mt.indexOf(e) : JSON.stringify(e);
        return (n ? "typeof " + r + "=== typeof " + t + "&&" : "") + r + i + t
    }
    function Rt(t, e) {
        return t.map(Tt).join(e)
    }
    function At(t, e) {
        "$type" === t && (e = e.map(function(t) {
            return Mt.indexOf(t)
        }));
        var i = JSON.stringify(e.sort(Dt))
            , t = Et(t);
        return e.length <= 200 ? i + ".indexOf(" + t + ") !== -1" : "function(v, a, i, j) {\n        while (i <= j) { var m = (i + j) >> 1;\n            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;\n        }\n    return false; }(" + t + ", " + i + ",0," + (e.length - 1) + ")"
    }
    function Lt(t) {
        return "$id" === t ? '"id" in f' : JSON.stringify(t) + " in p"
    }
    function Ot(t) {
        return "!(" + t + ")"
    }
    function Dt(t, e) {
        return t < e ? -1 : e < t ? 1 : 0
    }
    function It(t) {
        var t = t._toJSON()
            , e = t.feature;
        return e.type = Mt.indexOf(e.geometry.type),
            e.subType = t.subType,
            e
    }
    function jt(t) {
        if (!Array.isArray(t))
            return jt([t]);
        for (var e = [], i = 0; i < t.length; i++) {
            var n = void 0
                , n = !0 === t[i].filter ? function() {
                    return !0
                }
                : St(t[i].filter);
            e.push(function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i, n = arguments[e];
                    for (i in n)
                        t[i] = n[i]
                }
                return t
            }({}, t[i], {
                filter: n
            }))
        }
        return e
    }
    function zt(t, e) {
        for (var i = 0; i < t.stops.length; i++)
            if (e === t.stops[i][0])
                return t.stops[i][1];
        return t.default
    }
    function Zt(t, e) {
        for (var i = 0; i < t.stops.length && !(e < t.stops[i][0]); i++)
            ;
        return t.stops[Math.max(i - 1, 0)][1]
    }
    function Ht(t, e) {
        for (var i = void 0 !== t.base ? t.base : 1, n = 0; !(n >= t.stops.length) && !(e <= t.stops[n][0]); )
            n++;
        return 0 === n ? t.stops[n][1] : n === t.stops.length ? t.stops[n - 1][1] : function i(n, r, o, s, a, h) {
            return "function" == typeof a ? function() {
                    var t = a.apply(void 0, arguments)
                        , e = h.apply(void 0, arguments);
                    return i(n, r, o, s, t, e)
                }
                : (a.length ? Nt : Ft)(n, r, o, s, a, h)
        }(e, i, t.stops[n - 1][0], t.stops[n][0], t.stops[n - 1][1], t.stops[n][1])
    }
    function Gt(t, e) {
        return e = e,
            t = t.default,
            void 0 !== e ? e : void 0 !== t ? t : void 0 !== i ? i : null;
        var i
    }
    function Ft(t, e, i, n, r, o) {
        n -= i,
            t -= i,
            i = 1 === e ? t / n : (Math.pow(e, t) - 1) / (Math.pow(e, n) - 1);
        return r * (1 - i) + o * i
    }
    function Nt(t, e, i, n, r, o) {
        for (var s = [], a = 0; a < r.length; a++)
            s[a] = Ft(t, e, i, n, r[a], o[a]);
        return s
    }
    function Wt(t) {
        return t && "object" == typeof t && (t.stops || t.property && "identity" === t.type)
    }
    function Bt(t) {
        for (var e in t)
            if (Wt(t[e]))
                return !0;
        return !1
    }
    function Vt(t) {
        return qt(t, "exponential")
    }
    function Ut(t, i) {
        if (!t)
            return null;
        var e = !1;
        if (Array.isArray(t)) {
            for (var n, r = [], o = 0; o < t.length; o++)
                (n = Ut(t[o], i)) ? (r.push(n),
                    e = !0) : r.push(t[o]);
            return e ? r : t
        }
        var s, a = {
            __fn_types_loaded: !0
        }, h = [];
        for (s in t)
            t.hasOwnProperty(s) && h.push(s);
        for (var l = 0, u = h.length; l < u; l++)
            Wt(t[s = h[l]]) ? (e = !0,
                a["_" + s] = t[s],
                function(e) {
                    Object.defineProperty(a, e, {
                        get: function() {
                            return this["__fn_" + e] || (this["__fn_" + e] = Vt(this["_" + e])),
                                this["__fn_" + e].apply(this, i())
                        },
                        set: function(t) {
                            this["_" + e] = t
                        },
                        configurable: !0,
                        enumerable: !0
                    })
                }(s)) : a[s] = t[s];
        return e ? a : t
    }
    function Jt(t) {
        if (!t || !t.stops)
            return [];
        for (var e = [], i = 0, n = t.stops.length; i < n; i++)
            e.push(t.stops[i][1]);
        return e
    }
    function qt(t, e) {
        if (!Wt(t))
            return function() {
                return t
            }
                ;
        var i = !0
            , n = !0
            , r = (t = JSON.parse(JSON.stringify(t))).stops;
        if (r)
            for (var o, s = 0; s < r.length; s++)
                Wt(r[s][1]) && (o = qt(r[s][1], e),
                    i = i && o.isZoomConstant,
                    n = n && o.isFeatureConstant,
                    r[s] = [r[s][0], o]);
        var a = function t(n, e) {
            var i, r, o;
            if (Wt(n)) {
                var s, a = n.stops && "object" == typeof n.stops[0][0], h = a || void 0 !== n.property, h = a || !h;
                if ("exponential" === (e = n.type || e || "exponential"))
                    s = Ht;
                else if ("interval" === e)
                    s = Zt;
                else if ("categorical" === e)
                    s = zt;
                else {
                    if ("identity" !== e)
                        throw new Error('Unknown function type "' + e + '"');
                    s = Gt
                }
                if (a) {
                    for (var l, u = {}, c = [], d = 0; d < n.stops.length; d++) {
                        var g = n.stops[d];
                        void 0 === u[g[0].zoom] && (u[g[0].zoom] = {
                            zoom: g[0].zoom,
                            type: n.type,
                            property: n.property,
                            default: n.default,
                            stops: []
                        }),
                            u[g[0].zoom].stops.push([g[0].value, g[1]])
                    }
                    for (l in u)
                        c.push([u[l].zoom, t(u[l])]);
                    o = r = !(i = function(t, e) {
                            var i = Ht({
                                stops: c,
                                base: n.base
                            }, t)(t, e);
                            return "function" == typeof i ? i(t, e) : i
                        }
                    )
                } else
                    o = h ? (i = function(t) {
                        var e = s(n, t);
                        return "function" == typeof e ? e(t) : e
                    }
                        ,
                        !(r = !0)) : !(r = !(i = function(t, e) {
                            var i = s(n, e ? e[n.property] : null);
                            return "function" == typeof i ? i(t, e) : i
                        }
                    ))
            } else
                i = function() {
                    return n
                }
                    ,
                    o = r = !0;
            return i.isZoomConstant = o,
                i.isFeatureConstant = r,
                i
        }(t, e);
        return a.isZoomConstant = i && a.isZoomConstant,
            a.isFeatureConstant = n && a.isFeatureConstant,
            a
    }
    var Yt = Object.freeze({
        createFilter: St,
        getFilterFeature: It,
        compileStyle: jt,
        isFunctionDefinition: Wt,
        hasFunctionDefinition: Bt,
        interpolated: Vt,
        piecewiseConstant: function(t) {
            return qt(t, "interval")
        },
        loadFunctionTypes: Ut,
        getFunctionTypeResources: Jt
    });
    function Xt(t) {
        t = {
            stroke: {
                stroke: t.markerLineColor,
                "stroke-width": t.markerLineWidth,
                "stroke-opacity": t.markerLineOpacity,
                "stroke-dasharray": null,
                "stroke-linecap": "butt",
                "stroke-linejoin": "round"
            },
            fill: {
                fill: t.markerFill,
                "fill-opacity": t.markerFillOpacity
            }
        };
        return 0 === t.stroke["stroke-width"] && (t.stroke["stroke-opacity"] = 0),
            t
    }
    function Kt(t, e, i) {
        if (!t.markerPath)
            return null;
        var n = 1
            , r = Xt(t)
            , o = (P(t.markerOpacity) && (n = t.markerOpacity),
        P(t.opacity) && (n *= t.opacity),
            {});
        if (r) {
            for (var s in r.stroke)
                !r.stroke.hasOwnProperty(s) || V(r.stroke[s]) || (o[s] = r.stroke[s]);
            for (var a in r.fill)
                !r.fill.hasOwnProperty(a) || V(r.fill[a]) || (o[a] = r.fill[a])
        }
        for (var h, l = Array.isArray(t.markerPath) ? t.markerPath : [t.markerPath], u = [], c = 0; c < l.length; c++)
            (h = m({}, h = b(l[c]) ? {
                path: l[c]
            } : l[c], o)).d = h.path,
                delete h.path,
                u.push(h);
        var d = ['<svg version="1.1"', 'xmlns="http://www.w3.org/2000/svg"'];
        n < 1 && d.push('opacity="' + n + '"'),
        t.markerPathWidth && t.markerPathHeight && d.push('viewBox="0 0 ' + t.markerPathWidth + " " + t.markerPathHeight + '"'),
            d.push('preserveAspectRatio="none"'),
        e && d.push('width="' + e + '"'),
        i && d.push('height="' + i + '"'),
            d.push("><defs></defs>");
        for (var g = 0; g < u.length; g++) {
            var p, f = "<path ";
            for (p in u[g])
                u[g].hasOwnProperty(p) && (f += " " + p + '="' + u[g][p] + '"');
            f += "></path>",
                d.push(f)
        }
        return d.push("</svg>"),
        "data:image/svg+xml;base64," + yt(d.join(" "))
    }
    function Qt(t, e) {
        if (!t)
            return [];
        for (var i, n, r, o = t, s = (Array.isArray(t) || (o = [t]),
            []), a = z, h = o.length - 1; 0 <= h; h--)
            if (t = o[h]) {
                e && (t = $t(t));
                for (var l = 0; l < a.length; l++)
                    if (c = Wt(c = t[a[l]]) ? Jt(c) : c) {
                        Array.isArray(c) || (c = [c]);
                        for (var u = 0; u < c.length; u++)
                            "url(" === c[u].slice(0, 4) && (c[u] = _t(c[u])),
                                s.push([c[u], t[(i = Z[l])[0]], t[i[1]]])
                    }
                if ("path" === t.markerType && t.markerPath)
                    if (n = Wt(t.markerWidth) ? 200 : t.markerWidth,
                        r = Wt(t.markerHeight) ? 200 : t.markerHeight,
                        Wt(t.markerPath)) {
                        for (var c = Jt(t.markerPath), d = t.markerPath, g = 0; g < c.length; g++)
                            t.markerPath = c[g],
                                s.push([Kt(t), n, r]);
                        t.markerPath = d
                    } else
                        s.push([Kt(t), n, r])
            }
        return s
    }
    function $t(t) {
        if (!t)
            return null;
        var e = t;
        if ($)
            return e;
        for (var i, n = z, r = 0, o = n.length; r < o; r++)
            (i = e[n[r]]) && (e[n[r]] = function t(e) {
                if (Wt(e)) {
                    for (var i = e.stops, n = 0; n < i.length; n++)
                        i[n][1] = t(i[n][1]);
                    return e
                }
                "url(" === e.slice(0, 4) && (e = _t(e));
                return e
            }(i));
        return e
    }
    function te(t) {
        return t && t.colorStops
    }
    function ee(t) {
        var e = [t.type];
        if (t.places && e.push(t.places.join()),
            t.colorStops) {
            for (var i = [], n = t.colorStops.length - 1; 0 <= n; n--)
                i.push(t.colorStops[n].join());
            e.push(i.join(","))
        }
        return e.join("_")
    }
    function ie(t) {
        var e, i = [];
        if (Array.isArray(t)) {
            for (var n = 0; n < t.length; n++)
                i.push(ie(t[n]));
            return "[ " + i.join(" , ") + " ]"
        }
        for (e in t)
            !J(t, e) || p(t[e]) || (te(t[e]) ? i.push(e + "=" + ee(t[e])) : i.push(e + "=" + t[e]));
        return i.join(";")
    }
    function ne(t, e) {
        function i(t, e) {
            V(t.opacity) ? t.opacity = e : t.opacity *= e
        }
        if (Array.isArray(t))
            for (var n = [], r = 0; r < t.length; r++) {
                var o = m({}, t[r]);
                i(o, e),
                    n.push(o)
            }
        else
            i(n = m({}, t), e);
        return n
    }
    function re(t) {
        var e, i = Array.prototype.slice.call(arguments, 1);
        if (i && i.length || (i = [{}]),
            Array.isArray(t)) {
            for (var n = [], r = 0, o = t.length; r < o; r++) {
                for (var s = t[r], a = {}, h = 0, l = i.length; h < l; h++)
                    Array.isArray(i[h]) ? V(i[h][r]) ? m(a, s || {}) : m(a, s, i[h][r]) : m(a, s, i[h] || {});
                n.push(a)
            }
            return n
        }
        return (e = [{}, t]).push.apply(e, i),
            m.apply(this, e)
    }
    function oe(t) {
        if (t.symbol && (t = [t]),
            Array.isArray(t))
            return t;
        var e = t.$root
            , i = t.$iconset;
        return t = t.style,
        (e || i) && (e && "/" === e[e.length - 1] && (e = e.substring(0, e.length - 1)),
        i && "/" === i[i.length - 1] && (i = i.substring(0, i.length - 1)),
            se(t, function(t) {
                return "{$root}" === t ? e : "{$iconset}" === t ? i : null
            })),
            t
    }
    function se(t, e) {
        for (var i = 0; i < t.length; i++) {
            var n = t[i].symbol;
            n && he(n, e)
        }
    }
    var ae = /(\{\$root\}|\{\$iconset\})/g;
    function he(t, e) {
        for (var i in t)
            t.hasOwnProperty(i) && "textName" !== i && (b(t[i]) && 2 < t[i].length ? t[i] = t[i].replace(ae, e) : Wt(t[i]) ? t[i] = function t(e, i) {
                var n = e.default;
                b(n) && (e.default = n.replace(ae, i));
                var r = e.stops;
                for (var o = 0; o < r.length; o++)
                    Array.isArray(r[o]) && (b(r[o][1]) ? r[o][1] = r[o][1].replace(ae, i) : Wt(r[o][1]) && (r[o][1] = t(r[o][1], i)));
                return e
            }(t[i], e) : W(t[i]) && he(t[i], e))
    }
    var le = Object.freeze({
        now: F,
        extend: m,
        isNil: V,
        isNumber: P,
        isInteger: N,
        isObject: W,
        isString: b,
        isFunction: p,
        hasOwn: J,
        join: function(t, e) {
            return t.join ? t.join(e || ",") : Array.prototype.join.call(t, e || ",")
        },
        isEmpty: function(t) {
            for (var e in t)
                return !1;
            return !e
        },
        toRadian: Y,
        toDegree: X,
        IS_NODE: $,
        get requestAnimFrame() {
            return K
        },
        get cancelAnimFrame() {
            return Q
        },
        isSVG: tt,
        loadImage: et,
        UID: nt,
        GUID: nt,
        parseJSON: rt,
        pushIn: ot,
        removeFromArray: st,
        forEachCoord: at,
        getValueOrDefault: r,
        sign: ht,
        log2: lt,
        interpolate: ut,
        wrap: ct,
        clamp: dt,
        isArrayHasData: L,
        isURL: function(t) {
            return gt.test(t)
        },
        isCssUrl: mt,
        extractCssUrl: _t,
        btoa: yt,
        b64toBlob: vt,
        computeDegree: xt,
        emptyImageUrl: wt,
        equalMapView: Ct,
        flash: bt,
        _defaults: function(t, e) {
            for (var i = Object.getOwnPropertyNames(e), n = 0; n < i.length; n++) {
                var r = i[n]
                    , o = Object.getOwnPropertyDescriptor(e, r);
                o && o.configurable && void 0 === t[r] && Object.defineProperty(t, r, o)
            }
            return t
        },
        translateToSVGStyles: Xt,
        getMarkerPathBase64: Kt,
        getExternalResources: Qt,
        convertResourceUrl: $t,
        isGradient: te,
        getGradientStamp: ee,
        getSymbolStamp: ie,
        lowerSymbolOpacity: ne,
        extendSymbol: re,
        parseStyleRootPath: oe,
        convertStylePath: se,
        parseSymbolPath: he
    })
        , e = {};
    if (!$) {
        var ue = navigator.userAgent.toLowerCase()
            , ce = document.documentElement
            , i = "ActiveXObject"in window
            , de = -1 !== ue.indexOf("webkit")
            , ge = -1 !== ue.indexOf("phantom")
            , pe = -1 !== ue.search("android [23]")
            , fe = -1 !== ue.indexOf("chrome")
            , me = -1 !== ue.indexOf("gecko") && !de && !window.opera && !i
            , _e = "undefined" != typeof orientation || -1 !== ue.indexOf("mobile")
            , n = !window.PointerEvent && window.MSPointerEvent
            , ye = window.PointerEvent && navigator.pointerEnabled || n
            , ve = i && "transition"in ce.style
            , xe = "WebKitCSSMatrix"in window && "m11"in new window.WebKitCSSMatrix && !pe
            , we = "MozPerspective"in ce.style
            , ce = "OTransition"in ce.style
            , Ce = (ve || xe || we) && !ce && !ge
            , Pe = 0
            , be = (fe && (Pe = ue.match(/chrome\/([\d.]+)/)[1]),
        !ge && (ye || "ontouchstart"in window || window.DocumentTouch && document instanceof window.DocumentTouch));
        try {
            var Me = document.createElement("canvas")
                , o = Me.getContext("webgl") || Me.getContext("experimental-webgl")
                , Se = o && o instanceof WebGLRenderingContext
        } catch (t) {
            Se = !1
        }
        Me = window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI,
            e = {
                ie: i,
                ielt9: i && !document.addEventListener,
                edge: "msLaunchUri"in navigator && !("documentMode"in document),
                webkit: de,
                gecko: me,
                android: -1 !== ue.indexOf("android"),
                android23: pe,
                chrome: fe,
                chromeVersion: Pe,
                safari: !fe && -1 !== ue.indexOf("safari"),
                phantomjs: ge,
                ie3d: ve,
                webkit3d: xe,
                gecko3d: we,
                opera12: ce,
                any3d: Ce,
                mobile: _e,
                mobileWebkit: _e && de,
                mobileWebkit3d: _e && xe,
                mobileOpera: _e && window.opera,
                mobileGecko: _e && me,
                touch: !!be,
                msPointer: !!n,
                pointer: !!ye,
                retina: 1 < Me,
                devicePixelRatio: Me,
                language: navigator.browserLanguage || navigator.language,
                ie9: i && 9 === document.documentMode,
                ie10: i && 10 === document.documentMode,
                webgl: Se
            }
    }
    var c = e;
    function s(t, e) {
        t.prototype = Object.create(e.prototype),
            Te(t.prototype.constructor = t, e)
    }
    function Te(t, e) {
        return (Te = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e,
                    t
            }
        )(t, e)
    }
    function Ee(t) {
        if (void 0 === t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    (o = ke.prototype).set = function(t, e) {
        return this.x = t,
            this.y = e,
            this
    }
        ,
        o.abs = function() {
            return new this.constructor(Math.abs(this.x),Math.abs(this.y))
        }
        ,
        o._abs = function() {
            return this.x = Math.abs(this.x),
                this.y = Math.abs(this.y),
                this
        }
        ,
        o._round = function() {
            return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
        }
        ,
        o.round = function() {
            return new this.constructor(Math.round(this.x),Math.round(this.y))
        }
        ,
        o._ceil = function() {
            return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
        }
        ,
        o.ceil = function() {
            return new this.constructor(Math.ceil(this.x),Math.ceil(this.y))
        }
        ,
        o.distanceTo = function(t) {
            var e = t.x - this.x
                , t = t.y - this.y;
            return Math.sqrt(e * e + t * t)
        }
        ,
        o._floor = function() {
            return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
        }
        ,
        o.floor = function() {
            return new this.constructor(Math.floor(this.x),Math.floor(this.y))
        }
        ,
        o.copy = function() {
            return new this.constructor(this.x,this.y)
        }
        ,
        o._add = function(t, e) {
            return V(t.x) ? V(t[0]) ? (this.x += t,
                this.y += e) : (this.x += t[0],
                this.y += t[1]) : (this.x += t.x,
                this.y += t.y),
                this
        }
        ,
        o.add = function(t, e) {
            var i, e = V(t.x) ? V(t[0]) ? (i = this.x + t,
            this.y + e) : (i = this.x + t[0],
            this.y + t[1]) : (i = this.x + t.x,
            this.y + t.y);
            return new this.constructor(i,e)
        }
        ,
        o._sub = function(t, e) {
            return V(t.x) ? V(t[0]) ? (this.x -= t,
                this.y -= e) : (this.x -= t[0],
                this.y -= t[1]) : (this.x -= t.x,
                this.y -= t.y),
                this
        }
        ,
        o._substract = function() {
            return this._sub.apply(this, arguments)
        }
        ,
        o.sub = function(t, e) {
            var i, e = V(t.x) ? V(t[0]) ? (i = this.x - t,
            this.y - e) : (i = this.x - t[0],
            this.y - t[1]) : (i = this.x - t.x,
            this.y - t.y);
            return new this.constructor(i,e)
        }
        ,
        o.substract = function() {
            return this.sub.apply(this, arguments)
        }
        ,
        o.multi = function(t) {
            return new this.constructor(this.x * t,this.y * t)
        }
        ,
        o._multi = function(t) {
            return this.x *= t,
                this.y *= t,
                this
        }
        ,
        o.div = function(t) {
            return this.multi(1 / t)
        }
        ,
        o._div = function(t) {
            return this._multi(1 / t)
        }
        ,
        o.equals = function(t) {
            return t instanceof this.constructor && (this.x === t.x && this.y === t.y)
        }
        ,
        o._isNaN = function() {
            return isNaN(this.x) || isNaN(this.y)
        }
        ,
        o.isZero = function() {
            return 0 === this.x && 0 === this.y
        }
        ,
        o.toArray = function() {
            return [this.x, this.y]
        }
        ,
        o.toFixed = function(t) {
            return new this.constructor(this.x.toFixed(t),this.y.toFixed(t))
        }
        ,
        o.toJSON = function() {
            return {
                x: this.x,
                y: this.y
            }
        }
    ;
    pe = ke;
    function ke(t, e) {
        if (V(t) || V(e) ? V(t.x) || V(t.y) ? Array.isArray(t) && (this.x = +t[0],
            this.y = +t[1]) : (this.x = +t.x,
            this.y = +t.y) : (this.x = +t,
            this.y = +e),
            this._isNaN())
            throw new Error("Position is NaN")
    }
    s(Ae, Re = pe),
        (Pe = Ae.prototype).closeTo = function(t, e) {
            return this.x >= t.x - (e = e || 0) && this.x <= t.x + e && this.y >= t.y - e && this.y <= t.y + e
        }
        ,
        Pe.mag = function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        ,
        Pe.unit = function() {
            return this.copy()._unit()
        }
        ,
        Pe._unit = function() {
            return this._div(this.mag()),
                this
        }
        ,
        Pe.perp = function() {
            return this.copy()._perp()
        }
        ,
        Pe._perp = function() {
            var t = this.y;
            return this.y = this.x,
                this.x = -t,
                this
        }
        ,
        Pe.angleWith = function(t) {
            return this.angleWithSep(t.x, t.y)
        }
        ,
        Pe.angleWithSep = function(t, e) {
            return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e)
        }
        ,
        Pe._rotate = function(t) {
            var e = Math.cos(t)
                , t = Math.sin(t)
                , i = e * this.x - t * this.y
                , t = t * this.x + e * this.y;
            return this.x = i,
                this.y = t,
                this
        }
        ,
        Pe.rotate = function(t) {
            return this.copy()._rotate(t)
        }
    ;
    var Re, R = Ae;
    function Ae() {
        return Re.apply(this, arguments) || this
    }
    (fe = Oe.prototype).copy = function() {
        return new Oe(this.width,this.height)
    }
        ,
        fe.add = function(t, e) {
            var i, t = t instanceof Oe ? (i = this.width + t.width,
            this.height + t.height) : (i = this.width + t,
            this.height + e);
            return new Oe(i,t)
        }
        ,
        fe.equals = function(t) {
            return this.width === t.width && this.height === t.height
        }
        ,
        fe.multi = function(t) {
            return new Oe(this.width * t,this.height * t)
        }
        ,
        fe._multi = function(t) {
            return this.width *= t,
                this.height *= t,
                this
        }
        ,
        fe._round = function() {
            return this.width = Math.round(this.width),
                this.height = Math.round(this.height),
                this
        }
        ,
        fe.toPoint = function() {
            return new R(this.width,this.height)
        }
        ,
        fe.toArray = function() {
            return [this.width, this.height]
        }
        ,
        fe.toJSON = function() {
            return {
                width: this.width,
                height: this.height
            }
        }
    ;
    var Le = Oe;
    function Oe(t, e) {
        P(t) && P(e) ? (this.width = t,
            this.height = e) : P(t.width) ? (this.width = t.width,
            this.height = t.height) : Array.isArray(t) && (this.width = t[0],
            this.height = t[1])
    }
    function De(t) {
        return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
    }
    var Ie = /[\b\t\r\v\f]/gim;
    function je(t) {
        return b(t) ? t.replace(Ie, "") : t
    }
    function ze(t) {
        return De(t).split(/\s+/)
    }
    var Ze = "undefined" != typeof document ? document.createElement("canvas").getContext("2d") : null;
    function He(t, e) {
        if (He.node)
            return He.node(t, e);
        try {
            if (Ze)
                return Ze.font = e,
                    Ze.measureText(t).width
        } catch (t) {}
        e = t.replace(/\D/g, "").length;
        return 12 * (t.length - e) + 8 * e
    }
    function Ge(t, e, i) {
        t = He(t, e);
        return new Le(t,i || 14)
    }
    function Fe(t, e, i, n) {
        if (!t || 0 === t.length)
            return [{
                text: "",
                width: 0
            }];
        var e = V(n) ? He(t, e) : n
            , r = e / t.length
            , o = Math.floor(i / r / 2);
        if (i <= r || o <= 0)
            return [{
                text: "",
                width: i
            }];
        if (e <= i)
            return [{
                text: t,
                width: e
            }];
        for (var s = [], a = t.substring(0, o), h = r * o, l = o, u = t.length; l < u; l++) {
            var c = t[l]
                , d = He(a + c)
                , h = i <= d ? (s.push({
                text: a,
                width: h
            }),
                a = t.substring(l, o + l),
                l += o - 1,
            r * o) : (a += c,
                d);
            u - 1 <= l && (h = He(a),
                s.push({
                    text: a,
                    width: h
                }))
        }
        return s
    }
    var Ne = /\{([\w_]+)\}/g;
    function We(t, i) {
        return b(t) ? t.replace(Ne, function(t, e) {
            if (!i)
                return "";
            e = i[e];
            return V(e) ? "" : Array.isArray(e) ? e.join() : e
        }) : t
    }
    function Be(t, e, i) {
        var n = t.width
            , t = t.height
            , e = "left" === e ? -n : "right" === e ? 0 : -n / 2
            , n = "top" === i ? -t : "bottom" === i ? 0 : -t / 2;
        return new R(e,n)
    }
    function Ve(t) {
        return t.textFont || (t.textStyle && "normal" !== t.textStyle ? t.textStyle + " " : "") + (t.textWeight && "normal" !== t.textWeight ? t.textWeight + " " : "") + t.textSize + "px " + (t.textFaceName ? '"' === t.textFaceName[0] ? t.textFaceName : '"' + t.textFaceName + '"' : "monospace")
    }
    function Ue(t, e) {
        var i = Ve(e)
            , n = e.textLineSpacing || 0
            , r = Ge(t, i, e.textSize)
            , o = r.width
            , s = r.height
            , a = e.textWrapCharacter
            , h = []
            , l = e.textWrapWidth
            , u = ((!l || o < l) && (l = o),
        b(t) || (t += ""),
            0);
        if (a && 0 <= t.indexOf(a))
            for (var c = t.split(a), d = 0, g = c.length; d < g; d++) {
                var p = c[d]
                    , f = He(p, i);
                if (l < f)
                    for (var m = Fe(p, i, l, f), _ = 0, y = m.length; _ < y; _++) {
                        var v = m[_].width;
                        u < v && (u = v),
                            h.push({
                                text: m[_].text,
                                size: new Le(v,s)
                            })
                    }
                else
                    u < f && (u = f),
                        h.push({
                            text: p,
                            size: new Le(f,s)
                        })
            }
        else if (l < o)
            for (var x = Fe(t, i, l, o), w = 0; w < x.length; w++) {
                var C = x[w].width;
                u < C && (u = C),
                    h.push({
                        text: x[w].text,
                        size: new Le(C,s)
                    })
            }
        else
            u < o && (u = o),
                h.push({
                    text: t,
                    size: r
                });
        e = h.length;
        return {
            total: e,
            size: new Le(u,s * e + n * (e - 1)),
            rows: h,
            rawSize: r
        }
    }
    var ue = Object.freeze({
        trim: De,
        escapeSpecialChars: je,
        splitWords: ze,
        stringWidth: He,
        stringLength: Ge,
        getFontHeight: function(t) {
            var e = fi("span")
                , t = ("_default_" !== t && (e.style.font = t),
                e.innerHTML = "\u79e6",
                e.clientHeight);
            return Ke(e),
                t
        },
        splitContent: Fe,
        replaceVariable: We,
        getAlignPoint: Be,
        getFont: Ve,
        splitTextToRow: Ue
    })
        , ge = $ ? function(t) {
            return t[0]
        }
        : function(t) {
            for (var e = document.documentElement.style, i = 0; i < t.length; i++)
                if (t[i]in e)
                    return t[i];
            return !1
        }
        , Je = ge(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"])
        , qe = ge(["transformOrigin", "WebkitTransformOrigin", "OTransformOrigin", "MozTransformOrigin", "msTransformOrigin"])
        , Ye = ge(["transition", "WebkitTransition", "OTransition", "MozTransition", "msTransition"])
        , ve = ge(["filter", "WebkitFilter", "OFilter", "MozFilter", "msFilter"]);
    function f(t, e) {
        t = document.createElement(t);
        return e && ui(t, e),
            t
    }
    function Xe(t, e, i) {
        t = f(t);
        return e && ai(t, e),
        i && i.appendChild(t),
            t
    }
    function Ke(t) {
        return t && (c.ielt9 || c.ie9 ? ((e = f("div")).appendChild(t),
            e.innerHTML = "",
            e = null) : t.parentNode && t.parentNode.removeChild(t)),
            this;
        var e
    }
    function Qe(e, t, i, n) {
        if (!(e && e.addEventListener && t && i))
            return this;
        for (var r = function(t) {
            t = t || window.event,
                i.call(n || e, t)
        }, o = t.split(" "), s = o.length - 1; 0 <= s; s--) {
            var a = o[s];
            a && (e["Z__" + a] || (e["Z__" + a] = []),
            0 <= ti(e, a, i) && $e(e, a, i),
                e["Z__" + a].push({
                    callback: r,
                    src: i
                }),
                c.ie ? e.addEventListener(a, r, !1) : e.addEventListener(a, r, {
                    capture: !1,
                    passive: !1
                }))
        }
        return this
    }
    function $e(i, t, e) {
        function n(t, e) {
            "mousewheel" === t && c.gecko && (t = "DOMMouseScroll"),
                i.removeEventListener(t, e, !1)
        }
        if (!i || !i.removeEventListener || !t)
            return this;
        for (var r = t.split(" "), o = r.length - 1; 0 <= o; o--) {
            var s = r[o];
            if (s) {
                if (!e && i["Z__" + s]) {
                    for (var a = i["Z__" + s], h = 0, l = a.length; h < l; h++)
                        n(a[h].callback);
                    return delete i["Z__" + s],
                        this
                }
                var u = ti(i, s, e);
                if (u < 0)
                    return this;
                n(s, i["Z__" + s][u].callback),
                    i["Z__" + s].splice(u, 1)
            }
        }
        return this
    }
    function ti(t, e, i) {
        if (!t || !t["Z__" + e] || !i)
            return -1;
        for (var n = t["Z__" + e], r = 0, o = n.length; r < o; r++)
            if (n[r].src === i)
                return r;
        return -1
    }
    function ei(t) {
        return t.preventDefault ? t.preventDefault() : t.returnValue = !1,
            this
    }
    function ii(t) {
        return t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0,
            this
    }
    function ni(t) {
        return t.onselectstart = function() {
            return !1
        }
            ,
            t.ondragstart = function() {
                return !1
            }
            ,
            t.setAttribute("unselectable", "on"),
            this
    }
    function ri(t, e) {
        return t ? (c.any3d ? di(t, e) : (t.style.left = e.x + "px",
            t.style.top = e.y + "px"),
            e) : null
    }
    function oi(t) {
        var e = window.getComputedStyle(t)
            , e = [parseInt(e["padding-left"]), parseInt(e["padding-top"])]
            , i = t.getBoundingClientRect()
            , n = t.offsetWidth
            , r = t.offsetHeight
            , n = n ? i.width / n : 1
            , r = r ? i.height / r : 1;
        return t.__position = [i.left + e[0], i.top + e[1], n, r],
            t.__position
    }
    function si(t, e) {
        t = t || window.event;
        var i = (i = e.__position) || oi(e);
        return new R((t.clientX - i[0] - e.clientLeft) / i[2],(t.clientY - i[1] - e.clientTop) / i[3])
    }
    function ai(t, e) {
        var i, n, r, o = t.style.cssText;
        return n = ";",
        0 <= (r = (i = o).length - n.length) && i.indexOf(n, r) === r || (o += ";"),
            t.style.cssText = o + e,
            this
    }
    function hi(t, e) {
        if (void 0 !== t.classList)
            return t.classList.contains(e);
        t = ci(t);
        return 0 < t.length && new RegExp("(^|\\s)" + e + "(\\s|$)").test(t)
    }
    function li(t, e) {
        if (void 0 === t.classList || hi(t, e)) {
            var i = ci(t);
            ui(t, (i ? i + " " : "") + e)
        } else
            for (var n = ze(e), r = 0, o = n.length; r < o; r++)
                t.classList.add(n[r]);
        return this
    }
    function ui(t, e) {
        return V(t.className.baseVal) ? t.className = e : t.className.baseVal = e,
            this
    }
    function ci(t) {
        return V(t.className.baseVal) ? t.className : t.className.baseVal
    }
    function di(t, e) {
        e = e || new R(0,0);
        return t.style[Je] = c.any3d ? "translate3d(" + e.x + "px," + e.y + "px,0px)" : "translate(" + e.x + "px," + e.y + "px)",
            this
    }
    function gi(t) {
        return /<[a-z\][\s\S]*>/i.test(t)
    }
    function pi(t, e) {
        t = fi(t),
            b(e) ? t.innerHTML = e : t.appendChild(e),
            e = new Le(t.clientWidth,t.clientHeight);
        return Ke(t),
            e
    }
    function fi(t) {
        t = document.createElement(t);
        return t.style.cssText = "position:absolute;left:-10000px;top:-10000px;",
            document.body.appendChild(t),
            t
    }
    var _ = Qe
        , mi = $e
        , we = Object.freeze({
        TRANSFORM: Je,
        TRANSFORMORIGIN: qe,
        TRANSITION: Ye,
        CSSFILTER: ve,
        createEl: f,
        createElOn: Xe,
        removeDomNode: Ke,
        addDomEvent: Qe,
        removeDomEvent: $e,
        listensDomEvent: ti,
        preventDefault: ei,
        stopPropagation: ii,
        preventSelection: ni,
        offsetDom: ri,
        computeDomPosition: oi,
        getEventContainerPoint: si,
        setStyle: ai,
        hasClass: hi,
        addClass: li,
        setClass: ui,
        getClass: ci,
        setOpacity: function(t, e) {
            return t.style.opacity = e,
                this
        },
        setTransform: di,
        setTransformMatrix: function(t, e) {
            return e = "matrix(" + (b(e) ? e : e.join()) + ")",
            t.style[Je] !== e && (t.style[Je] = e),
                this
        },
        removeTransform: function(t) {
            return t.style[Je] && (t.style[Je] = ""),
                this
        },
        isHTML: gi,
        measureDom: pi,
        getDomRuler: fi,
        on: _,
        off: mi
    })
        , _i = {
        jsonp: function(t, e) {
            var i = "_maptalks_jsonp_" + it++
                , n = (t.match(/\?/) ? t += "&callback=" + i : t += "?callback=" + i,
                document.createElement("script"));
            return n.type = "text/javascript",
                n.src = t,
                window[i] = function(t) {
                    e(null, t),
                        document.getElementsByTagName("head")[0].removeChild(n),
                        n = null,
                        delete window[i]
                }
                ,
                document.getElementsByTagName("head")[0].appendChild(n),
                this
        },
        get: function(t, e, i) {
            var n;
            if (p(e) && (n = i,
                i = e,
                e = n),
            $ && _i.get.node)
                return _i.get.node(t, i, e);
            var r = _i._getClient(i);
            if (r.open("GET", t, !0),
                e) {
                for (var o in e.headers)
                    r.setRequestHeader(o, e.headers[o]);
                r.withCredentials = "include" === e.credentials,
                e.responseType && (r.responseType = e.responseType)
            }
            return r.send(null),
                r
        },
        post: function(t, e, i) {
            var n, r;
            if (b(t) ? (p(e) && (r = i,
                i = e,
                e = r),
                r = (e = e || {}).postData) : (n = i,
                r = e,
                t = (e = t).url,
                i = n),
            $ && _i.post.node)
                return e.url = t,
                    _i.post.node(e, r, i);
            var o = _i._getClient(i);
            if (o.open("POST", e.url, !0),
            e.headers || (e.headers = {}),
            e.headers["Content-Type"] || (e.headers["Content-Type"] = "application/x-www-form-urlencoded"),
            "setRequestHeader"in o)
                for (var s in e.headers)
                    e.headers.hasOwnProperty(s) && o.setRequestHeader(s, e.headers[s]);
            return b(r) || (r = JSON.stringify(r)),
                o.send(r),
                o
        },
        _wrapCallback: function(t, e) {
            return function() {
                4 === t.readyState && (200 === t.status ? "arraybuffer" === t.responseType ? 0 === t.response.byteLength ? e(new Error("http status 200 returned without content.")) : e(null, {
                    data: t.response,
                    cacheControl: t.getResponseHeader("Cache-Control"),
                    expires: t.getResponseHeader("Expires"),
                    contentType: t.getResponseHeader("Content-Type")
                }) : e(null, t.responseText) : e(new Error(t.statusText + "," + t.status)))
            }
        },
        _getClient: function(t) {
            var e;
            try {
                e = new XMLHttpRequest
            } catch (t) {
                try {
                    e = new ActiveXObject("Msxml2.XMLHTTP")
                } catch (t) {
                    try {
                        e = new ActiveXObject("Microsoft.XMLHTTP")
                    } catch (t) {}
                }
            }
            return e.onreadystatechange = _i._wrapCallback(e, t),
                e
        },
        getArrayBuffer: function(t, e, i) {
            var n;
            return p(e) && (n = i,
                i = e,
                e = n),
                (e = e || {}).responseType = "arraybuffer",
                _i.get(t, e, i)
        },
        getImage: function(r, t, e) {
            return _i.getArrayBuffer(t, e, function(t, e) {
                var i, n;
                t ? r.onerror && r.onerror(t) : e && (i = window.URL || window.webkitURL,
                    n = r.onload,
                    r.onload = function() {
                        n && n(),
                            i.revokeObjectURL(r.src)
                    }
                    ,
                    t = new Blob([new Uint8Array(e.data)],{
                        type: e.contentType
                    }),
                    r.cacheControl = e.cacheControl,
                    r.expires = e.expires,
                    r.src = e.data.byteLength ? i.createObjectURL(t) : wt)
            })
        }
    }
        , yi = (_i.getJSON = function(t, e, i) {
        function n(t, e) {
            e = e ? rt(e) : null,
                i(t, e)
        }
        var r;
        p(e) && (r = i,
            i = e,
            e = r);
        return e && e.jsonp ? _i.jsonp(t, n) : _i.get(t, e, n)
    }
        ,
        !1)
        , vi = null
        , xi = Math.PI / 180
        , O = {
        setHitTesting: function(t) {
            yi = t
        },
        createCanvas: function(t, e, i) {
            var n;
            return $ ? n = new i(t,e) : ((n = f("canvas")).width = t,
                n.height = e),
                n
        },
        prepareCanvasFont: function(t, e) {
            t.textBaseline = "top",
                t.font = Ve(e);
            var i = (i = e.textFill) || "#000";
            t.fillStyle = O.getRgba(i, e.textOpacity)
        },
        prepareCanvas: function(t, e, i, n) {
            var r, o, s, a;
            e && (V(a = e.lineWidth) || t.lineWidth === a || (t.lineWidth = a),
                s = e.linePatternFile,
                o = e.lineColor || "#000",
                n ? t.strokeStyle = "#000" : s && i ? ((e.linePatternDx || e.linePatternDy) && (r = [e.linePatternDx, e.linePatternDy]),
                    O._setStrokePattern(t, s, a, r, i),
                    e.lineDasharray = []) : te(o) ? e.lineGradientExtent ? t.strokeStyle = O._createGradient(t, o, e.lineGradientExtent) : t.strokeStyle = "#000" : t.strokeStyle = o,
            e.lineJoin && (t.lineJoin = e.lineJoin),
            e.lineCap && (t.lineCap = e.lineCap),
            t.setLineDash && L(e.lineDasharray) && t.setLineDash(e.lineDasharray),
                s = e.polygonPatternFile,
                r = e.polygonFill || "rgba(255,255,255,0)",
                n ? t.fillStyle = "#000" : s && i ? (o = Ci(s),
                    n = (n = i.getImage([o, null, null])) || i.getImage([o + "-texture", null, a]),
                tt(o) && n instanceof Image && (c.edge || c.ie) && (s = n.width || 20,
                    i = n.height || 20,
                    a = O.createCanvas(s, i),
                    O.image(a.getContext("2d"), n, 0, 0, s, i),
                    n = a),
                    n ? (t.fillStyle = t.createPattern(n, "repeat"),
                    (e.polygonPatternDx || e.polygonPatternDy) && (t.fillStyle.polygonPatternOffset = [e.polygonPatternDx, e.polygonPatternDy])) : "undefined" != typeof console && console.warn("img not found for", o)) : te(r) ? e.polygonGradientExtent ? t.fillStyle = O._createGradient(t, r, e.polygonGradientExtent) : t.fillStyle = "rgba(255,255,255,0)" : t.fillStyle = r)
        },
        _createGradient: function(t, e, i) {
            var n = null
                , r = e.places
                , o = i.getMin()
                , s = i.getMax()
                , a = i.getWidth()
                , h = i.getHeight();
            if (e.type && "linear" !== e.type) {
                if ("radial" === e.type) {
                    if (r) {
                        if (6 !== r.length)
                            throw new Error("A radial gradient's places should have 6 numbers.");
                        r = [o.x + r[0] * a, o.y + r[1] * h, a * r[2], o.x + r[3] * a, o.y + r[4] * h, a * r[5]]
                    } else
                        i = i.getCenter()._round(),
                            r = [i.x, i.y, Math.abs(i.x - o.x), i.x, i.y, 0];
                    n = t.createRadialGradient.apply(t, r)
                }
            } else {
                if (r) {
                    if (4 !== r.length)
                        throw new Error("A linear gradient's places should have 4 numbers.");
                    r = [o.x + r[0] * a, o.y + r[1] * h, o.x + r[2] * a, o.y + r[3] * h]
                } else
                    r = [o.x, o.y, s.x, o.y];
                n = t.createLinearGradient.apply(t, r)
            }
            return e.colorStops.forEach(function(t) {
                n.addColorStop.apply(n, t)
            }),
                n
        },
        _setStrokePattern: function(t, e, i, n, r) {
            var o, s, a, h, l, e = Ci(e);
            $ ? l = r.getImage([e, null, i]) : (l = r.getImage(o = e + "-texture-" + i)) || (s = r.getImage([e, null, null])) && (a = s.width && s.height ? Math.round(s.width * i / s.height) : i,
                h = O.createCanvas(a, i, t.canvas.constructor),
                O.image(h.getContext("2d"), s, 0, 0, a, i),
                r.addResource([o, null, i], h),
                l = h),
                l ? (t.strokeStyle = t.createPattern(l, "repeat"),
                    t.strokeStyle.linePatternOffset = n) : "undefined" != typeof console && console.warn("img not found for", e)
        },
        clearRect: function(t, e, i, n, r) {
            t.canvas._drawn = !1,
                t.clearRect(e, i, n, r)
        },
        fillCanvas: function(t, e, i, n) {
            var r, o, s, a;
            yi && (e = 1),
                t.canvas._drawn = !0,
            0 !== e && (r = O._isPattern(t.fillStyle),
                o = (s = t.fillStyle && t.fillStyle.polygonPatternOffset) ? s[0] : 0,
                s = s ? s[1] : 0,
            (e = V(e) ? 1 : e) < 1 && (a = t.globalAlpha,
                t.globalAlpha *= e),
            r && t.translate((i = i || 0) + o, (n = n || 0) + s),
                t.fill(),
            r && t.translate(-i - o, -n - s),
            e < 1 && (t.globalAlpha = a))
        },
        getRgba: function(t, e) {
            if (V(e) && (e = 1),
            "#" !== t[0])
                return t;
            var i, n, t = 7 === t.length ? (i = parseInt(t.substring(1, 3), 16),
                n = parseInt(t.substring(3, 5), 16),
                parseInt(t.substring(5, 7), 16)) : (i = 17 * parseInt(t.substring(1, 2), 16),
                n = 17 * parseInt(t.substring(2, 3), 16),
            17 * parseInt(t.substring(3, 4), 16));
            return "rgba(" + i + "," + n + "," + t + "," + e + ")"
        },
        image: function(t, e, i, n, r, o) {
            t.canvas._drawn = !0;
            try {
                P(r) && P(o) ? t.drawImage(e, i, n, r, o) : t.drawImage(e, i, n)
            } catch (t) {
                console && (console.warn("error when drawing image on canvas:", t),
                    console.warn(e))
            }
        },
        text: function(t, e, i, n, r) {
            O._textOnMultiRow(t, r.rows, n, i, r.size, r.rawSize)
        },
        _textOnMultiRow: function(t, e, i, n, r, o) {
            for (var s, a, r = Be(r, i.textHorizontalAlignment, i.textVerticalAlignment), h = o.height + i.textLineSpacing, l = n.add(0, r.y), u = i.textMaxHeight, c = 0, d = 0, g = e.length; d < g && (s = e[d].text,
                a = Be(e[d].size, i.textHorizontalAlignment, i.textVerticalAlignment),
                O._textOnLine(t, s, l.add(a.x, d * h), i.textHaloRadius, i.textHaloFill, i.textHaloOpacity),
                !(0 < u && (c += h) + o.height >= u)); d++)
                ;
        },
        _textOnLine: function(t, e, i, n, r, o) {
            var s, a, h = 0 !== (o = yi ? 1 : o) && 0 !== n, l = (t.textBaseline = "top",
                t.shadowBlur), u = t.shadowOffsetX, c = t.shadowOffsetY;
            h && (a = t.globalAlpha,
                t.globalAlpha *= o,
                t.miterLimit = 2,
                t.lineJoin = "round",
                t.lineCap = "round",
                t.lineWidth = 2 * n,
                t.strokeStyle = r,
                t.strokeText(e, i.x, i.y + 1),
                t.miterLimit = 10,
                t.globalAlpha = a,
                a = t.globalCompositeOperation,
                t.globalCompositeOperation = "destination-out",
                s = t.fillStyle,
                t.fillStyle = "#000"),
            l && h && (t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0),
                O.fillText(t, e, i),
            a && (t.globalCompositeOperation = a,
                O.fillText(t, e, i, s),
            l && (t.shadowBlur = l,
                t.shadowOffsetX = u,
                t.shadowOffsetY = c))
        },
        fillText: function(t, e, i, n) {
            t.canvas._drawn = !0,
            n && (t.fillStyle = n),
                t.fillText(e, i.x, i.y + 1)
        },
        _stroke: function(t, e, i, n) {
            var r, o, s, a;
            yi && (e = 1),
                t.canvas._drawn = !0,
            0 !== e && (r = (o = t.strokeStyle && t.strokeStyle.linePatternOffset) ? o[0] : 0,
                o = o ? o[1] : 0,
                s = O._isPattern(t.strokeStyle) && (!V(i) && !V(n) || !V(r) && !V(o)),
            (e = V(e) ? 1 : e) < 1 && (a = t.globalAlpha,
                t.globalAlpha *= e),
            s && t.translate((i = i || 0) + r, (n = n || 0) + o),
                t.stroke(),
            s && t.translate(-i - r, -n - o),
            e < 1 && (t.globalAlpha = a))
        },
        _path: function(t, e, i, n, r) {
            if (L(e))
                for (var o, s, a = L(i), h = !0 !== r && O._isPattern(t.strokeStyle), l = 0, u = e.length; l < u; l++)
                    if (o = e[l],
                    !a || t.setLineDash)
                        t.lineTo(o.x, o.y),
                        h && 0 < l && (s = e[l - 1],
                            g = o,
                            d = void 0,
                            g = xt((s = s).x, s.y, g.x, g.y),
                            t.save(),
                            d = Math.cos(g),
                            Math.abs(d) < 1e-7 ? t.translate(s.x - t.lineWidth / 2, s.y) : t.translate(s.x, s.y - t.lineWidth / 2 / d),
                            t.rotate(g),
                            O._stroke(t, n),
                            t.restore(),
                            t.beginPath(),
                            t.moveTo(o.x, o.y));
                    else if (a) {
                        if (l === u - 1)
                            break;
                        s = e[l + 1],
                            T = S = A = R = k = E = M = b = y = _ = m = f = P = C = w = x = v = p = g = d = c = void 0;
                        var c = t
                            , d = o
                            , g = s
                            , p = i
                            , f = function(t, e) {
                            return t <= e
                        }
                            , m = function(t, e) {
                            return e <= t
                        }
                            , _ = function(t, e) {
                            return Math.min(t, e)
                        }
                            , y = function(t, e) {
                            return Math.max(t, e)
                        }
                            , v = d.x
                            , x = d.y
                            , w = g.x
                            , C = g.y
                            , P = p
                            , b = {
                            thereYet: m,
                            cap: _
                        }
                            , M = {
                            thereYet: m,
                            cap: _
                        };
                        0 < x - C && (M.thereYet = f,
                            M.cap = y),
                        0 < v - w && (b.thereYet = f,
                            b.cap = y),
                            c.moveTo(v, x);
                        for (var S, T, E = v, k = x, R = 0, A = !0; !b.thereYet(E, w) || !M.thereYet(k, C); )
                            S = Math.atan2(C - x, w - v),
                                T = P[R],
                                E = b.cap(w, E + Math.cos(S) * T),
                                k = M.cap(C, k + Math.sin(S) * T),
                                A ? c.lineTo(E, k) : c.moveTo(E, k),
                                R = (R + 1) % P.length,
                                A = !A
                    }
        },
        path: function(t, e, i, n, r) {
            L(e) && (t.beginPath(),
                t.moveTo(e[0].x, e[0].y),
                O._path(t, e, r, i),
                O._stroke(t, i))
        },
        _multiClip: function(t, e) {
            if (e && 0 !== e.length)
                for (var i = 0, n = (e = e[0]).length; i < n; i++) {
                    var r = e[i]
                        , o = r.x
                        , r = r.y;
                    0 === i ? t.moveTo(o, r) : t.lineTo(o, r),
                    i === n - 1 && (o = e[0].x,
                        r = e[0].y,
                        t.lineTo(o, r))
                }
        },
        polygon: function(t, e, i, n, r, o) {
            if (t.isMultiClip)
                O._multiClip(t, e);
            else if (L(e)) {
                var s, a, h, l = O._isPattern(t.strokeStyle), u = L(r) && !t.setLineDash || l && !o, l = t;
                if (1 < (e = L(e[0]) ? e : [e]).length && !$ && (vi = vi || O.createCanvas(1, 1),
                    t.canvas._drawn = !1,
                    vi.width = t.canvas.width,
                    vi.height = t.canvas.height,
                    Pi(t = vi.getContext("2d"), l)),
                    u) {
                    for (t.save(),
                             a = 0,
                             h = e.length; a < h; a++)
                        L(e[a]) && (O._ring(t, e[a], null, 0, !0),
                            s = n,
                        0 < a && (t.globalCompositeOperation = "destination-out",
                            s = 1),
                            O.fillCanvas(t, s, e[a][0].x, e[a][0].y),
                            0 < a ? t.globalCompositeOperation = "source-over" : 1 < h && (t.fillStyle = "#fff"),
                            O._stroke(t, 0));
                    t.restore()
                }
                for (a = 0,
                         h = e.length; a < h; a++)
                    L(e[a]) && (o ? (O.paintSmoothLine(t, e[a], i, o, !0),
                        t.closePath()) : O._ring(t, e[a], r, i),
                    u || (s = n,
                    0 < a && (t.globalCompositeOperation = "destination-out",
                        s = 1),
                        O.fillCanvas(t, s, e[a][0].x, e[a][0].y),
                        0 < a ? t.globalCompositeOperation = "source-over" : 1 < h && (t.fillStyle = "#fff")),
                        O._stroke(t, i));
                1 < e.length && !$ && (l.drawImage(vi, 0, 0),
                    l.canvas._drawn = t.canvas._drawn,
                    Pi(l, t))
            }
        },
        _ring: function(t, e, i, n, r) {
            var o = O._isPattern(t.strokeStyle);
            r || !o || e[0].equals(e[e.length - 1]) || (e = e.concat([e[0]])),
                t.beginPath(),
                t.moveTo(e[0].x, e[0].y),
                O._path(t, e, i, n, r),
            o || t.closePath()
        },
        paintSmoothLine: function(t, e, i, n, r, o, s) {
            if (e)
                if (e.length <= 2 || !n)
                    O.path(t, e, i);
                else {
                    var a, h = e.length, l = r ? h : h - 1;
                    t.beginPath(),
                        t.moveTo(e[0].x, e[0].y),
                    void 0 !== s && (l -= Math.max(l - o - 1, 0));
                    for (var u, c, d, g, p, f, m, _, y, v = 0; v < l; v++) {
                        var x, w = e[v].x, C = e[v].y, P = void 0, b = void 0, M = void 0, S = void 0, T = void 0, E = void 0, b = v - 1 < 0 ? r ? (P = e[l - 1].x,
                            e[l - 1].y) : (P = e[v + 1].x,
                            e[v + 1].y) : (P = e[v - 1].x,
                            e[v - 1].y), S = v + 1 < h ? (M = e[v + 1].x,
                            e[v + 1].y) : (M = e[v + 1 - h].x,
                            e[v + 1 - h].y), E = v + 2 < h ? (T = e[v + 2].x,
                            e[v + 2].y) : r ? (T = e[v + 2 - h].x,
                            e[v + 2 - h].y) : (T = e[v].x,
                            e[v].y), w = (c = n,
                            d = v === l - 1 ? s : 1,
                            y = _ = p = g = y = _ = m = f = p = g = void 0,
                            g = ((P = P) + (w = w)) / 2,
                            p = ((b = b) + (C = C)) / 2,
                            f = (w + (x = M)) / 2,
                            m = (C + (u = S)) / 2,
                            _ = (x + (T = T)) / 2,
                            y = (u + (E = E)) / 2,
                            P = Math.sqrt((w - P) * (w - P) + (C - b) * (C - b)),
                            b = Math.sqrt((x - w) * (x - w) + (u - C) * (u - C)),
                            P /= P + b,
                            b /= b + Math.sqrt((T - x) * (T - x) + (E - u) * (E - u)),
                            T = g + (f - g) * P,
                            E = p + (m - p) * P,
                            g = f + (_ - f) * b,
                            p = m + (y - m) * b,
                            P = T + (f - T) * c + w - T,
                            _ = E + (m - E) * c + C - E,
                            y = g + (f - g) * c + x - g,
                            b = p + (m - p) * c + u - p,
                            d < 1 ? [(w * (E = 1 - (T = 0)) * E + 2 * P * T * E + y * T * T) * (f = 1 - d) + (P * E * E + 2 * y * T * E + x * T * T) * d, (C * E * E + 2 * _ * T * E + b * T * T) * f + (_ * E * E + 2 * b * T * E + u * T * T) * d, (g = w * f * f + 2 * P * d * f + y * d * d) * E + (m = P * f * f + 2 * y * d * f + x * d * d) * T, (c = C * f * f + 2 * _ * d * f + b * d * d) * E + (p = _ * f * f + 2 * b * d * f + u * d * d) * T, g * f + m * d, c * f + p * d] : [P, _, y, b]);
                        v === l - 1 && 0 <= s && s < 1 ? (t.bezierCurveTo(w[0], w[1], w[2], w[3], w[4], w[5]),
                            e.splice(l - 1, h - (l - 1) - 1),
                            (x = new R(w[4],w[5])).prevCtrlPoint = new R(w[2],w[3]),
                            e.push(x),
                            h = e.length) : t.bezierCurveTo(w[0], w[1], w[2], w[3], M, S),
                            e[v].nextCtrlPoint = w.slice(0, 2),
                            e[v].prevCtrlPoint = a ? a.slice(2) : null,
                            a = w
                    }
                    !r && e[1].prevCtrlPoint && (e[0].nextCtrlPoint = e[1].prevCtrlPoint,
                        delete e[0].prevCtrlPoint),
                    e[h - 1].prevCtrlPoint || (e[h - 1].prevCtrlPoint = e[h - 2].nextCtrlPoint),
                        O._stroke(t, i)
                }
        },
        _arcBetween: function(t, e, i, n) {
            var r = e.distanceTo(i)
                , o = r / 2 / Math.sin(n / 2)
                , r = Math.asin((i.y - e.y) / r)
                , s = (e.x > i.x && (r = Math.PI - r),
            90 * xi - n / 2)
                , r = r - s
                , s = Math.cos(r) * o
                , r = Math.sin(r) * o
                , s = e.x + s
                , e = e.y + r
                , r = Math.asin((i.y - e) / o)
                , i = (r = s > i.x ? Math.PI - r : r) + n;
            return t.beginPath(),
                t.arc(s, e, o, r, i),
                [s, e]
        },
        _lineTo: function(t, e) {
            t.lineTo(e.x, e.y)
        },
        bezierCurveAndFill: function(t, e, i, n) {
            t.beginPath();
            var r = e[0]
                , r = (t.moveTo(r.x, r.y),
                [t]);
            r.push.apply(r, e.splice(1)),
                O._bezierCurveTo.apply(O, r),
                O.fillCanvas(t, n),
                O._stroke(t, i)
        },
        _bezierCurveTo: function(t, e, i, n) {
            t.bezierCurveTo(e.x, e.y, i.x, i.y, n.x, n.y)
        },
        ellipse: function(t, e, i, n, r, o, s) {
            var a, h, l, u, c, d, g;
            t.beginPath(),
                i === n && i === r ? t.arc(e.x, e.y, i, 0, 2 * Math.PI) : t.ellipse ? n !== r ? (t.ellipse(e.x, e.y, i, n, 0, 180 * xi, 360 * xi, !1),
                    t.ellipse(e.x, e.y, i, r, 0, 0, 180 * xi, !1)) : t.ellipse(e.x, e.y, i, n, 0, 0, 360 * xi, !1) : (a = e.x,
                    h = e.y,
                    c = (l = i) * (g = .5522848),
                    d = (u = n) * g,
                    g *= r = r,
                    t.moveTo(a - l, h),
                    t.bezierCurveTo(a - l, h - d, a - c, h - u, a, h - u),
                    t.bezierCurveTo(a + c, h - u, a + l, h - d, a + l, h),
                    t.bezierCurveTo(a + l, h + g, a + c, h + r, a, h + r),
                    t.bezierCurveTo(a - c, h + r, a - l, h + g, a - l, h),
                    t.closePath()),
                O.fillCanvas(t, s, e.x - i, e.y - n),
                O._stroke(t, o, e.x - i, e.y - n)
        },
        rectangle: function(t, e, i, n, r) {
            var o = e.x
                , e = e.y;
            t.beginPath(),
                t.rect(o, e, i.width, i.height),
                O.fillCanvas(t, r, o, e),
                O._stroke(t, n, o, e)
        },
        sector: function(t, e, i, n, s, a) {
            var h = xi
                , r = n[0]
                , n = n[1];
            function o(t, e, i, n, r, o) {
                o = h * -o,
                    r = h * -r;
                t.beginPath(),
                    t.moveTo(e, i),
                    t.arc(e, i, n, o, r),
                    t.lineTo(e, i),
                    O.fillCanvas(t, a, e - n, i - n),
                    O._stroke(t, s, e - n, i - n)
            }
            o(t, e.x, e.y, i, r, n)
        },
        _isPattern: function(t) {
            return !(b(t) || "addColorStop"in t)
        },
        drawCross: function(t, e, i, n, r) {
            t.canvas._drawn = !0,
                t.strokeStyle = r,
                t.lineWidth = n,
                t.beginPath(),
                t.moveTo(e - 5, i),
                t.lineTo(e + 5, i),
                t.moveTo(e, i - 5),
                t.lineTo(e, i + 5),
                t.stroke()
        },
        copy: function(t, e) {
            e = e || f("canvas");
            return e.width = t.width,
                e.height = t.height,
                e.getContext("2d").drawImage(t, 0, 0),
                e
        }
    };
    var wi = "data:image/";
    function Ci(t) {
        return t.substring(0, wi.length) === wi ? t : _t(t)
    }
    function Pi(t, e) {
        t.filter = e.filter,
            t.fillStyle = e.fillStyle,
            t.globalAlpha = e.globalAlpha,
            t.lineCap = e.lineCap,
            t.lineDashOffset = e.lineDashOffset,
            t.lineJoin = e.lineJoin,
            t.lineWidth = e.lineWidth,
            t.shadowBlur = e.shadowBlur,
            t.shadowColor = e.shadowColor,
            t.shadowOffsetX = e.shadowOffsetX,
            t.shadowOffsetY = e.shadowOffsetY,
            t.strokeStyle = e.strokeStyle
    }
    var bi = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    function Mi(t, e) {
        return t(e = {
            exports: {}
        }, e.exports),
            e.exports
    }
    function Si(t) {
        return s(e, i = t),
            (t = e.prototype).on = function(t, e, i) {
                if (!t)
                    return this;
                if (!b(t))
                    return this._switch("on", t, e);
                if (!e)
                    return this;
                this._eventMap || (this._eventMap = {});
                var n, r, o = t.toLowerCase().split(" ");
                i = i || this;
                for (var s = 0, a = o.length; s < a; s++) {
                    n = o[s],
                    (r = this._eventMap[n]) || (this._eventMap[n] = r = []);
                    var h = r.length;
                    if (0 < h)
                        for (var l = 0; l < h; l++)
                            if (e === r[l].handler && r[l].context === i)
                                return this;
                    r.push({
                        handler: e,
                        context: i
                    })
                }
                return this
            }
            ,
            t.addEventListener = function() {
                return this.on.apply(this, arguments)
            }
            ,
            t.once = function(t, e, i) {
                if (!b(t)) {
                    var n, r = {};
                    for (n in t)
                        t.hasOwnProperty(n) && (r[n] = this._wrapOnceHandler(n, t[n], i));
                    return this._switch("on", r)
                }
                for (var o = t.split(" "), s = 0, a = o.length; s < a; s++)
                    this.on(o[s], this._wrapOnceHandler(o[s], e, i));
                return this
            }
            ,
            t.off = function(t, e, i) {
                if (!this._eventMap || !t)
                    return this;
                if (!b(t))
                    return this._switch("off", t, e);
                if (!e)
                    return this;
                var n, r, o, s = t.split(" ");
                i = i || this;
                for (var a = 0, h = s.length; a < h; a++) {
                    if (o = "Z__" + (n = s[a].toLowerCase()),
                        !(r = this._eventMap[n]))
                        return this;
                    for (var l = r.length - 1; 0 <= l; l--) {
                        var u = r[l];
                        e !== u.handler && e !== u.handler[o] || u.context !== i || (delete u.handler[o],
                            r.splice(l, 1))
                    }
                    r.length || delete this._eventMap[n]
                }
                return this
            }
            ,
            t.removeEventListener = function() {
                return this.off.apply(this, arguments)
            }
            ,
            t.listens = function(t, e, i) {
                if (!this._eventMap || !b(t))
                    return 0;
                var n = this._eventMap[t.toLowerCase()];
                if (!n || !n.length)
                    return 0;
                if (!e)
                    return n.length;
                for (var r = 0, o = n.length; r < o; r++)
                    if (e === n[r].handler && (V(i) || n[r].context === i))
                        return 1;
                return 0
            }
            ,
            t.getListeningEvents = function() {
                return this._eventMap ? Object.keys(this._eventMap) : []
            }
            ,
            t.copyEventListeners = function(t) {
                var e, i = t._eventMap;
                if (!i)
                    return this;
                for (e in i)
                    for (var n, r = 0, o = (n = i[e]).length; r < o; r++)
                        this.on(e, n[r].handler, n[r].context);
                return this
            }
            ,
            t.fire = function() {
                return this._eventParent ? this._eventParent.fire.apply(this._eventParent, arguments) : this._fire.apply(this, arguments)
            }
            ,
            t._wrapOnceHandler = function(e, i, n) {
                var r = this
                    , o = "Z__" + e
                    , s = !1
                    , a = function t() {
                    s || (delete a[o],
                        s = !0,
                        n ? i.apply(n, arguments) : i.apply(this, arguments),
                        r.off(e, t, this))
                };
                return a[o] = i,
                    a
            }
            ,
            t._switch = function(t, e, i) {
                for (var n in e)
                    e.hasOwnProperty(n) && this[t](n, e[n], i);
                return this
            }
            ,
            t._clearListeners = function(t) {
                this._eventMap && b(t) && this._eventMap[t.toLowerCase()] && (this._eventMap[t] = null)
            }
            ,
            t._clearAllListeners = function() {
                this._eventMap = null
            }
            ,
            t._setEventParent = function(t) {
                return this._eventParent = t,
                    this
            }
            ,
            t._setEventTarget = function(t) {
                return this._eventTarget = t,
                    this
            }
            ,
            t._fire = function(t, e) {
                if (!this._eventMap)
                    return this;
                var i = this._eventMap[t.toLowerCase()];
                if (!i)
                    return this;
                (e = e || {}).type = t,
                    e.target = this._eventTarget || this;
                for (var n, r, o = i.slice(0), s = 0, a = o.length; s < a; s++)
                    o[s] && (n = o[s].context,
                        r = m({}, e),
                    !1 === (n ? o[s].handler.call(n, r) : o[s].handler(r)) && e.domEvent && ii(e.domEvent));
                return this
            }
            ,
            e;
        function e() {
            return i.apply(this, arguments) || this
        }
        var i
    }
    var ce = Mi(function(t) {
        function e() {
            for (; i.length - o; ) {
                try {
                    i[o]()
                } catch (t) {
                    r.console && r.console.error(t)
                }
                i[o++] = n,
                1024 == o && (i.splice(0, 1024),
                    o = 0)
            }
        }
        function s(t) {
            if (!(this instanceof s))
                throw new TypeError("Zousan must be created with the new keyword");
            if ("function" == typeof t) {
                var e = this;
                try {
                    t(function(t) {
                        e.resolve(t)
                    }, function(t) {
                        e.reject(t)
                    })
                } catch (t) {
                    e.reject(t)
                }
            } else if (0 < arguments.length)
                throw new TypeError("Zousan resolver " + t + " is not a function")
        }
        function a(t, e) {
            if ("function" == typeof t.y)
                try {
                    var i = t.y.call(n, e);
                    t.p.resolve(i)
                } catch (e) {
                    t.p.reject(e)
                }
            else
                t.p.resolve(e)
        }
        function h(t, e) {
            if ("function" == typeof t.n)
                try {
                    var i = t.n.call(n, e);
                    t.p.resolve(i)
                } catch (e) {
                    t.p.reject(e)
                }
            else
                t.p.reject(e)
        }
        var r, l, n, i, o, u, c, d, g;
        r = bi,
            c = "fulfilled",
            d = "undefined",
            i = [],
            o = 0,
            u = function() {
                if (typeof MutationObserver == d)
                    return typeof process != d && "function" == typeof process.nextTick ? function() {
                            process.nextTick(e)
                        }
                        : typeof setImmediate != d ? function() {
                                setImmediate(e)
                            }
                            : function() {
                                setTimeout(e, 0)
                            }
                        ;
                var t = document.createElement("div");
                return new MutationObserver(e).observe(t, {
                    attributes: !0
                }),
                    function() {
                        t.setAttribute("a", 0)
                    }
            }(),
            g = function(t) {
                i.push(t),
                i.length - o == 1 && u()
            }
            ,
            s.prototype = {
                resolve: function(i) {
                    if (this.state === l) {
                        if (i === this)
                            return this.reject(new TypeError("Attempt to resolve promise with self"));
                        var n = this;
                        if (i && ("function" == typeof i || "object" == typeof i))
                            try {
                                var e = !0
                                    , t = i.then;
                                if ("function" == typeof t)
                                    return void t.call(i, function(t) {
                                        e && (e = !1,
                                            n.resolve(t))
                                    }, function(t) {
                                        e && (e = !1,
                                            n.reject(t))
                                    })
                            } catch (t) {
                                return void (e && this.reject(t))
                            }
                        this.state = c,
                            this.v = i,
                        n.c && g(function() {
                            for (var t = 0, e = n.c.length; t < e; t++)
                                a(n.c[t], i)
                        })
                    }
                },
                reject: function(i) {
                    var t, n;
                    this.state === l && ((t = this).state = "rejected",
                        this.v = i,
                        n = this.c,
                        g(n ? function() {
                                    for (var t = 0, e = n.length; t < e; t++)
                                        h(n[t], i)
                                }
                                : function() {
                                    t.handled || !s.suppressUncaughtRejectionError && r.console && s.warn("You upset Zousan. Please catch rejections: ", i, i ? i.stack : null)
                                }
                        ))
                },
                then: function(t, e) {
                    var i, n, r = new s, o = {
                        y: t,
                        n: e,
                        p: r
                    };
                    return this.state === l ? this.c ? this.c.push(o) : this.c = [o] : (i = this.state,
                        n = this.v,
                        this.handled = !0,
                        g(function() {
                            (i === c ? a : h)(o, n)
                        })),
                        r
                },
                catch: function(t) {
                    return this.then(null, t)
                },
                finally: function(t) {
                    return this.then(t, t)
                },
                timeout: function(t, n) {
                    n = n || "Timeout";
                    var r = this;
                    return new s(function(e, i) {
                            setTimeout(function() {
                                i(Error(n))
                            }, t),
                                r.then(function(t) {
                                    e(t)
                                }, function(t) {
                                    i(t)
                                })
                        }
                    )
                }
            },
            s.resolve = function(t) {
                var e = new s;
                return e.resolve(t),
                    e
            }
            ,
            s.reject = function(t) {
                var e = new s;
                return e.c = [],
                    e.reject(t),
                    e
            }
            ,
            s.all = function(i) {
                var n = []
                    , r = 0
                    , o = new s;
                for (var t = 0; t < i.length; t++)
                    !function(t, e) {
                        (t = t && "function" == typeof t.then ? t : s.resolve(t)).then(function(t) {
                            n[e] = t,
                            ++r == i.length && o.resolve(n)
                        }, function(t) {
                            o.reject(t)
                        })
                    }(i[t], t);
                return i.length || o.resolve(n),
                    o
            }
            ,
            s.warn = console.warn,
        t.exports && (t.exports = s),
        r.define && r.define.amd && r.define([], function() {
            return s
        }),
            (r.Zousan = s).soon = g
    })
        , Ce = "undefined" != typeof Promise ? Promise : ce
        , Ti = Ce;
    function Ei(t) {
        this.target = t
    }
    (de = Ei.prototype).enable = function() {
        return this._enabled || (this._enabled = !0,
            this.addHooks()),
            this
    }
        ,
        de.disable = function() {
            return this._enabled && (this._enabled = !1,
                this.removeHooks()),
                this
        }
        ,
        de.enabled = function() {
            return !!this._enabled
        }
        ,
        de.remove = function() {
            this.disable(),
                delete this.target,
                delete this.dom
        }
    ;
    var ki = Si(Ei)
        , _e = ((xe = Ri.prototype).callInitHooks = function() {
        var t = Object.getPrototypeOf(this);
        return this._visitInitHooks(t),
            this
    }
        ,
        xe.setOptions = function(t) {
            if (this.hasOwnProperty("options") || (this.options = this.options ? Object.create(this.options) : {}),
                !t)
                return this;
            for (var e in t)
                this.options[e] = t[e];
            return this
        }
        ,
        xe.config = function(t) {
            if (!t) {
                var e, i = {};
                for (e in this.options)
                    this.options.hasOwnProperty(e) && (i[e] = this.options[e]);
                return i
            }
            var n, r;
            for (r in 2 === arguments.length && ((n = {})[t] = arguments[1],
                t = n),
                t)
                this.options[r] = t[r],
                this[r] && this[r]instanceof ki && (t[r] ? this[r].enable() : this[r].disable());
            return this.onConfig(t),
                this
        }
        ,
        xe.onConfig = function() {}
        ,
        xe._visitInitHooks = function(t) {
            if (!this._initHooksCalled) {
                var e = Object.getPrototypeOf(t)
                    , i = (e._visitInitHooks && e._visitInitHooks.call(this, e),
                    this._initHooksCalled = !0,
                    t._initHooks);
                if (i && i !== e._initHooks)
                    for (var n = 0; n < i.length; n++)
                        i[n].call(this)
            }
        }
        ,
        Ri.addInitHook = function(t) {
            for (var e = arguments.length, i = new Array(1 < e ? e - 1 : 0), n = 1; n < e; n++)
                i[n - 1] = arguments[n];
            var r = "function" == typeof t ? t : function() {
                this[t].apply(this, i)
            }
                , o = this.prototype
                , s = Object.getPrototypeOf(o);
            return o._initHooks && o._initHooks !== s._initHooks || (o._initHooks = []),
                o._initHooks.push(r),
                this
        }
        ,
        Ri.include = function() {
            for (var t = 0; t < arguments.length; t++)
                m(this.prototype, t < 0 || arguments.length <= t ? void 0 : arguments[t]);
            return this
        }
        ,
        Ri.mergeOptions = function(t) {
            var e = this.prototype
                , i = Object.getPrototypeOf(e);
            return e.options && e.options !== i.options || (e.options = e.options ? Object.create(e.options) : {}),
                m(e.options, t),
                this
        }
        ,
        Ri);
    function Ri(t) {
        if (!this || !this.setOptions)
            throw new Error('Class instance is being created without "new" operator.');
        this.setOptions(t),
            this.callInitHooks()
    }
    function Ai(t) {
        return s(e, i = t),
            e.registerJSONType = function(t) {
                return t ? Li[t] = this : this
            }
            ,
            e.getJSONClass = function(t) {
                return t ? Li[t] : null
            }
            ,
            e.prototype.getJSONType = function() {
                if (void 0 === this._jsonType) {
                    var t, e = Object.getPrototypeOf(this).constructor;
                    for (t in Li)
                        if (Li[t] === e) {
                            this._jsonType = t;
                            break
                        }
                }
                if (this._jsonType)
                    return this._jsonType;
                throw new Error("Found an unregistered geometry class!")
            }
            ,
            e;
        function e() {
            return i.apply(this, arguments) || this
        }
        var i
    }
    var Li = {};
    function Oi(t) {
        return s(e, i = t),
            (t = e.prototype).addHandler = function(t, e) {
                if (!e)
                    return this;
                if (this._handlers || (this._handlers = []),
                    this[t])
                    return this[t].enable(),
                        this;
                e = this[t] = new e(this);
                return this._handlers.push(e),
                this.options[t] && e.enable(),
                    this
            }
            ,
            t.removeHandler = function(t) {
                if (!t)
                    return this;
                var e = this[t];
                return e && (0 <= (e = this._handlers.indexOf(e)) && this._handlers.splice(e, 1),
                    this[t].remove(),
                    delete this[t]),
                    this
            }
            ,
            t._clearHandlers = function() {
                for (var t = 0, e = this._handlers.length; t < e; t++)
                    this._handlers[t].remove();
                this._handlers = []
            }
            ,
            e;
        function e() {
            return i.apply(this, arguments) || this
        }
        var i
    }
    var Di, Ii = "touchstart mousedown", ji = {
        mousedown: "mousemove",
        touchstart: "touchmove",
        pointerdown: "touchmove",
        MSPointerDown: "touchmove"
    }, zi = {
        mousedown: "mouseup",
        touchstart: "touchend",
        pointerdown: "touchend",
        MSPointerDown: "touchend"
    }, Zi = (s(Hi, Di = ki),
        (me = Hi.prototype).enable = function() {
            return this.dom && (this._onMouseDown = function(t) {
                return this.onMouseDown(t)
            }
                ,
                _(this.dom, Ii, this._onMouseDown, this)),
                this
        }
        ,
        me.disable = function() {
            return this.dom && (this._offEvents(),
                mi(this.dom, Ii, this._onMouseDown),
                delete this._onMouseDown),
                this
        }
        ,
        me.onMouseDown = function(t) {
            var e;
            !this.options.rightclick && 2 === t.button || t.touches && 1 < t.touches.length || this.options.cancelOn && !0 === this.options.cancelOn(t) || ((e = this.dom).setCapture ? e.setCapture() : window.captureEvents && window.captureEvents(window.Event.MOUSEMOVE | window.Event.MOUSEUP),
                e.ondragstart = function() {
                    return !1
                }
                ,
                delete this.moved,
                e = t.touches ? t.touches[0] : t,
                this.startPos = new R(e.clientX,e.clientY),
                _(document, ji[t.type], this.onMouseMove, this),
                _(document, zi[t.type], this.onMouseUp, this),
            this.options.ignoreMouseleave || _(this.dom, "mouseleave", this.onMouseUp, this),
                this.fire("mousedown", {
                    domEvent: t,
                    mousePos: new R(e.clientX,e.clientY)
                }))
        }
        ,
        me.onMouseMove = function(t) {
            var e, i;
            t.touches && 1 < t.touches.length ? this.moved && (this.interupted = !0,
                this.onMouseUp(t)) : (e = t.touches ? t.touches[0] : t,
            ((i = new R(e.clientX,e.clientY).sub(this.startPos)).x || i.y) && (this.moved ? this.fire("dragging", {
                domEvent: t,
                mousePos: new R(e.clientX,e.clientY)
            }) : (this.fire("dragstart", {
                domEvent: t,
                mousePos: this.startPos.copy()
            }),
                this.moved = !0)))
        }
        ,
        me.onMouseUp = function(t) {
            var e = t.changedTouches ? t.changedTouches[0] : t
                , t = (this._offEvents(),
                {
                    domEvent: t
                });
            P(e.clientX) && (t.mousePos = new R(parseInt(e.clientX, 0),parseInt(e.clientY, 0))),
            this.moved && (t.interupted = this.interupted,
                this.fire("dragend", t),
                delete this.interupted,
                delete this.moved),
                this.fire("mouseup", t)
        }
        ,
        me._offEvents = function() {
            var t = this.dom;
            if (mi(t, "mouseleave", this.onMouseUp, this),
            "undefined" != typeof document && "undefined" != typeof window) {
                for (var e in ji)
                    mi(document, ji[e], this.onMouseMove, this),
                        mi(document, zi[e], this.onMouseUp, this);
                t.releaseCapture ? t.releaseCapture() : window.captureEvents && window.captureEvents(window.Event.MOUSEMOVE | window.Event.MOUSEUP)
            }
        }
        ,
        Hi);
    function Hi(t, e) {
        var i;
        return void 0 === e && (e = {}),
            (i = Di.call(this, null) || this).dom = t,
            i.options = e,
            i
    }
    s(Fi, Gi = pe),
        Fi.toNumberArrays = function(t) {
            return Array.isArray(t) ? at(t, function(t) {
                return [t.x, t.y]
            }) : [t.x, t.y]
        }
        ,
        Fi.toCoordinates = function(t) {
            if (P(t[0]) && P(t[1]))
                return new Fi(t);
            for (var e = [], i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                !Array.isArray(r) || P(r[0]) ? e.push(new Fi(r)) : e.push(Fi.toCoordinates(r))
            }
            return e
        }
    ;
    var Gi, M = Fi;
    function Fi() {
        return Gi.apply(this, arguments) || this
    }
    Ni.createProj4 = function(t) {
        return new Ni("proj4",{
            proj: t
        })
    }
        ,
        Ni.fromProjectionCode = function(t) {
            return t && Ni[t = t.toUpperCase().replace(":", "")] || null
        }
    ;
    be = Ni;
    function Ni(t, e) {
        this.type = t,
            this.properties = e
    }
    be.WGS84 = be.createProj4("+proj=longlat +datum=WGS84 +no_defs"),
        be.EPSG4326 = be.WGS84,
        be.EPSG3857 = be.createProj4("+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"),
        be.IDENTITY = be.createProj4("+proj=identity +no_defs"),
        be.CGCS2000 = be.createProj4("+proj=longlat +datum=CGCS2000"),
        be.EPSG4490 = be.CGCS2000,
        be.BD09LL = be.createProj4("+proj=longlat +datum=BD09"),
        be.GCJ02 = be.createProj4("+proj=longlat +datum=GCJ02");
    var Wi = new R(0,0)
        , Bi = new M(0,0)
        , Vi = new M(0,0)
        , Ui = new M(0,0)
        , Ji = new M(0,0)
        , qi = new M(0,0)
        , Yi = new M(0,0)
        , Xi = new M(0,0)
        , Ki = new M(0,0)
        , Qi = []
        , $i = []
        , g = ((n = tn.prototype)._initialize = function(t, e, i, n) {
        var r;
        this.xmin = null,
            this.xmax = null,
            this.ymin = null,
            this.ymax = null,
        V(t) || (r = this.projection,
            P(t) && P(e) && P(i) && P(n) ? r ? this.set(t, e, i, n) : this.set(Math.min(t, i), Math.min(e, n), Math.max(t, i), Math.max(e, n)) : Array.isArray(t) ? r ? this.set(t[0], t[1], t[2], t[3]) : this.set(Math.min(t[0], t[2]), Math.min(t[1], t[3]), Math.max(t[0], t[2]), Math.max(t[1], t[3])) : P(t.x) && P(e.x) && P(t.y) && P(e.y) ? r ? this.set(t.x, t.y, e.x, e.y) : (t.x > e.x ? (this.xmin = e.x,
                this.xmax = t.x) : (this.xmin = t.x,
                this.xmax = e.x),
                t.y > e.y ? (this.ymin = e.y,
                    this.ymax = t.y) : (this.ymin = t.y,
                    this.ymax = e.y)) : P(t.xmin) && P(t.xmax) && P(t.ymin) && P(t.ymax) && this.set(t.xmin, t.ymin, t.xmax, t.ymax))
    }
        ,
        n._add = function(t) {
            return this._dirty = !0,
                V(t.x) ? V(t.xmin) ? V(t[0]) || (this.xmin += t[0],
                    this.ymin += t[1],
                    this.xmax += t[0],
                    this.ymax += t[1]) : (this.xmin += t.xmin,
                    this.ymin += t.ymin,
                    this.xmax += t.xmax,
                    this.ymax += t.ymax) : (this.xmin += t.x,
                    this.ymin += t.y,
                    this.xmax += t.x,
                    this.ymax += t.y),
                this
        }
        ,
        n.add = function() {
            var t = new this.constructor(this.xmin,this.ymin,this.xmax,this.ymax,this.projection);
            return t._add.apply(t, arguments)
        }
        ,
        n._scale = function(t) {
            return this._dirty = !0,
                this.xmin *= t,
                this.ymin *= t,
                this.xmax *= t,
                this.ymax *= t,
                this
        }
        ,
        n._sub = function(t) {
            return this._dirty = !0,
                V(t.x) ? V(t.xmin) ? V(t[0]) || (this.xmin -= t[0],
                    this.ymin -= t[1],
                    this.xmax -= t[0],
                    this.ymax -= t[1]) : (this.xmin -= t.xmin,
                    this.ymin -= t.ymin,
                    this.xmax -= t.xmax,
                    this.ymax -= t.ymax) : (this.xmin -= t.x,
                    this.ymin -= t.y,
                    this.xmax -= t.x,
                    this.ymax -= t.y),
                this
        }
        ,
        n._substract = function() {
            return this._sub.apply(this, arguments)
        }
        ,
        n.sub = function() {
            var t = new this.constructor(this.xmin,this.ymin,this.xmax,this.ymax,this.projection);
            return t._sub.apply(t, arguments)
        }
        ,
        n.substract = function() {
            return this.sub.apply(this, arguments)
        }
        ,
        n.round = function() {
            return new this.constructor(Math.round(this.xmin),Math.round(this.ymin),Math.round(this.xmax),Math.round(this.ymax),this.projection)
        }
        ,
        n._round = function() {
            return this._dirty = !0,
                this.xmin = Math.round(this.xmin),
                this.ymin = Math.round(this.ymin),
                this.xmax = Math.round(this.xmax),
                this.ymax = Math.round(this.ymax),
                this
        }
        ,
        n.getMin = function(t) {
            return t ? (t.set(this.xmin, this.ymin),
                t) : new this._clazz(this.xmin,this.ymin)
        }
        ,
        n.getMax = function(t) {
            return t ? (t.set(this.xmax, this.ymax),
                t) : new this._clazz(this.xmax,this.ymax)
        }
        ,
        n.getCenter = function(t) {
            var e = (this.xmin + this.xmax) / 2
                , i = (this.ymin + this.ymax) / 2;
            return t ? (t.set(e, i),
                t) : new this._clazz(e,i)
        }
        ,
        n.isValid = function() {
            return !(V(this.xmin) || V(this.ymin) || V(this.xmax) || V(this.ymax))
        }
        ,
        n.equals = function(t) {
            return this.xmin === t.xmin && this.xmax === t.xmax && this.ymin === t.ymin && this.ymax === t.ymax
        }
        ,
        n.intersects = function(t) {
            this._project(this),
                this._project(t);
            var e = Math.max(this.pxmin, t.pxmin)
                , i = Math.max(this.pymin, t.pymin)
                , n = Math.min(this.pxmax, t.pxmax)
                , t = Math.min(this.pymax, t.pymax);
            return !(n < e || t < i)
        }
        ,
        n.within = function(t) {
            return this._project(this),
                this._project(t),
            this.pxmin >= t.pxmin && this.pxmax <= t.pxmax && this.pymin >= t.pymin && this.pymax <= t.pymax
        }
        ,
        n.contains = function(t) {
            if (!t)
                return !1;
            this._project(this);
            var e, i = this.projection;
            return i && (void 0 !== t.x ? (e = Bi,
                Array.isArray(t) ? (e.x = t[0],
                    e.y = t[1]) : (e.x = t.x,
                    e.y = t.y),
                t = i.project(e, e)) : void 0 !== t.xmin && this._project(t)),
            (t.x || t.pxmin || 0) >= this.pxmin && (t.x || t.pxmax || 0) <= this.pxmax && (t.y || t.pymin || 0) >= this.pymin && (t.y || t.pymax || 0) <= this.pymax
        }
        ,
        n.getWidth = function() {
            return Math.abs(this.xmax - this.xmin)
        }
        ,
        n.getHeight = function() {
            return Math.abs(this.ymax - this.ymin)
        }
        ,
        n.getSize = function() {
            return new Le(this.getWidth(),this.getHeight())
        }
        ,
        n.set = function(t, e, i, n) {
            return this.xmin = t,
                this.ymin = e,
                this.xmax = i,
                this.ymax = n,
                this._dirty = !0,
                this
        }
        ,
        n.__combine = function(t) {
            void 0 !== t.x && (nn.xmin = nn.xmax = t.x,
                nn.ymin = nn.ymax = t.y,
                t = nn),
                this._project(t),
                this._project(this);
            t = P(this.pxmin) ? (i = Math.min(this.pxmin, t.pxmin),
                n = Math.min(this.pymin, t.pymin),
                r = Math.max(this.pxmax, t.pxmax),
                Math.max(this.pymax, t.pymax)) : (i = t.pxmin,
                n = t.pymin,
                r = t.pxmax,
                t.pymax);
            var e, i, n, r, o = this.projection;
            return o && (Vi.set(i, n),
                Ui.set(r, t),
                e = o.unproject(Vi, Vi),
                o = o.unproject(Ui, Ui),
                i = e.x,
                n = e.y,
                r = o.x,
                t = o.y),
                $i[0] = i,
                $i[1] = n,
                $i[2] = r,
                $i[3] = t,
                $i
        }
        ,
        n._combine = function(t) {
            if (!t || t.isValid && !t.isValid())
                return this;
            t = this.__combine(t);
            return this.set(t[0], t[1], t[2], t[3]),
                this._dirty = !0,
                this
        }
        ,
        n.combine = function(t) {
            if (!t || t.isValid && !t.isValid())
                return this;
            t = this.__combine(t);
            return new this.constructor(t[0],t[1],t[2],t[3],this.projection)
        }
        ,
        n.intersection = function(t) {
            if (!this.intersects(t))
                return null;
            Ji.x = Math.max(this.pxmin, t.pxmin),
                Ji.y = Math.max(this.pymin, t.pymin),
                qi.x = Math.min(this.pxmax, t.pxmax),
                qi.y = Math.min(this.pymax, t.pymax);
            var t = Ji
                , e = qi
                , i = this.projection;
            return i && (t = i.unproject(t, t),
                e = i.unproject(e, e)),
                new this.constructor(t,e,i)
        }
        ,
        n.expand = function(t) {
            var e, i;
            return P(t) ? e = i = t : (e = t.width || t.x || t[0] || 0,
                i = t.height || t.y || t[1] || 0),
                new this.constructor(this.xmin - e,this.ymin - i,this.xmax + e,this.ymax + i,this.projection)
        }
        ,
        n._expand = function(t) {
            var e, i;
            return P(t) ? e = i = t : (e = t.width || t.x || t[0] || 0,
                i = t.height || t.y || t[1] || 0),
                this.xmin -= e,
                this.ymin -= i,
                this.xmax += e,
                this.ymax += i,
                this._dirty = !0,
                this
        }
        ,
        n.toJSON = function() {
            return {
                xmin: this.xmin,
                ymin: this.ymin,
                xmax: this.xmax,
                ymax: this.ymax
            }
        }
        ,
        n.toArray = function() {
            var t = this.xmin
                , e = this.ymin
                , i = this.xmax
                , n = this.ymax;
            return [new this._clazz([t, n]), new this._clazz([i, n]), new this._clazz([i, e]), new this._clazz([t, e]), new this._clazz([t, n])]
        }
        ,
        n.toString = function() {
            return this.xmin + "," + this.ymin + "," + this.xmax + "," + this.ymax
        }
        ,
        n.copy = function() {
            return new this.constructor(this.xmin,this.ymin,this.xmax,this.ymax,this.projection)
        }
        ,
        n.convertTo = function(t, e) {
            if (!this.isValid())
                return null;
            var i, n = e || new this.constructor;
            return e && n.set(null, null, null, null),
                this._clazz === M ? i = Yi : this._clazz === R && (i = Wi),
                i.x = this.xmin,
                i.y = this.ymax,
                n._combine(t(i)),
                i.x = this.xmax,
                n._combine(t(i)),
                i.y = this.ymin,
                n._combine(t(i)),
                i.x = this.xmin,
                n._combine(t(i)),
                n
        }
        ,
        n._project = function(t) {
            var e, i;
            t && t.isValid() ? (i = this.projection) ? (t._dirty && (Xi.set(t.xmax, t.ymin),
                Ki.set(t.xmin, t.ymax),
                Qi[0] = Xi,
                Qi[1] = Ki,
                e = (i = i.projectCoords(Qi))[0],
                i = i[1],
                t.pxmin = Math.min(e.x, i.x),
                t.pymin = Math.min(e.y, i.y),
                t.pxmax = Math.max(e.x, i.x),
                t.pymax = Math.max(e.y, i.y)),
                delete t._dirty) : (t.pxmin = t.xmin,
                t.pxmax = t.xmax,
                t.pymin = t.ymin,
                t.pymax = t.ymax) : t && (t.pxmin = t.pxmax = t.pymin = t.pymax = null)
        }
        ,
        tn);
    function tn(t, e, i, n) {
        this._clazz = M;
        var r = arguments.length
            , o = 0 < r ? arguments[r - 1] : null;
        o && o.unproject && (this.projection = arguments[r - 1]),
            this._dirty = !0,
            this._initialize(t, e, i, n)
    }
    var en, nn = new g(0,0,0,0), U = (s(rn, en = g),
        rn);
    function rn(t, e, i, n) {
        t = en.call(this, t, e, i, n) || this;
        return t._clazz = R,
            t
    }
    (ye = sn.prototype).transform = function(t, e, i) {
        var n = this.matrix[0] * (t.x - this.matrix[2]) / e
            , t = -this.matrix[1] * (t.y - this.matrix[3]) / e;
        return i ? (i.x = n,
            i.y = t,
            i) : new R(n,t)
    }
        ,
        ye.untransform = function(t, e, i) {
            var n = t.x * e / this.matrix[0] + this.matrix[2]
                , t = t.y * e / -this.matrix[1] + this.matrix[3];
            return i ? (i.x = n,
                i.y = t,
                i) : new M(n,t)
        }
    ;
    var on = sn;
    function sn(t) {
        this.matrix = t
    }
    var an, hn = {
        project: function() {},
        unproject: function() {},
        projectCoords: function(t) {
            var e = this;
            if (!t)
                return [];
            if (!Array.isArray(t))
                return this.project(t);
            if (0 === t.length)
                return [];
            if (!this.isSphere())
                return at(t, this.project, this);
            if (Array.isArray(t[0]))
                return t.map(function(t) {
                    return e.projectCoords(t)
                });
            for (var i, n, r, o, s, a, h = this.getCircum(), l = this.getSphereExtent(), u = l.sx, c = l.sy, d = t[0], g = [this.project(d)], p = 1, f = t.length; p < f; p++)
                o = (r = t[p]).x - d.x,
                    s = r.y - d.y,
                    a = this.project(r),
                180 < Math.abs(o) && (i = void 0 === i ? r.x > d.x : i) && (a._add(-h.x * ht(o) * u, 0),
                    r._add(-360 * ht(o), 0)),
                90 < Math.abs(s) && (n = void 0 === n ? r.y < d.y : n) && (a._add(0, -h.y * ht(s) * c),
                    r._add(0, -180 * ht(s))),
                    d = r,
                    g.push(a);
            return g
        },
        unprojectCoords: function(t) {
            return t ? Array.isArray(t) ? at(t, this.unproject, this) : this.unproject(t) : []
        },
        isSphere: function() {
            return !!this.sphere
        },
        isOutSphere: function(t) {
            return !!this.isSphere() && !this.getSphereExtent().contains(t)
        },
        wrapCoord: function(t) {
            if (!this.isSphere())
                return t;
            var e = this.getSphereExtent()
                , i = new M(t);
            return e.contains(i) || (i.x = ct(t.x, e.xmin, e.xmax),
                i.y = ct(t.y, e.ymin, e.ymax)),
                i
        },
        getCircum: function() {
            var t;
            return !this.circum && this.isSphere() && (t = this.getSphereExtent(),
                this.circum = {
                    x: t.getWidth(),
                    y: t.getHeight()
                }),
                this.circum
        },
        getSphereExtent: function() {
            var t, e;
            return !this.extent && this.isSphere() && (t = this.project(new M(180,90)),
                e = this.project(new M(-180,-90)),
                this.extent = new g(e,t,this),
                this.extent.sx = t.x > e.x ? 1 : -1,
                this.extent.sy = t.y > e.y ? 1 : -1),
                this.extent
        }
    }, Me = {
        measureLength: function(t, e) {
            if (!Array.isArray(t))
                return this.measureLenBetween(t, e);
            for (var i = 0, n = 0, r = t.length; n < r - 1; n++)
                i += this.measureLenBetween(t[n], t[n + 1]);
            return i
        }
    }, i = m({
        measure: "IDENTITY",
        measureLenBetween: function(t, e) {
            if (!t || !e)
                return 0;
            try {
                return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
            } catch (t) {
                return 0
            }
        },
        measureArea: function(t) {
            if (!Array.isArray(t))
                return 0;
            for (var e = 0, i = 0, n = t.length; i < n; i++) {
                var r = t[i]
                    , o = null
                    , o = i === n - 1 ? t[0] : t[i + 1];
                e += r.x * o.y - r.y * o.x
            }
            return Math.abs(e / 2)
        },
        locate: function(t, e, i) {
            return t = new M(t.x,t.y),
                this._locate(t, e, i)
        },
        _locate: function(t, e, i) {
            return t ? (i = i || 0,
            ((e = e || 0) || i) && (t.x = t.x + e,
                t.y = t.y + i),
                t) : null
        },
        rotate: function(t, e, i) {
            return t = new M(t.x,t.y),
                this._rotate(t, e, i)
        },
        _rotate: (an = new R(0,0),
                function(t, e, i) {
                    return an.x = t.x - e.x,
                        an.y = t.y - e.y,
                        an._rotate(i * Math.PI / 180),
                        t.x = e.x + an.x,
                        t.y = e.y + an.y,
                        t
                }
        )
    }, Me), e = ((Se = ln.prototype).measureLenBetween = function(t, e) {
        if (!t || !e)
            return 0;
        var i = Y(t.y)
            , n = Y(e.y)
            , t = Y(t.x) - Y(e.x)
            , i = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((i - n) / 2), 2) + Math.cos(i) * Math.cos(n) * Math.pow(Math.sin(t / 2), 2)));
        return i *= this.radius,
        Math.round(1e5 * i) / 1e5
    }
        ,
        Se.measureArea = function(t) {
            var e, i = Y(this.radius), n = 0, r = t, o = r.length;
            if (o < 3)
                return 0;
            for (e = 0; e < o - 1; e++) {
                var s = r[e]
                    , a = r[e + 1];
                n += s.x * i * Math.cos(Y(s.y)) * a.y * i - a.x * i * Math.cos(Y(a.y)) * s.y * i
            }
            return o = r[e],
                r = r[0],
                n += o.x * i * Math.cos(Y(o.y)) * r.y * i - r.x * i * Math.cos(Y(r.y)) * o.y * i,
            .5 * Math.abs(n)
        }
        ,
        Se.locate = function(t, e, i) {
            return t = new M(t.x,t.y),
                this._locate(t, e, i)
        }
        ,
        Se._locate = function(t, e, i) {
            if (!t)
                return null;
            if (i = i || 0,
            !(e = e || 0) && !i)
                return t;
            var n, r, o = Y(t.y);
            return n = 0 !== i ? (n = Math.abs(i),
                ct(180 * (o += 2 * Math.sin(n / (2 * this.radius)) * (0 < i ? 1 : -1)) / Math.PI, -90, 90)) : t.y,
                i = 0 !== e ? (i = Math.abs(e),
                    r = Y(t.x),
                    ct(180 * (r += 2 * Math.sqrt(Math.pow(Math.sin(i / (2 * this.radius)), 2) / Math.pow(Math.cos(o), 2)) * (0 < e ? 1 : -1)) / Math.PI, -180, 180)) : t.x,
                t.x = i,
                t.y = n,
                t
        }
        ,
        Se.rotate = function(t, e, i) {
            return t = new M(t),
                this._rotate(t, e, i)
        }
        ,
        Se._rotate = function(t, e, i) {
            var n, r, o, s, i = function(t, e, i) {
                void 0 === i && (i = {});
                i = i.final ? un(e, t) : un(t, e);
                return 180 < i ? -(360 - i) : i
            }(e, t) - i, a = this.measureLenBetween(e, t);
            return t.x = e.x,
                t.y = e.y,
                e = t,
                t = a,
                a = i,
                i = this.radius,
                t /= i,
                i = e.x * Math.PI / 180,
                n = Y(e.y),
                a *= q,
                r = t * Math.cos(a),
                o = n + r,
            Math.abs(o) > Math.PI / 2 && (o = 0 < o ? Math.PI - o : -Math.PI - o),
                s = Math.log(Math.tan(o / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4)),
                r = 1e-11 < Math.abs(s) ? r / s : Math.cos(n),
                s = t * Math.sin(a) / r,
                n = i + s,
                e.x = (180 * n / Math.PI + 540) % 360 - 180,
                e.y = 180 * o / Math.PI,
                e
        }
        ,
        ln);
    function ln(t) {
        this.radius = t
    }
    function un(t, e) {
        var i = Y(t.y)
            , n = Y(e.y)
            , e = Y(e.x - t.x)
            , t = (e > Math.PI && (e -= 2 * Math.PI),
        e < -Math.PI && (e += 2 * Math.PI),
            Math.log(Math.tan(n / 2 + Math.PI / 4) / Math.tan(i / 2 + Math.PI / 4)));
        return (Math.atan2(e, t) / q + 360) % 360
    }
    var ge = m({
        measure: "EPSG:4326",
        sphere: new e(6378137),
        measureLenBetween: function() {
            return this.sphere.measureLenBetween.apply(this.sphere, arguments)
        },
        measureArea: function() {
            return this.sphere.measureArea.apply(this.sphere, arguments)
        },
        _locate: function() {
            return this.sphere._locate.apply(this.sphere, arguments)
        },
        locate: function() {
            return this.sphere.locate.apply(this.sphere, arguments)
        },
        _rotate: function() {
            return this.sphere._rotate.apply(this.sphere, arguments)
        },
        rotate: function() {
            return this.sphere.rotate.apply(this.sphere, arguments)
        }
    }, Me)
        , ve = m({
        measure: "BAIDU",
        sphere: new e(6370996.81),
        measureLenBetween: function() {
            return this.sphere.measureLenBetween.apply(this.sphere, arguments)
        },
        measureArea: function() {
            return this.sphere.measureArea.apply(this.sphere, arguments)
        },
        _locate: function() {
            return this.sphere._locate.apply(this.sphere, arguments)
        },
        locate: function() {
            return this.sphere.locate.apply(this.sphere, arguments)
        },
        _rotate: function() {
            return this.sphere._rotate.apply(this.sphere, arguments)
        },
        rotate: function() {
            return this.sphere.rotate.apply(this.sphere, arguments)
        }
    }, Me)
        , cn = ge
        , dn = {};
    function gn(t) {
        dn[t.measure] = t
    }
    gn(i),
        gn(ge),
        gn(ve);
    function pn(t) {
        return s(e, i = t),
            e.registerRenderer = function(t, e) {
                var i = this.prototype
                    , n = Object.getPrototypeOf(i);
                return i._rendererClasses && i._rendererClasses !== n._rendererClasses || (i._rendererClasses = i._rendererClasses ? Object.create(i._rendererClasses) : {}),
                    i._rendererClasses[t.toLowerCase()] = e,
                    this
            }
            ,
            e.getRendererClass = function(t) {
                var e = this.prototype;
                return e._rendererClasses ? e._rendererClasses[t.toLowerCase()] : null
            }
            ,
            e;
        function e() {
            return i.apply(this, arguments) || this
        }
        var i
    }
    var fn, mn = {
        getInstance: function(t) {
            if (!t)
                return cn;
            for (var e in dn)
                if (J(dn, e)) {
                    var i = dn[e].measure;
                    if (i && t.toLowerCase() === i.toLowerCase())
                        return dn[e]
                }
            return null
        }
    }, ce = Object.freeze({
        Identity: i,
        DEFAULT: cn,
        Measurer: mn,
        WGS84Sphere: ge,
        BaiduSphere: ve
    }), Ce = m({}, hn, {
        code: "EPSG:3857",
        rad: Math.PI / 180,
        metersPerDegree: 6378137 * Math.PI / 180,
        maxLatitude: 85.0511287798,
        project: function(t, e) {
            var i = this.rad
                , n = this.metersPerDegree
                , r = this.maxLatitude
                , o = t.x
                , t = Math.max(Math.min(r, t.y), -r)
                , r = 0 === t ? 0 : Math.log(Math.tan((90 + t) * i / 2)) / i
                , t = o * n
                , i = r * n;
            return e ? (e.x = t,
                e.y = i,
                e) : new M(t,i)
        },
        unproject: function(t, e) {
            var i = this.rad
                , n = this.metersPerDegree
                , r = t.x / n
                , t = t.y
                , o = 0 === t ? 0 : (o = t / n,
            (2 * Math.atan(Math.exp(o * i)) - Math.PI / 2) / i)
                , t = (Math.abs(Math.abs(r) - 180) < 1e-7 && (r = 180 * ht(r)),
            Math.abs(Math.abs(o) - this.maxLatitude) < 1e-7 && (o = ht(o) * this.maxLatitude),
                ct(r, -180, 180))
                , n = ct(o, -this.maxLatitude, this.maxLatitude);
            return e ? (e.x = t,
                e.y = n,
                e) : new M(t,n)
        }
    }, ge), e = m({}, hn, {
        code: "EPSG:4326",
        project: function(t, e) {
            return e ? (e.x = t.x,
                e.y = t.y,
                e) : new M(t)
        },
        unproject: function(t, e) {
            return e ? (e.x = t.x,
                e.y = t.y,
                e) : new M(t)
        }
    }, ge), Me = m({}, e, {
        code: "EPSG:4490"
    }), ge = m({}, hn, {
        code: "BAIDU",
        project: function(t, e) {
            return this.convertLL2MC(t, e)
        },
        unproject: function(t, e) {
            return this.convertMC2LL(t, e)
        }
    }, ve, {
        EARTHRADIUS: 6370996.81,
        MCBAND: [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0],
        LLBAND: [75, 60, 45, 30, 15, 0],
        MC2LL: [[1.410526172116255e-8, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -.03801003308653, 17337981.2], [-7.435856389565537e-9, 8983055097726239e-21, -.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 898305509983578e-20, .30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, .32710905363475, 6856817.37], [-1.981981304930552e-8, 8983055099779535e-21, .03278182852591, 40.31678527705744, .65659298677277, -4.44255534477492, .85341911805263, .12923347998204, -.04625736007561, 4482777.06], [3.09191371068437e-9, 8983055096812155e-21, 6995724062e-14, 23.10934304144901, -.00023663490511, -.6321817810242, -.00663494467273, .03430082397953, -.00466043876332, 2555164.4], [2.890871144776878e-9, 8983055095805407e-21, -3.068298e-8, 7.47137025468032, -353937994e-14, -.02145144861037, -1234426596e-14, .00010322952773, -323890364e-14, 826088.5]],
        LL2MC: [[-.0015702102444, 111320.7020616939, 0x60e374c3105a3, -0x24bb4115e2e164, 0x5cc55543bb0ae8, -0x7ce070193f3784, 0x5e7ca61ddf8150, -0x261a578d8b24d0, 0x665d60f3742ca, 82.5], [.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5], [.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-.0003218135878613132, 111320.7020701615, .00369383431289, 823725.6402795718, .46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, .37238884252424, 7.45]],
        convertMC2LL: function(t, e) {
            for (var i, n = 0, r = this.MCBAND.length; n < r; n++)
                if (Math.abs(t.y) >= this.MCBAND[n]) {
                    i = this.MC2LL[n];
                    break
                }
            return this.convertor(t, i, e)
        },
        convertLL2MC: function(t, e) {
            t.x = this.getLoop(t.x, -180, 180),
                t.y = this.getRange(t.y, -74, 74);
            for (var i, n = new M(t.x,t.y), r = 0, o = this.LLBAND.length; r < o; r++)
                if (n.y >= this.LLBAND[r]) {
                    i = this.LL2MC[r];
                    break
                }
            if (!i)
                for (r = this.LLBAND.length - 1; 0 <= r; r--)
                    if (n.y <= -this.LLBAND[r]) {
                        i = this.LL2MC[r];
                        break
                    }
            return this.convertor(t, i, e)
        },
        convertor: function(t, e, i) {
            if (!t || !e)
                return null;
            var n = e[0] + e[1] * Math.abs(t.x)
                , r = Math.abs(t.y) / e[9]
                , e = e[2] + e[3] * r + e[4] * r * r + e[5] * r * r * r + e[6] * r * r * r * r + e[7] * r * r * r * r * r + e[8] * r * r * r * r * r * r;
            return n *= t.x < 0 ? -1 : 1,
                e *= t.y < 0 ? -1 : 1,
                i ? (i.x = n,
                    i.y = e,
                    i) : new M(n,e)
        },
        toRadians: function(t) {
            return Math.PI * t / 180
        },
        toDegrees: function(t) {
            return 180 * t / Math.PI
        },
        getRange: function(t, e, i) {
            return null != e && (t = Math.max(t, e)),
                t = null != i ? Math.min(t, i) : t
        },
        getLoop: function(t, e, i) {
            if (t === 1 / 0)
                return i;
            if (t === -1 / 0)
                return e;
            for (; i < t; )
                t -= i - e;
            for (; t < e; )
                t += i - e;
            return t
        }
    }), ve = m({}, hn, {
        code: "IDENTITY",
        project: function(t, e) {
            return e ? (e.x = t.x,
                e.y = t.y,
                e) : t.copy()
        },
        unproject: function(t, e) {
            return e ? (e.x = t.x,
                e.y = t.y,
                e) : t.copy()
        }
    }, i), _n = Ce, yn = Object.freeze({
        EPSG3857: Ce,
        DEFAULT: _n,
        EPSG4326: e,
        EPSG4490: Me,
        BAIDU: ge,
        IDENTITY: ve,
        Common: hn
    }), vn = (s(xn, fn = _e),
        (i = xn.prototype).render = function(t) {
            this.prepareRender(),
            this.getMap() && this.layer.isVisible() && (this.resources || (this.resources = new Cn),
                this.checkAndDraw(this._tryToDraw, t))
        }
        ,
        i.checkAndDraw = function(t) {
            for (var e, i = this, n = arguments.length, r = new Array(1 < n ? n - 1 : 0), o = 1; o < n; o++)
                r[o - 1] = arguments[o];
            this.checkResources && 0 < (e = this.checkResources()).length ? (this._loadingResource = !0,
                this.loadResources(e).then(function() {
                    i._loadingResource = !1,
                    i.layer && (i.layer.fire("resourceload"),
                        i.setToRedraw())
                })) : t.call.apply(t, [this].concat(r))
        }
        ,
        i.testIfNeedRedraw = function() {
            var t = this.getMap();
            return !this._loadingResource && (!!this._toRedraw || !(t.isInteracting() && !this.drawOnInteracting) && !!this.needToRedraw())
        }
        ,
        i.needToRedraw = function() {
            var t = this.getMap();
            return !(!t.isInteracting() && !t.getRenderer().isViewChanged()) && !(!t.getPitch() && t.isMoving() && !t.isZooming() && !t.isRotating() && !this.layer.options.forceRenderOnMoving)
        }
        ,
        i.onSkipDrawOnInteracting = function() {}
        ,
        i.isLoadingResource = function() {
            return this._loadingResource
        }
        ,
        i.isRenderComplete = function() {
            return !!this._renderComplete
        }
        ,
        i.mustRenderOnInteracting = function() {
            return !this._painted
        }
        ,
        i.setToRedraw = function() {
            return this._toRedraw = !0,
                this
        }
        ,
        i.setCanvasUpdated = function() {
            return this._canvasUpdated = !0,
                this
        }
        ,
        i.isCanvasUpdated = function() {
            return !!this._canvasUpdated
        }
        ,
        i.remove = function() {
            this.onRemove(),
                delete this._loadingResource,
                delete this.southWest,
                delete this.canvas,
                delete this.context,
                delete this.canvasExtent2D,
                delete this._extent2D,
                delete this.resources,
                delete this.layer
        }
        ,
        i.onRemove = function() {}
        ,
        i.onAdd = function() {}
        ,
        i.getMap = function() {
            return this.layer ? this.layer.getMap() : null
        }
        ,
        i.getCanvasImage = function() {
            var t = this.getMap();
            if (this._canvasUpdated = !1,
            this._renderZoom !== t.getZoom() || !this.canvas || !this._extent2D)
                return null;
            if (this.isBlank())
                return null;
            if (this.layer.isEmpty && this.layer.isEmpty())
                return null;
            t = t._pointToContainerPoint(this.southWest)._add(0, -t.height);
            return {
                image: this.canvas,
                layer: this.layer,
                point: t
            }
        }
        ,
        i.clear = function() {
            this.clearCanvas()
        }
        ,
        i.isBlank = function() {
            return !this._painted
        }
        ,
        i.show = function() {
            this.setToRedraw()
        }
        ,
        i.hide = function() {
            this.clear(),
                this.setToRedraw()
        }
        ,
        i.setZIndex = function() {
            this.setToRedraw()
        }
        ,
        i.hitDetect = function(t) {
            if (!this.context || this.layer.isEmpty && this.layer.isEmpty() || this.isBlank() || this._errorThrown)
                return !1;
            var e = this.getMap()
                , i = e.getDevicePixelRatio()
                , e = e.getSize();
            if (t.x < 0 || t.x > e.width * i || t.y < 0 || t.y > e.height * i)
                return !1;
            try {
                if (0 < this.context.getImageData(i * t.x, i * t.y, 1, 1).data[3])
                    return !0
            } catch (t) {
                return this._errorThrown || (console && console.warn("hit detect failed with tainted canvas, some geometries have external resources in another domain:\n", t),
                    this._errorThrown = !0),
                    !1
            }
            return !1
        }
        ,
        i.loadResources = function(t) {
            this.resources || (this.resources = new Cn);
            var e = this.resources
                , i = [];
            if (L(t))
                for (var n = {}, r = t.length - 1; 0 <= r; r--) {
                    var o = t[r];
                    o && o.length && !n[o.join("-")] && (n[o.join("-")] = 1,
                    e.isResourceLoaded(o, !0) || i.push(new Ti(this._promiseResource(o))))
                }
            return Ti.all(i)
        }
        ,
        i.prepareRender = function() {
            delete this._renderComplete;
            var t = this.getMap();
            this._renderZoom = t.getZoom(),
                this.canvasExtent2D = this._extent2D = t._get2DExtent(),
                this.southWest = t._containerPointToPoint(new R(0,t.height))
        }
        ,
        i.createCanvas = function() {
            var t, e, i, n, r;
            this.canvas || (e = (t = this.getMap()).getSize(),
                i = (n = t.getDevicePixelRatio()) * e.width,
                n = n * e.height,
                this.layer._canvas ? ((r = this.layer._canvas).width = i,
                    r.height = n,
                r.style && (r.style.width = e.width + "px",
                    r.style.height = e.height + "px"),
                    this.canvas = this.layer._canvas) : this.canvas = O.createCanvas(i, n, t.CanvasClass),
                this.onCanvasCreate())
        }
        ,
        i.onCanvasCreate = function() {}
        ,
        i.createContext = function() {
            var t;
            this.gl && this.gl.canvas === this.canvas || this.context || (this.context = this.canvas.getContext("2d"),
            this.context && (this.layer.options.globalCompositeOperation && (this.context.globalCompositeOperation = this.layer.options.globalCompositeOperation),
            1 !== (t = this.getMap().getDevicePixelRatio()) && this.context.scale(t, t)))
        }
        ,
        i.resetCanvasTransform = function() {
            var t;
            this.context && (t = this.getMap().getDevicePixelRatio(),
                this.context.setTransform(t, 0, 0, t, 0, 0))
        }
        ,
        i.resizeCanvas = function(t) {
            var e, i = this.canvas;
            i && (t = t || this.getMap().getSize(),
                e = this.getMap().getDevicePixelRatio(),
            i.width === e * t.width && i.height === e * t.height || (i.height = e * t.height,
                i.width = e * t.width,
            1 !== e && this.context && this.context.scale(e, e),
            this.layer._canvas && i.style && (i.style.width = t.width + "px",
                i.style.height = t.height + "px")))
        }
        ,
        i.clearCanvas = function() {
            this.context && O.clearRect(this.context, 0, 0, this.canvas.width, this.canvas.height)
        }
        ,
        i.prepareCanvas = function() {
            this.canvas ? (this.resetCanvasTransform(),
                this.clearCanvas(),
                this.resizeCanvas()) : (this.createCanvas(),
                this.createContext(),
                this.layer.onCanvasCreate(),
                this.layer.fire("canvascreate", {
                    context: this.context,
                    gl: this.gl
                })),
                delete this._maskExtent;
            var t = this.layer.getMask();
            if (!t)
                return this.layer.fire("renderstart", {
                    context: this.context,
                    gl: this.gl
                }),
                    null;
            t = this._maskExtent = t._getMaskPainter().get2DExtent();
            return t.intersects(this._extent2D),
                this.layer.fire("renderstart", {
                    context: this.context,
                    gl: this.gl
                }),
                t
        }
        ,
        i.clipCanvas = function(e) {
            var t = this.layer.getMask();
            if (!t)
                return !1;
            var i, n = this.southWest, r = this.getMap(), r = (this.southWest = r._containerPointToPoint(new R(0,r.height)),
                e.save(),
                r.getDevicePixelRatio());
            return 1 !== r && (e.save(),
                e.scale(r, r)),
                t.getGeometries ? (e.isMultiClip = !0,
                    i = t.getGeometries() || [],
                    e.beginPath(),
                    i.forEach(function(t) {
                        t._getMaskPainter().paint(null, e)
                    }),
                    e.stroke(),
                    delete e.isMultiClip) : t._getMaskPainter().paint(null, e),
            1 !== r && e.restore(),
                e.clip(),
                this.southWest = n,
                !0
        }
        ,
        i.getViewExtent = function() {
            return {
                extent: this._extent2D,
                maskExtent: this._maskExtent,
                zoom: this._renderZoom,
                southWest: this.southWest
            }
        }
        ,
        i.completeRender = function() {
            this.getMap() && (this._renderComplete = !0,
                this.layer.fire("renderend", {
                    context: this.context,
                    gl: this.gl
                }),
                this.setCanvasUpdated())
        }
        ,
        i.getEvents = function() {
            return {
                _zoomstart: this.onZoomStart,
                _zooming: this.onZooming,
                _zoomend: this.onZoomEnd,
                _resize: this.onResize,
                _movestart: this.onMoveStart,
                _moving: this.onMoving,
                _moveend: this.onMoveEnd,
                _dragrotatestart: this.onDragRotateStart,
                _dragrotating: this.onDragRotating,
                _dragrotateend: this.onDragRotateEnd,
                _spatialreferencechange: this.onSpatialReferenceChange
            }
        }
        ,
        i.onZoomStart = function() {}
        ,
        i.onZoomEnd = function() {
            this.setToRedraw()
        }
        ,
        i.onZooming = function() {}
        ,
        i.onMoveStart = function() {}
        ,
        i.onMoving = function() {}
        ,
        i.onMoveEnd = function() {
            this.setToRedraw()
        }
        ,
        i.onResize = function() {
            delete this._extent2D,
                this.resizeCanvas(),
                this.setToRedraw()
        }
        ,
        i.onDragRotateStart = function() {}
        ,
        i.onDragRotating = function() {}
        ,
        i.onDragRotateEnd = function() {
            this.setToRedraw()
        }
        ,
        i.onSpatialReferenceChange = function() {}
        ,
        i.getDrawTime = function() {
            return this._drawTime
        }
        ,
        i._tryToDraw = function(t) {
            this._toRedraw = !1,
                !this.canvas && this.layer.isEmpty && this.layer.isEmpty() ? this._renderComplete = !0 : this._drawAndRecord(t)
        }
        ,
        i._drawAndRecord = function(t) {
            var e, i;
            this.getMap() && (e = this._painted,
                this._painted = !0,
                i = F(),
                this.draw(t),
                i = F() - i,
                this._drawTime = e ? i : i / 2,
            e && this.layer && this.layer.options.logDrawTime && console.log(this.layer.getId(), "frameTimeStamp:", t, "drawTime:", this._drawTime))
        }
        ,
        i._promiseResource = function(i) {
            var n = this
                , r = this.resources
                , o = this.layer.options.crossOrigin;
            return function(e) {
                var t;
                r.isResourceLoaded(i, !0) ? e(i) : (t = new Image,
                V(o) || (t.crossOrigin = o),
                tt(i[0]) && !$ && (i[1] && (i[1] *= 2),
                i[2] && (i[2] *= 2)),
                    t.onload = function() {
                        n._cacheResource(i, t),
                            e(i)
                    }
                    ,
                    t.onabort = function(t) {
                        console && console.warn("image loading aborted: " + i[0]),
                        t && console && console.warn(t),
                            e(i)
                    }
                    ,
                    t.onerror = function(t) {
                        t && "undefined" != typeof console && console.warn(t),
                            r.markErrorResource(i),
                            e(i)
                    }
                    ,
                    et(t, i))
            }
        }
        ,
        i._cacheResource = function(t, e) {
            var i, n, r;
            this.layer && this.resources && (i = t[1],
                n = t[2],
            this.layer.options.cacheSvgOnCanvas && 1 === tt(t[0]) && (c.edge || c.ie) && (V(i) && (i = e.width || this.layer.options.defaultIconSize[0]),
            V(n) && (n = e.height || this.layer.options.defaultIconSize[1]),
                r = O.createCanvas(i, n),
                O.image(r.getContext("2d"), e, 0, 0, i, n),
                e = r),
                this.resources.addResource(t, e))
        }
        ,
        xn);
    function xn(t) {
        var e = fn.call(this) || this;
        return e.layer = t,
            e._painted = !1,
            e._drawTime = 0,
            e.setToRedraw(),
            e
    }
    (Ce = Pn.prototype).addResource = function(t, e) {
        this.resources[t[0]] = {
            image: e,
            width: +t[1],
            height: +t[2]
        }
    }
        ,
        Ce.isResourceLoaded = function(t, e) {
            if (!t)
                return !1;
            var i = this._getImgUrl(t);
            if (this._errors[i])
                return !0;
            i = this.resources[i];
            return !!i && !(e && tt(t[0]) && (+t[1] > i.width || +t[2] > i.height))
        }
        ,
        Ce.getImage = function(t) {
            var e = this._getImgUrl(t);
            return !this.isResourceLoaded(t) || this._errors[e] ? null : this.resources[e].image
        }
        ,
        Ce.markErrorResource = function(t) {
            this._errors[this._getImgUrl(t)] = 1
        }
        ,
        Ce.merge = function(t) {
            if (!t)
                return this;
            for (var e in t.resources) {
                var i = t.resources[e];
                this.addResource([e, i.width, i.height], i.image)
            }
            return this
        }
        ,
        Ce.forEach = function(t) {
            if (!this.resources)
                return this;
            for (var e in this.resources)
                J(this.resources, e) && t(e, this.resources[e]);
            return this
        }
        ,
        Ce._getImgUrl = function(t) {
            return Array.isArray(t) ? t[0] : t
        }
    ;
    var wn, Cn = Pn;
    function Pn() {
        this.resources = {},
            this._errors = {}
    }
    function bn(t, e, i, n) {
        for (var r, o = [], s = 0, a = 0, h = t.length; a < h - 1; a++)
            (r = function(t, e, i, n, r, o) {
                var s, a, h, l = n ? wn : Tn(t, i), u = Tn(e, i);
                wn = u;
                for (; ; ) {
                    if (!(l | u))
                        return [t, e];
                    if (l & u)
                        return !1;
                    if (o)
                        return [t, e];
                    a = Sn(t, e, s = l || u, i, r),
                        h = Tn(a, i),
                        s === l ? (t = a,
                            l = h) : (e = a,
                            u = h)
                }
            }(t[a], t[a + 1], e, a, i, n)) && (o[s] = o[s] || [],
                o[s].push({
                    point: r[0],
                    index: a
                }),
            r[1] === t[a + 1] && a !== h - 2 || (o[s].push({
                point: r[1],
                index: a + 1
            }),
                s++));
        return o
    }
    function Mn(t, e, i) {
        for (var n, r, o, s, a, h, l, u = [1, 4, 2, 8], c = 0, d = t.length; c < d; c++)
            t[c]._code = Tn(t[c], e);
        for (o = 0; o < 4; o++) {
            for (h = u[o],
                     n = [],
                     c = 0,
                     r = (d = t.length) - 1; c < d; r = c++)
                s = t[c],
                    a = t[r],
                    s._code & h ? a._code & h || ((l = Sn(a, s, h, e, i))._code = Tn(l, e),
                        n.push(l)) : (a._code & h && ((l = Sn(a, s, h, e, i))._code = Tn(l, e),
                        n.push(l)),
                        n.push(s));
            t = n
        }
        return t
    }
    function Sn(t, e, i, n, r) {
        var o, s, a = e.x - t.x, e = e.y - t.y, h = n.getMin(), n = n.getMax(), n = (8 & i ? (o = t.x + a * (n.y - t.y) / e,
            s = n.y) : 4 & i ? (o = t.x + a * (h.y - t.y) / e,
            s = h.y) : 2 & i ? (o = n.x,
            s = t.y + e * (n.x - t.x) / a) : 1 & i && (o = h.x,
            s = t.y + e * (h.x - t.x) / a),
            new R(o,s));
        return r && n._round(),
            n
    }
    function Tn(t, e) {
        var i = 0;
        return t.x < e.getMin().x ? i |= 1 : t.x > e.getMax().x && (i |= 2),
            t.y < e.getMin().y ? i |= 4 : t.y > e.getMax().y && (i |= 8),
            i
    }
    function En(t, e, i, n) {
        t = new R(t);
        var r, o, s = Math.abs(i.x - e.x), i = Math.abs(i.y - e.y), a = Math.sqrt(Math.abs(s * s - i * i)), s = i <= s ? (r = new R(e.x - a,e.y),
            o = new R(e.x + a,e.y),
        2 * s) : (r = new R(e.x,e.y - a),
            o = new R(e.x,e.y + a),
        2 * i);
        return t.distanceTo(r) + t.distanceTo(o) <= s + 2 * n
    }
    (e = kn.prototype).getMap = function() {
        return this.geometry.getMap()
    }
        ,
        e.getPainter = function() {
            return this.painter
        }
        ,
        e.isDynamicSize = function() {
            return !1
        }
        ,
        kn.testColor = function(t) {
            return !(!t || !b(t)) && 0 <= G.indexOf(t)
        }
    ;
    Me = kn;
    function kn() {}
    s(An, Rn = Me),
        (ge = An.prototype)._prepareContext = function(t) {
            P(this.symbol.opacity) ? t.globalAlpha !== this.symbol.opacity && (t.globalAlpha = this.symbol.opacity) : 1 !== t.globalAlpha && (t.globalAlpha = 1)
        }
        ,
        ge.prepareCanvas = function(t, e, i) {
            O.prepareCanvas(t, e, i, this.getPainter().isHitTesting())
        }
        ,
        ge.remove = function() {}
        ,
        ge.setZIndex = function() {}
        ,
        ge.show = function() {}
        ,
        ge.hide = function() {}
        ,
        ge._defineStyle = function(t) {
            return function() {
                var s = this
                    , a = []
                    , h = {};
                return Ut(t, function() {
                    var t, e, i, n, r, o = s.getMap();
                    return t = a,
                        e = o.getZoom(),
                        n = m({}, s.geometry.getProperties(), (i = h,
                            n = o.getBearing(),
                            r = o.getPitch(),
                            o = o.getZoom(),
                            i["{bearing}"] = n,
                            i["{pitch}"] = r,
                            i["{zoom}"] = o,
                            i)),
                        t[0] = e,
                        t[1] = n,
                        t
                })
            }
                .bind(this)()
        }
    ;
    var Rn, ve = An;
    function An() {
        return Rn.apply(this, arguments) || this
    }
    var Ln, On = new R(0,0), Dn = new R(0,0), In = (s(jn, Ln = ve),
        (e = jn.prototype).get2DExtent = function() {
            for (var t = this.getMap(), e = t.getGLZoom(), i = new U, n = this._getRenderPoints()[0], r = n.length - 1; 0 <= r; r--)
                n[r] && i._combine(t._pointToPoint(n[r], e));
            return i
        }
        ,
        e.isDynamicSize = function() {
            var t = this.symbol;
            return Wt(t.markerWidth) || Wt(t.markerHeight) || Wt(t.textSize)
        }
        ,
        e._rotateExtent = function(t, e) {
            return t.convertTo(function(t) {
                return t._rotate(e)
            })
        }
        ,
        e._getRenderPoints = function() {
            var t = this.getPainter().isSpriting() ? "center" : this.getPlacement();
            return this.getPainter().getRenderPoints(t)
        }
        ,
        e._getRenderContainerPoints = function(t) {
            var e = this.getPainter()
                , i = this._getRenderPoints()[0];
            if (e.isSpriting())
                return i;
            var e = this.getDxDy()
                , n = this.painter._pointContainerPoints(i, e.x, e.y, t, !0, this.getPlacement());
            if (!n || !Array.isArray(n[0]))
                return n;
            for (var r = [], o = 0, s = n.length; o < s; o++)
                for (var a = 0, h = n[o].length; a < h; a++)
                    r.push(n[o][a]);
            return r
        }
        ,
        e._getRotationAt = function(t) {
            var e = (e = this.getRotation()) || 0
                , i = this._getRenderPoints()[1];
            if (!i || !i[t])
                return e;
            var n, r = this.getMap(), o = i[t][0], s = i[t][1];
            return r.isTransforming() ? (n = r.getGLZoom(),
                o = r._pointToContainerPoint(i[t][0], n, 0, On),
                s = r._pointToContainerPoint(i[t][1], n, 0, Dn),
            e + xt(o.x, o.y, s.x, s.y)) : e + -xt(o.x, o.y, s.x, s.y)
        }
        ,
        e._rotate = function(t, e, i) {
            var n;
            return i ? (n = this.getDxDy(),
                e = e.sub(n),
                t.save(),
                t.translate(e.x, e.y),
                t.rotate(i),
                this.getDxDy()) : null
        }
        ,
        jn);
    function jn(t, e, i) {
        var n = Ln.call(this) || this;
        return n.symbol = t,
            n.geometry = e,
            n.painter = i,
            n
    }
    s(Hn, zn = In),
        Hn.test = function(t) {
            return !!t && !(!V(t.markerFile) || V(t.markerType) || "path" === t.markerType)
        }
        ,
        (e = Hn.prototype).symbolize = function(t, e) {
            var i = this.style;
            !this.painter.isHitTesting() && (0 === i.markerWidth || 0 === i.markerHeight || 0 === i.polygonOpacity && 0 === i.lineOpacity) || L(i = this._getRenderContainerPoints()) && (this._prepareContext(t),
                this.getPainter().isSpriting() || this.geometry.getLayer().getMask() === this.geometry || this._dynamic || !1 === this.geometry.getLayer().options.cacheVectorOnCanvas ? this._drawMarkers(t, i, e) : this._drawMarkersWithCache(t, i, e))
        }
        ,
        e.getDxDy = function() {
            var t = this.style
                , e = t.markerDx
                , t = t.markerDy;
            return new R(e,t)
        }
        ,
        e._drawMarkers = function(t, e, i) {
            var n = this.strokeAndFill;
            te(n.lineColor) || te(n.polygonFill) || this.prepareCanvas(t, n, i);
            for (var r = e.length - 1; 0 <= r; r--) {
                var o = e[r]
                    , s = this._rotate(t, o, this._getRotationAt(r));
                this._drawVectorMarker(t, o = s ? s : o, i),
                s && t.restore()
            }
        }
        ,
        e._drawMarkersWithCache = function(t, e, i) {
            for (var n = this._stampSymbol(), r = i.getImage(n), o = (r || (r = this._createMarkerImage(t, i),
                i.addResource([n, r.width, r.height], r)),
                this._getAnchor(r.width, r.height)), s = e.length - 1; 0 <= s; s--) {
                var a = e[s]
                    , h = this._rotate(t, a, this._getRotationAt(s));
                O.image(t, r, (a = h ? h : a).x + o.x, a.y + o.y),
                h && t.restore()
            }
        }
        ,
        e._calMarkerSize = function() {
            if (!this._size) {
                var t = this.strokeAndFill.lineWidth
                    , e = 2 * (this.symbol.shadowBlur || 0)
                    , i = Math.round(this.style.markerWidth + t + 2 * e + 2 * this.padding)
                    , t = Math.round(this.style.markerHeight + t + 2 * e + 2 * this.padding);
                if (Wt(this.symbol.markerWidth) || Wt(this.symbol.markerHeight))
                    return [i, t];
                this._size = [i, t]
            }
            return this._size
        }
        ,
        e._createMarkerImage = function(t, e) {
            var t = t.canvas.constructor
                , i = this._calMarkerSize()
                , t = O.createCanvas(i[0], i[1], t)
                , i = this._getCacheImageAnchor(i[0], i[1])
                , n = t.getContext("2d");
            return te(this.strokeAndFill.lineColor) || te(this.strokeAndFill.polygonFill) || this.prepareCanvas(n, this.strokeAndFill, e),
                this._drawVectorMarker(n, i, e),
                t
        }
        ,
        e._stampSymbol = function() {
            return this._stamp || (this._stamp = [this.style.markerType, te(this.style.markerFill) ? ee(this.style.markerFill) : this.style.markerFill, this.style.markerFillOpacity, this.style.markerFillPatternFile, te(this.style.markerLineColor) ? ee(this.style.markerLineColor) : this.style.markerLineColor, this.style.markerLineWidth, this.style.markerLineOpacity, this.style.markerLineDasharray ? this.style.markerLineDasharray.join(",") : "", this.style.markerLinePatternFile, this.style.markerWidth, this.style.markerHeight, this.style.markerHorizontalAlignment, this.style.markerVerticalAlignment].join("_")),
                this._stamp
        }
        ,
        e._getAnchor = function(t, e) {
            var i = 2 * (this.symbol.shadowBlur || 0) + this.padding
                , n = Be(new Le(t,e), this.style.markerHorizontalAlignment, this.style.markerVerticalAlignment);
            return n.x !== -t / 2 && (n.x -= ht(n.x + t / 2) * i),
            n.y !== -e / 2 && (n.y -= ht(n.y + e / 2) * i),
                n
        }
        ,
        e._getCacheImageAnchor = function(t, e) {
            var i = 2 * (this.symbol.shadowBlur || 0) + this.padding
                , n = this.style.markerType;
            return "bar" === n || "pie" === n || "pin" === n ? new R(t / 2,e - i) : "rectangle" === n ? new R(i,i) : new R(t / 2,e / 2)
        }
        ,
        e._getGraidentExtent = function(t) {
            var e = new U
                , i = this.getDxDy()
                , n = this.getFixedExtent();
            if (Array.isArray(t))
                for (var r = t.length - 1; 0 <= r; r--)
                    e._combine(t[r]);
            else
                e._combine(t);
            return e.xmin += n.xmin - i.x,
                e.ymin += n.ymin - i.y,
                e.xmax += n.xmax - i.x,
                e.ymax += n.ymax - i.y,
                e
        }
        ,
        e._drawVectorMarker = function(t, e, i) {
            var n = this.style
                , r = this.strokeAndFill
                , o = n.markerType.toLowerCase()
                , s = Hn._getVectorPoints(o, n.markerWidth, n.markerHeight)
                , a = r.lineOpacity
                , h = r.polygonOpacity
                , l = ((te(r.lineColor) || te(r.polygonFill)) && (te(r.lineColor) && (l = this._getGraidentExtent(e),
                r.lineGradientExtent = l.expand(r.lineWidth)),
            te(r.polygonFill) && (l = l || this._getGraidentExtent(e),
                r.polygonGradientExtent = l),
                this.prepareCanvas(t, r, i)),
                n.markerWidth)
                , r = n.markerHeight
                , i = n.markerLineWidth / 2;
            if ("ellipse" === o)
                O.ellipse(t, e, l / 2, r / 2, r / 2, a, h);
            else if ("cross" === o || "x" === o) {
                for (var u = s.length - 1; 0 <= u; u--)
                    s[u]._add(e);
                O.path(t, s.slice(0, 2), a),
                    O.path(t, s.slice(2, 4), a)
            } else if ("diamond" === o || "bar" === o || "square" === o || "rectangle" === o || "triangle" === o) {
                "bar" === o ? e = e.add(0, -i) : "rectangle" === o && (e = e.add(i, i));
                for (var c = s.length - 1; 0 <= c; c--)
                    s[c]._add(e);
                O.polygon(t, s, a, h)
            } else if ("pin" === o) {
                e = e.add(0, -i);
                for (var d = s.length - 1; 0 <= d; d--)
                    s[d]._add(e);
                n = t.lineCap;
                t.lineCap = "round",
                    O.bezierCurveAndFill(t, s, a, h),
                    t.lineCap = n
            } else {
                if ("pie" !== o)
                    throw new Error("unsupported markerType: " + o);
                e = e.add(0, i);
                n = 180 * Math.atan(l / 2 / r) / Math.PI,
                    o = t.lineCap;
                t.lineCap = "round",
                    O.sector(t, e, r, [90 - n, 90 + n], a, h),
                    t.lineCap = o
            }
        }
        ,
        e.getPlacement = function() {
            return this.symbol.markerPlacement
        }
        ,
        e.getRotation = function() {
            var t = this.style.markerRotation;
            return P(t) ? -t * Math.PI / 180 : null
        }
        ,
        e.getFixedExtent = function() {
            var t = this.getDxDy()
                , e = 2 * this.padding
                , i = this._calMarkerSize().map(function(t) {
                return t - e
            })
                , n = this._getAnchor(i[0], i[1])
                , t = new U(t.add(0, 0),t.add(i[0], i[1]))
                , i = (t._add(n),
                this.getRotation());
            return t = i ? this._rotateExtent(t, i) : t
        }
        ,
        e.translate = function() {
            var t, e = this.symbol, i = {
                markerType: r(e.markerType, "ellipse"),
                markerFill: r(e.markerFill, "#00f"),
                markerFillOpacity: r(e.markerFillOpacity, 1),
                markerFillPatternFile: r(e.markerFillPatternFile, null),
                markerLineColor: r(e.markerLineColor, "#000"),
                markerLineWidth: r(e.markerLineWidth, 1),
                markerLineOpacity: r(e.markerLineOpacity, 1),
                markerLineDasharray: r(e.markerLineDasharray, []),
                markerLinePatternFile: r(e.markerLinePatternFile, null),
                markerDx: r(e.markerDx, 0),
                markerDy: r(e.markerDy, 0),
                markerWidth: r(e.markerWidth, 10),
                markerHeight: r(e.markerHeight, 10),
                markerRotation: r(e.markerRotation, 0)
            }, n = i.markerType, n = "bar" === n || "pie" === n || "pin" === n ? (t = "middle",
                "top") : "rectangle" === n ? (t = "right",
                "bottom") : t = "middle";
            return i.markerHorizontalAlignment = r(e.markerHorizontalAlignment, t),
                i.markerVerticalAlignment = r(e.markerVerticalAlignment, n),
            P(e.markerOpacity) && (P(e.markerFillOpacity) && (i.markerFillOpacity *= e.markerOpacity),
            P(e.markerLineOpacity) && (i.markerLineOpacity *= e.markerOpacity)),
                i
        }
        ,
        Hn.translateLineAndFill = function(t) {
            t = {
                lineColor: t.markerLineColor,
                linePatternFile: t.markerLinePatternFile,
                lineWidth: t.markerLineWidth,
                lineOpacity: t.markerLineOpacity,
                lineDasharray: t.markerLineDasharray,
                lineCap: "butt",
                lineJoin: "round",
                polygonFill: t.markerFill,
                polygonPatternFile: t.markerFillPatternFile,
                polygonOpacity: t.markerFillOpacity
            };
            return 0 === t.lineWidth && (t.lineOpacity = 0),
                t
        }
        ,
        Hn._getVectorPoints = function(t, e, i) {
            var n, r, o, s, a = i / 2, h = e / 2;
            return "triangle" === t ? [n = new R(0,0 - a), r = new R(0 - h,0 + a), o = new R(0 + h,0 + a)] : "cross" === t ? [n = new R(0 - h,0), r = new R(0 + h,0), o = new R(0,0 - a), s = new R(0,0 + a)] : "diamond" === t ? [n = new R(0 - h,0), r = new R(0,0 - a), o = new R(0 + h,0), s = new R(0,0 + a)] : "square" === t ? [n = new R(0 - h,0 + a), r = new R(0 + h,0 + a), o = new R(0 + h,0 - a), s = new R(0 - h,0 - a)] : "rectangle" === t ? (r = (n = new R(0,0)).add(e, 0),
                o = n.add(e, i),
                s = n.add(0, i),
                [n, r, o, s]) : "x" === t ? [n = new R(0 - h,0 + a), r = new R(0 + h,0 - a), o = new R(0 + h,0 + a), s = new R(0 - h,0 - a)] : "bar" === t ? [n = new R(0 - h,0 - i), r = new R(0 + h,0 - i), o = new R(0 + h,0), s = new R(0 - h,0)] : "pin" === t ? (e = i * Math.atan(h / a),
                [n = new R(0,0), r = new R(0 - e,0 - i), o = new R(0 + e,0 - i), s = new R(0,0)]) : []
        }
    ;
    var zn, Zn = Hn;
    function Hn(t, e, i) {
        e = zn.call(this, t, e, i) || this,
            e._dynamic = Bt(t),
            e.style = e._defineStyle(e.translate()),
            e.strokeAndFill = e._defineStyle(Hn.translateLineAndFill(e.style)),
            i = e.strokeAndFill.lineWidth;
        return e.padding = i % 2 == 0 ? 2 : 1.5,
            e
    }
    s(Nn, Gn = In),
        (e = Nn.prototype).getPlacement = function() {
            return "point"
        }
        ,
        e.getDxDy = function() {
            return new R(0,0)
        }
        ,
        e.symbolize = function(t) {
            var e = this.geometry
                , i = e.getLayer();
            if (e.options.debug || !i || i.options.debug) {
                e = this.getMap();
                if (e && !e.isZooming())
                    for (var n = i.options.debugOutline, e = (t.strokeStyle = n,
                        t.fillStyle = n,
                        this.getPainter().getContainerExtent().toArray()), r = (O.polygon(t, [e], 1, 0),
                        this._getRenderContainerPoints()), o = this.geometry.getId(), s = Zn._getVectorPoints("cross", 10, 10), a = 0; a < r.length; a++) {
                        for (var h = r[a], l = (V(o) || O.fillText(t, o, h.add(8, -4), n),
                            []), u = 0; u < s.length; u++)
                            l.push(s[u].add(h));
                        O.path(t, l.slice(0, 2), 1),
                            O.path(t, l.slice(2, 4), 1)
                    }
            }
        }
    ;
    var Gn, Fn = Nn;
    function Nn() {
        return Gn.apply(this, arguments) || this
    }
    s(Vn, Wn = In),
        Vn.test = function(t) {
            return !!t && !V(t.markerFile)
        }
        ,
        (e = Vn.prototype).symbolize = function(t, e) {
            var i = this.style;
            if (this.painter.isHitTesting() || 0 !== i.markerWidth && 0 !== i.markerHeight && 0 !== i.markerOpacity) {
                var n = this._getRenderContainerPoints();
                if (L(n)) {
                    var r = this._getImage(e);
                    if (r) {
                        this._prepareContext(t);
                        for (var o, s, a = i.markerWidth, h = i.markerHeight, l = (P(a) && P(h) || (a = r.width,
                            h = r.height,
                            i.markerWidth = a,
                            i.markerHeight = h,
                            o = [i.markerFile, i.markerWidth, i.markerHeight],
                        e.isResourceLoaded(o) || e.addResource(o, r),
                        (e = this.getPainter()).isSpriting() || e.removeCache()),
                        "path" !== this.symbol.markerType && P(i.markerOpacity) && i.markerOpacity < 1 && (s = t.globalAlpha,
                            t.globalAlpha *= i.markerOpacity),
                            Be(new Le(a,h), i.markerHorizontalAlignment, i.markerVerticalAlignment)), u = 0, c = n.length; u < c; u++) {
                            var d = n[u]
                                , g = this._rotate(t, d, this._getRotationAt(u));
                            O.image(t, r, (d = g ? g : d).x + l.x, d.y + l.y, a, h),
                            g && t.restore()
                        }
                        void 0 !== s && (t.globalAlpha = s)
                    } else
                        "undefined" != typeof console && console.warn("no img found for " + (this.style.markerFile || this._url[0]))
                }
            }
        }
        ,
        e._getImage = function(t) {
            return t ? t.getImage([this.style.markerFile, this.style.markerWidth, this.style.markerHeight]) : null
        }
        ,
        e.getPlacement = function() {
            return this.symbol.markerPlacement
        }
        ,
        e.getRotation = function() {
            var t = this.style.markerRotation;
            return P(t) ? -t * Math.PI / 180 : null
        }
        ,
        e.getDxDy = function() {
            var t = this.style
                , e = t.markerDx
                , t = t.markerDy;
            return new R(e,t)
        }
        ,
        e.getFixedExtent = function(t) {
            var e = this.style
                , i = e.markerFile
                , t = t ? t.getImage(i) : null
                , i = e.markerWidth || (t ? t.width : 0)
                , t = e.markerHeight || (t ? t.height : 0)
                , n = this.getDxDy()
                , e = Be(new Le(i,t), e.markerHorizontalAlignment, e.markerVerticalAlignment)
                , n = new U(n.add(0, 0),n.add(i, t))
                , i = (n._add(e),
                this.getRotation());
            return n = i ? this._rotateExtent(n, i) : n
        }
        ,
        e.translate = function() {
            var t = this.symbol;
            return {
                markerFile: t.markerFile,
                markerOpacity: r(t.markerOpacity, 1),
                markerWidth: r(t.markerWidth, null),
                markerHeight: r(t.markerHeight, null),
                markerRotation: r(t.markerRotation, 0),
                markerDx: r(t.markerDx, 0),
                markerDy: r(t.markerDy, 0),
                markerHorizontalAlignment: r(t.markerHorizontalAlignment, "middle"),
                markerVerticalAlignment: r(t.markerVerticalAlignment, "top")
            }
        }
    ;
    var Wn, Bn = Vn;
    function Vn(t, e, i) {
        t = Wn.call(this, t, e, i) || this;
        return t.style = t._defineStyle(t.translate()),
            t
    }
    var Un, Jn = new M(0,0), qn = new M(0,0), Yn = (s(Xn, Un = ve),
        Xn.test = function(t, e) {
            if (!t)
                return !1;
            if (e && "Point" === e.type)
                return !1;
            for (var i in t) {
                i = i.slice(0, 4);
                if ("line" === i || "poly" === i)
                    return !0
            }
            return !1
        }
        ,
        (e = Xn.prototype).symbolize = function(t, e) {
            var i = this.style;
            if (0 !== i.polygonOpacity || 0 !== i.lineOpacity || this.painter.isHitTesting()) {
                var n = this._getPaintParams();
                if (n) {
                    this._prepareContext(t);
                    var r = te(i.lineColor)
                        , o = "Polygon" === this.geometry.getJSONType() || "LineString" === this.geometry.type
                        , s = (!r || !i.lineColor.places && o || (i.lineGradientExtent = this.getPainter().getContainerExtent()._expand(i.lineWidth)),
                    te(i.polygonFill) && (i.polygonGradientExtent = this.getPainter().getContainerExtent()),
                        n[0]);
                    if ("Polygon" === this.geometry.getJSONType() && 0 < s.length && Array.isArray(s[0][0]) || "LineString" === this.geometry.type && 0 < s.length && Array.isArray(s[0]))
                        for (var a = 0; a < s.length; a++) {
                            this.prepareCanvas(t, i, e),
                            r && o && !i.lineColor.places && this._createGradient(t, s[a], i.lineColor);
                            var h = [t, s[a]];
                            1 < n.length && h.push.apply(h, n.slice(1)),
                                h.push(i.lineOpacity, i.polygonOpacity, i.lineDasharray),
                                this.geometry._paintOn.apply(this.geometry, h)
                        }
                    else {
                        this.prepareCanvas(t, i, e),
                        r && o && !i.lineColor.places && this._createGradient(t, s, i.lineColor);
                        var l = [t];
                        l.push.apply(l, n),
                            l.push(i.lineOpacity, i.polygonOpacity, i.lineDasharray),
                            this.geometry._paintOn.apply(this.geometry, l)
                    }
                    t.setLineDash && Array.isArray(i.lineDasharray) && t.setLineDash([])
                }
            }
        }
        ,
        e.get2DExtent = function() {
            var t = this.getMap()
                , e = this.geometry._getPrjExtent();
            if (!e)
                return null;
            this._extMin && this._extMax || (this._extMin = new M(0,0),
                this._extMax = new M(0,0)),
                this._extMin.x = e.xmin,
                this._extMin.y = e.ymin,
                this._extMax.x = e.xmax,
                this._extMax.y = e.ymax;
            e = t._prjToPoint(this._extMin, void 0, Jn),
                t = t._prjToPoint(this._extMax, void 0, qn);
            return this._pxExtent ? this._pxExtent.set(Math.min(e.x, t.x), Math.min(e.y, t.y), Math.max(e.x, t.x), Math.max(e.y, t.y)) : this._pxExtent = new U(e,t),
                this._pxExtent
        }
        ,
        e.getFixedExtent = function() {
            var t = this.style.lineWidth / 2;
            return new U(-t,-t,t,t)
        }
        ,
        e._getPaintParams = function() {
            return this.getPainter().getPaintParams(this.style.lineDx, this.style.lineDy)
        }
        ,
        e.translate = function() {
            var t = this.symbol
                , t = {
                lineColor: r(t.lineColor, "#000"),
                lineWidth: r(t.lineWidth, 2),
                lineOpacity: r(t.lineOpacity, 1),
                lineDasharray: r(t.lineDasharray, []),
                lineCap: r(t.lineCap, "butt"),
                lineJoin: r(t.lineJoin, "miter"),
                linePatternFile: r(t.linePatternFile, null),
                lineDx: r(t.lineDx, 0),
                lineDy: r(t.lineDy, 0),
                polygonFill: r(t.polygonFill, null),
                polygonOpacity: r(t.polygonOpacity, 1),
                polygonPatternFile: r(t.polygonPatternFile, null),
                polygonPatternDx: r(t.polygonPatternDx, 0),
                polygonPatternDy: r(t.polygonPatternDy, 0),
                linePatternDx: r(t.linePatternDx, 0),
                linePatternDy: r(t.linePatternDy, 0)
            };
            return 0 === t.lineWidth && (t.lineOpacity = 0),
            "LineString" !== this.geometry.type || t.polygonFill || (t.polygonFill = t.lineColor),
                t
        }
        ,
        e._createGradient = function(t, e, i) {
            var n, r;
            Array.isArray(e) && e.length && (n = e.length,
                r = t.createLinearGradient(e[0].x, e[0].y, e[n - 1].x, e[n - 1].y),
                i.colorStops.forEach(function(t) {
                    r.addColorStop.apply(r, t)
                }),
                t.strokeStyle = r)
        }
        ,
        Xn);
    function Xn(t, e, i) {
        var n = Un.call(this) || this;
        return n.symbol = t,
            n.geometry = e,
            n.painter = i,
            "Point" === e.type ? Ee(n) : (n.style = n._defineStyle(n.translate()),
                n)
    }
    var Kn, Qn = "___text_symbol_cache", $n = (s(tr, Kn = In),
        tr.test = function(t) {
            return !!t && !V(t.textName)
        }
        ,
        (e = tr.prototype).symbolize = function(t, e) {
            if (this.painter.isHitTesting() || 0 !== this.style.textSize && (this.style.textOpacity || this.style.textHaloRadius && this.style.textHaloOpacity) && 0 !== this.style.textWrapWidth) {
                var i = this._getRenderContainerPoints();
                if (L(i)) {
                    var n = this.style
                        , r = this.strokeAndFill
                        , o = We(this.style.textName, this.geometry.getProperties());
                    this._descText(o),
                        this._prepareContext(t),
                        this.prepareCanvas(t, r, e),
                        O.prepareCanvasFont(t, n);
                    for (var s = 0, a = i.length; s < a; s++) {
                        var h = i[s]
                            , l = this._rotate(t, h, this._getRotationAt(s));
                        O.text(t, o, h = l ? l : h, n, this.textDesc),
                        l && t.restore()
                    }
                }
            }
        }
        ,
        e.getPlacement = function() {
            return this.symbol.textPlacement
        }
        ,
        e.getRotation = function() {
            var t = this.style.textRotation;
            return P(t) ? -t * Math.PI / 180 : null
        }
        ,
        e.getDxDy = function() {
            var t = this.style;
            return new R(t.textDx,t.textDy)
        }
        ,
        e.getFixedExtent = function() {
            var t = this.getDxDy()
                , e = this.style
                , i = this.textDesc.size
                , n = Be(i, e.textHorizontalAlignment, e.textVerticalAlignment)
                , r = n.x
                , n = n.y
                , e = (e.textHaloRadius && (e = e.textHaloRadius,
                i = i.add(2 * e, 2 * e)),
                new U(t.add(r, n),t.add(r + i.width, n + i.height)))
                , t = this.getRotation();
            return e = t ? this._rotateExtent(e, t) : e
        }
        ,
        e.translate = function() {
            var t = this.symbol
                , t = {
                textName: t.textName,
                textFaceName: r(t.textFaceName, "monospace"),
                textWeight: r(t.textWeight, "normal"),
                textStyle: r(t.textStyle, "normal"),
                textSize: r(t.textSize, 14),
                textFont: r(t.textFont, null),
                textFill: r(t.textFill, "#000"),
                textOpacity: r(t.textOpacity, 1),
                textHaloFill: r(t.textHaloFill, "#ffffff"),
                textHaloRadius: r(t.textHaloRadius, 0),
                textHaloOpacity: r(t.textHaloOpacity, 1),
                textWrapWidth: r(t.textWrapWidth, null),
                textWrapCharacter: r(t.textWrapCharacter, "\n"),
                textLineSpacing: r(t.textLineSpacing, 0),
                textDx: r(t.textDx, 0),
                textDy: r(t.textDy, 0),
                textHorizontalAlignment: r(t.textHorizontalAlignment, "middle"),
                textVerticalAlignment: r(t.textVerticalAlignment, "middle"),
                textAlign: r(t.textAlign, "center"),
                textRotation: r(t.textRotation, 0),
                textMaxWidth: r(t.textMaxWidth, 0),
                textMaxHeight: r(t.textMaxHeight, 0)
            };
            return 0 < t.textMaxWidth && (!t.textWrapWidth || t.textWrapWidth > t.textMaxWidth) && (t.textWrapWidth || (t.textMaxHeight = 1),
                t.textWrapWidth = t.textMaxWidth),
                t
        }
        ,
        e.translateLineAndFill = function(t) {
            return {
                lineColor: t.textHaloRadius ? t.textHaloFill : t.textFill,
                lineWidth: t.textHaloRadius,
                lineOpacity: t.textOpacity,
                lineDasharray: null,
                lineCap: "butt",
                lineJoin: "round",
                polygonFill: t.textFill,
                polygonOpacity: t.textOpacity
            }
        }
        ,
        e._descText = function(t) {
            this._dynamic ? this.textDesc = this._measureText(t) : (this.textDesc = this._loadFromCache(),
            this.textDesc || (this.textDesc = this._measureText(t),
                this._storeToCache(this.textDesc)))
        }
        ,
        e._measureText = function(t) {
            var e = this.style.textMaxHeight
                , t = Ue(t, this.style);
            return e && e < t.size.height && (t.size.height = e),
                t
        }
        ,
        e._storeToCache = function(t) {
            $ || (this.geometry[Qn] || (this.geometry[Qn] = {}),
                this.geometry[Qn][this._cacheKey] = {
                    desc: t,
                    active: !0
                })
        }
        ,
        e._loadFromCache = function() {
            if (!this.geometry[Qn])
                return null;
            var t = this.geometry[Qn][this._cacheKey];
            return t ? (t.active = !0,
                t.desc) : null
        }
        ,
        tr);
    function tr(t, e, i) {
        e = Kn.call(this, t, e, i) || this;
        if (e._dynamic = Bt(t),
            e.style = e._defineStyle(e.translate()),
        0 === e.style.textWrapWidth)
            return Ee(e);
        e.strokeAndFill = e._defineStyle(e.translateLineAndFill(e.style));
        i = We(e.style.textName, e.geometry.getProperties());
        return e._dynamic || (e._cacheKey = function(t, e) {
            var i, n = [t];
            for (i in e)
                e.hasOwnProperty(i) && 4 < i.length && "text" === i.substring(0, 4) && n.push(i + "=" + e[i]);
            return n.join("-")
        }(i, e.style)),
            e._descText(i),
            e
    }
    $n.CACHE_KEY = Qn;
    s(nr, er = Bn),
        nr.test = function(t) {
            return !!t && !(!V(t.markerFile) || "path" !== t.markerType)
        }
        ,
        (e = nr.prototype)._prepareContext = function() {}
        ,
        e._getImage = function(e) {
            var i = this;
            if (e && e.isResourceLoaded(this._url))
                return e.getImage(this._url);
            var n = this.painter
                , t = new Image;
            return t.onload = function() {
                var t = n.getLayer() && n.getLayer().getRenderer();
                t && t.setToRedraw()
            }
                ,
                t.onerror = function(t) {
                    t && "undefined" != typeof console && console.warn(t),
                        e.markErrorResource(i._url)
                }
                ,
                t.src = this._url[0],
            e && e.addResource(this._url, t),
                t
        }
    ;
    var er, ir = nr;
    function nr(t, e, i) {
        V(t.markerWidth) && (t.markerWidth = 80),
        V(t.markerHeight) && (t.markerHeight = 80),
            t = m(t, (e = er.call(this, t, e, i) || this).translate());
        i = e.style = e._defineStyle(t);
        return c.gecko ? e._url = [Kt(i, i.markerWidth, i.markerHeight), i.markerWidth, i.markerHeight] : e._url = [Kt(i), i.markerWidth, i.markerHeight],
            e
    }
    var rr, or = {
        lineWidth: 1,
        polygonFill: "#fff",
        polygonOpacity: .5
    }, e = (s(sr, rr = In),
        sr.test = function(t, e) {
            if (!e.getLayer())
                return !1;
            e = e.getJSONType();
            return "Marker" === e || "LineString" === e
        }
        ,
        (e = sr.prototype).symbolize = function(t) {
            var e, i = this.geometry.getLayer();
            !i.options.drawAltitude || (e = this.geometry.getProperties()) && e[i.options.altitudeProperty] && (e = this._getStyle(),
                this._prepareContext(t),
                "LineString" === this.geometry.type ? (i = this._getPaintParams(e.lineDx, e.lineDy)) && (e = this.getPainter().getPaintParams(e.lineDx, e.lineDy, !0)[0],
                    this._drawLineAltitude(t, i[0], e)) : (i = this._getRenderContainerPoints(),
                    e = this._getRenderContainerPoints(!0),
                i && 0 !== i.length && this._drawMarkerAltitude(t, i[0], e[0])))
        }
        ,
        e.getDxDy = function() {
            var t = this.dxdy;
            return new R(t.dx || 0,t.dy || 0)
        }
        ,
        e.get2DExtent = function() {
            return "LineString" === this.geometry.type ? Yn.prototype.get2DExtent.apply(this) : rr.prototype.get2DExtent.call(this)
        }
        ,
        e.getPlacement = function() {
            return "point"
        }
        ,
        e._getPaintParams = function(t, e) {
            return this.getPainter().getPaintParams(t || 0, e || 0)
        }
        ,
        e._drawMarkerAltitude = function(t, e, i) {
            var n = this._getStyle();
            this.prepareCanvas(t, n),
                O.path(t, [e, i], n.lineOpacity, null, n.lineDasharray)
        }
        ,
        e._drawLineAltitude = function(t, e, i) {
            var n = this._getStyle();
            if (0 < e.length && Array.isArray(e[0]))
                for (var r = 0; r < e.length; r++)
                    this._drawLine(t, e[r], i[r]);
            else
                this._drawLine(t, e, i);
            t.setLineDash && Array.isArray(n.lineDasharray) && t.setLineDash([])
        }
        ,
        e._drawLine = function(t, e, i) {
            var n = this._getStyle();
            this.prepareCanvas(t, n);
            for (var r = 0, o = e.length - 1; r < o; r++)
                O.polygon(t, [e[r], e[r + 1], i[r + 1], i[r]], n.lineOpacity, n.polygonOpacity, n.lineDasharray)
        }
        ,
        e._getStyle = function() {
            var t = this.geometry.getLayer().options.drawAltitude;
            return (t = W(t) ? t : or).lineWidth || (t.lineWidth = 0,
                t.lineOpacity = 0),
                t
        }
        ,
        sr);
    function sr(t, e, i) {
        i = rr.call(this, t, e, i) || this;
        return i.style = e.getLayer().options.drawAltitude,
        i.style && W(i.style) || (i.style = {
            lineWidth: 2
        }),
        i.style.lineWidth || (i.style.lineWidth = 0),
            i.dxdy = i._defineStyle({
                dx: t.textDx || t.markerDx,
                dy: t.textDy || t.markerDy
            }),
            i
    }
    var ar, hr, lr = Object.freeze({
        Symbolizer: Me,
        CanvasSymbolizer: ve,
        DebugSymbolizer: Fn,
        ImageMarkerSymbolizer: Bn,
        PointSymbolizer: In,
        StrokeAndFillSymbolizer: Yn,
        TextMarkerSymbolizer: $n,
        VectorMarkerSymbolizer: Zn,
        VectorPathMarkerSymbolizer: ir,
        DrawAltitudeSymbolizer: e
    }), ur = [e, Yn, Bn, ir, Zn, $n], cr = new R(0,0), dr = new U, gr = new U, pr = new U, fr = new U, mr = new U, _r = (s(yr, hr = _e),
        (e = yr.prototype).getMap = function() {
            return this.geometry.getMap()
        }
        ,
        e.getLayer = function() {
            return this.geometry.getLayer()
        }
        ,
        e._createSymbolizers = function() {
            for (var t, e = this.getSymbol(), i = [], n = ur, r = e, o = (r = Array.isArray(e) ? r : [e]).length - 1; 0 <= o; o--)
                for (var s, a = r[o], h = n.length - 1; 0 <= h; h--)
                    n[h].test(a, this.geometry) && (s = new n[h](a,this.geometry,this),
                        i.push(s),
                    s instanceof In && (this._hasPoint = !0));
            return i.length || console && (t = this.geometry.getId(),
                console.warn("invalid symbol for geometry(" + (this.geometry ? this.geometry.getType() + (t ? ":" + t : "") : "") + ") to draw : " + JSON.stringify(e))),
                this._debugSymbolizer = new Fn(e,this.geometry,this),
                i
        }
        ,
        e.hasPoint = function() {
            return !!this._hasPoint
        }
        ,
        e.getRenderPoints = function(t) {
            return this._renderPoints || (this._renderPoints = {}),
            this._renderPoints[t = t || "center"] || (this._renderPoints[t] = this.geometry._getRenderPoints(t)),
                this._renderPoints[t]
        }
        ,
        e.getPaintParams = function(t, e, i) {
            var n = this.getMap()
                , r = this.geometry
                , o = n.getResolution()
                , s = 0 !== n.getPitch()
                , a = 0 !== n.getBearing()
                , h = this._cachedParams
                , l = r._paintAsPath && r._paintAsPath();
            if (l && this._unsimpledParams && o <= this._unsimpledParams._res)
                h = this._unsimpledParams;
            else if (!h || h._res !== n.getResolution() || this._pitched !== s && r._redrawWhenPitch() || this._rotated !== a && r._redrawWhenRotate()) {
                if (!(h = r._getPaintParams()))
                    return null;
                h._res = o,
                !r._simplified && l && (this._unsimpledParams || (this._unsimpledParams = h),
                o > this._unsimpledParams._res && (this._unsimpledParams._res = o)),
                    this._cachedParams = h
            }
            if (!h)
                return null;
            this._pitched = s,
                this._rotated = a;
            var u = n.getGLScale()
                , c = []
                , r = h[0]
                , l = n.getContainerExtent()
                , o = this._pointContainerPoints(r, t, e, i, this._hitPoint && !l.contains(this._hitPoint));
            if (!o)
                return null;
            c.push(o);
            for (var d = 1, g = h.length; d < g; d++)
                P(h[d]) || h[d]instanceof Le ? P(h[d]) ? c.push(h[d] / u) : c.push(h[d].multi(1 / u)) : c.push(h[d]);
            return c
        }
        ,
        e._pointContainerPoints = function(t, i, n, e, r, o) {
            if (this._aboveCamera())
                return null;
            var s = this.getMap()
                , a = s.getGLZoom()
                , h = this.containerOffset;
            function l(t, e) {
                t = s._pointToContainerPoint(t, a, e)._sub(h);
                return (i || n) && t._add(i || 0, n || 0),
                    t
            }
            var u = this.getAltitude();
            if (Array.isArray(t))
                for (var c = this.geometry, r = !r && c.options.enableClip ? this._clip(t, u) : {
                    points: t,
                    altitude: u
                }, d = r.points, u = r.altitude, g = u = e ? 0 : u, p = [], f = 0, m = d.length; f < m; f++) {
                    var _ = d[f];
                    if (Array.isArray(_)) {
                        for (var y = [], v = 0, x = _.length; v < x; v++) {
                            var w = _[v];
                            Array.isArray(u) && (g = u[f] ? u[f][v] : 0),
                                y.push(l(w, g))
                        }
                        p.push(y)
                    } else
                        Array.isArray(u) && (g = "vertex-last" === o ? u[u.length - 1 - f] : "line" === o ? (u[f] + u[f + 1]) / 2 : u[f]),
                            p.push(l(_, g))
                }
            else
                t instanceof R && (p = s._pointToContainerPoint(t, a, u = e ? 0 : u)._sub(h),
                (i || n) && p._add(i, n));
            return p
        }
        ,
        e._clip = function(t, e) {
            var i, n, r = this.getMap(), o = this.geometry, s = this.getSymbol().lineWidth, a = (P(s) || (s = 4),
                r._get2DExtent(void 0, fr)._expand(s));
            0 < r.getPitch() && e && (i = r.cameraLookAt,
                n = r.cameraPosition,
                cr.set(n.x, n.y),
                a = a._combine(cr._add(ht(i[0] - n[0]), ht(i[1] - n[1]))));
            var h = t;
            if (this.get2DExtent(null, mr).within(a))
                return {
                    points: h,
                    altitude: e
                };
            var l = r._get2DExtent(r.getGLZoom(), fr)._expand(s * r._glScale)
                , u = o.options.smoothness;
            if (o.getShell && this.geometry.getHoles && !u)
                if (Array.isArray(t[0]))
                    for (var h = [], c = 0; c < t.length; c++) {
                        var d = Mn(t[c], l);
                        d.length && h.push(d)
                    }
                else
                    h = Mn(t, l);
            else if ("LineString" === o.getJSONType() && !u) {
                if (Array.isArray(t[0])) {
                    h = [];
                    for (var g = 0; g < t.length; g++)
                        ot(h, bn(t[g], l, !1, !!u))
                } else
                    h = bn(t, l, !1, !!u);
                return this._interpolateSegAlt(h, t, e)
            }
            return {
                points: h,
                altitude: e
            }
        }
        ,
        e._interpolateSegAlt = function(t, e, n) {
            var i;
            if (!Array.isArray(n))
                return i = function(t) {
                    return t.point
                }
                    ,
                    {
                        points: t.map(function(t) {
                            return Array.isArray(t) ? t.map(i) : t.point
                        }),
                        altitude: n
                    };
            t = function t(e, i, n) {
                if (!Array.isArray(n))
                    return e;
                var r = [];
                for (var o = 0, s = e.length; o < s; o++) {
                    var a, h, l, u;
                    Array.isArray(e[o]) ? r.push(t(e[o], i, n)) : ((a = e[o]).point.equals(i[a.index]) ? a.altitude = n[a.index] : (h = u = void 0,
                        h = 0 === a.index ? (u = a.index,
                        a.index + 1) : (u = a.index - 1,
                            a.index),
                        l = a.point.distanceTo(i[h]),
                        l = l / (l + i[u].distanceTo(a.point)),
                        u = ut(n[u], n[h], 1 - l),
                        a.altitude = u),
                        r.push(a))
                }
                return r
            }(t, e, n);
            return n = [],
                {
                    points: t.map(function(t) {
                        var e, i;
                        return Array.isArray(t) ? (e = [],
                            i = t.map(function(t) {
                                return e.push(t.altitude),
                                    t.point
                            }),
                            n.push(e),
                            i) : (n.push(t.altitude),
                            t.point)
                    }),
                    altitude: n
                }
        }
        ,
        e.getSymbol = function() {
            return this.geometry._getInternalSymbol()
        }
        ,
        e.paint = function(t, e, i) {
            if (this.symbolizers) {
                var n = this.getLayer()._getRenderer();
                if (n && (n.context || e) && (!t || t.intersects(this.get2DExtent(n.resources, dr)))) {
                    var t = this.getMap()
                        , r = this.getMinAltitude()
                        , o = t.getFrustumAltitude();
                    if (!(r && o && o < r)) {
                        this.containerOffset = i || t._pointToContainerPoint(n.southWest)._add(0, -t.height),
                            this._beforePaint();
                        for (var s = e || n.context, a = [s, n.resources], h = this.symbolizers.length - 1; 0 <= h; h--)
                            this._prepareShadow(s, this.symbolizers[h].symbol),
                                this.symbolizers[h].symbolize.apply(this.symbolizers[h], a);
                        this._afterPaint(),
                            this._painted = !0,
                            this._debugSymbolizer.symbolize.apply(this._debugSymbolizer, a)
                    }
                }
            }
        }
        ,
        e.getSprite = function(e, t) {
            if ("Point" !== this.geometry.type)
                return null;
            if (this._spriting = !0,
            !this._sprite && 0 < this.symbolizers.length) {
                for (var i, n = new U, r = (this.symbolizers.forEach(function(t) {
                    t = t.getFixedExtent(e);
                    n._combine(t)
                }),
                    n.getMin().multi(-1)), t = t || (this.getMap() ? this.getMap().CanvasClass : null), t = O.createCanvas(n.getWidth(), n.getHeight(), t), o = (this._renderPoints && (i = this._renderPoints),
                    t.getContext("2d")), s = [o, e], a = this.symbolizers.length - 1; 0 <= a; a--) {
                    var h = this.symbolizers[a].getDxDy();
                    this._renderPoints = {
                        center: [[r.add(h)]]
                    },
                        this._prepareShadow(o, this.symbolizers[a].symbol),
                        this.symbolizers[a].symbolize.apply(this.symbolizers[a], s)
                }
                i && (this._renderPoints = i),
                    this._sprite = {
                        canvas: t,
                        offset: n.getCenter()
                    }
            }
            return this._spriting = !1,
                this._sprite
        }
        ,
        e.isSpriting = function() {
            return !!this._spriting
        }
        ,
        e.hitTest = function(t, e) {
            (!e || e < .5) && (e = .5),
                ar = ar || O.createCanvas(1, 1),
                O.setHitTesting(!0),
                ar.width = ar.height = 2 * e;
            var i = ar.getContext("2d");
            this._hitPoint = t.sub(e, e);
            try {
                this.paint(null, i, this._hitPoint)
            } catch (t) {
                throw t
            } finally {
                O.setHitTesting(!1)
            }
            delete this._hitPoint;
            for (var n = i.getImageData(0, 0, ar.width, ar.height).data, r = 3, o = n.length; r < o; r += 4)
                if (0 < n[r])
                    return !0;
            return !1
        }
        ,
        e.isHitTesting = function() {
            return !!this._hitPoint
        }
        ,
        e._prepareShadow = function(t, e) {
            e.shadowBlur ? (t.shadowBlur = this.isHitTesting() ? 0 : e.shadowBlur,
                t.shadowColor = e.shadowColor || "#000",
                t.shadowOffsetX = e.shadowOffsetX || 0,
                t.shadowOffsetY = e.shadowOffsetY || 0) : t.shadowBlur && (t.shadowBlur = null,
                t.shadowColor = null,
                t.shadowOffsetX = null,
                t.shadowOffsetY = null)
        }
        ,
        e._eachSymbolizer = function(t, e) {
            if (this.symbolizers) {
                e = e || this;
                for (var i = this.symbolizers.length - 1; 0 <= i; i--)
                    t.apply(e, [this.symbolizers[i]])
            }
        }
        ,
        e.get2DExtent = function(t, e) {
            this._verifyProjection();
            var i = this.getMap()
                , i = (t = t || this.getLayer()._getRenderer().resources,
                i.getZoom())
                , n = this._isDynamicSize();
            if (this._extent2D && this._extent2D._zoom === i && this._fixedExtent || (this._extent2D && this._extent2D._zoom !== i && delete this._extent2D,
            this.symbolizers && (this._extent2D || (this._extent2D = this._computeExtent2D(new U),
                this._extent2D._zoom = i),
            this._fixedExtent || (this._fixedExtent = this._computeFixedExtent(t, new U)))),
                !this._extent2D)
                return n && delete this._fixedExtent,
                    null;
            var i = this._fixedExtent
                , t = i.xmin
                , r = i.ymin
                , o = i.xmax
                , i = i.ymax;
            return n && delete this._fixedExtent,
                pr.set(t, -i, o, -r),
                e ? (e.set(this._extent2D.xmin, this._extent2D.ymin, this._extent2D.xmax, this._extent2D.ymax),
                    e._add(pr),
                    e) : this._extent2D.add(pr)
        }
        ,
        e._computeExtent2D = function(t) {
            for (var e = this.symbolizers.length - 1; 0 <= e; e--) {
                var i = this.symbolizers[e];
                t._combine(i.get2DExtent())
            }
            return t
        }
        ,
        e._computeFixedExtent = function(t, e) {
            for (var i = this.symbolizers.length - 1; 0 <= i; i--) {
                var n = this.symbolizers[i];
                n.getFixedExtent && e._combine(n.getFixedExtent(t))
            }
            return e
        }
        ,
        e._isDynamicSize = function() {
            if (this.symbolizers)
                for (var t = this.symbolizers.length - 1; 0 <= t; t--)
                    if (this.symbolizers[t].isDynamicSize())
                        return !0;
            return !1
        }
        ,
        e.getContainerExtent = function(t) {
            if (this._aboveCamera())
                return null;
            this._verifyProjection();
            var e = this.getMap()
                , i = e.getZoom()
                , n = e._glScale
                , r = (this._extent2D && this._extent2D._zoom === i || this.get2DExtent(null, gr),
                this.getMinAltitude())
                , t = this._extent2D.convertTo(function(t) {
                return e._pointToContainerPoint(t, i, r / n, cr)
            }, t)
                , o = this.getMaxAltitude()
                , s = (o !== r && (s = this._extent2D.convertTo(function(t) {
                return e._pointToContainerPoint(t, i, o / n, cr)
            }, gr),
                t._combine(s)),
                this.geometry.getLayer());
            return "LineString" === this.geometry.type && o && s.options.drawAltitude && (s = this._extent2D.convertTo(function(t) {
                return e._pointToContainerPoint(t, i, 0, cr)
            }, gr),
                t._combine(s)),
            t && t._add(this._fixedExtent || this._computeFixedExtent(null, new U)),
            this.geometry.options.smoothness && t._expand(.15 * t.getWidth()),
                t
        }
        ,
        e._aboveCamera = function() {
            var t = this.getMinAltitude()
                , e = this.getMap().getFrustumAltitude();
            return t && e && e < t
        }
        ,
        e.getFixedExtent = function() {
            var t = this.getMap().getZoom();
            return this._isDynamicSize() ? this._computeFixedExtent(null, new U) : (this._extent2D && this._extent2D._zoom === t || this.get2DExtent(null, pr),
                this._fixedExtent)
        }
        ,
        e.setZIndex = function(e) {
            this._eachSymbolizer(function(t) {
                t.setZIndex(e)
            })
        }
        ,
        e.show = function() {
            this._painted ? (this.removeCache(),
                this._eachSymbolizer(function(t) {
                    t.show()
                })) : this.getLayer().isCanvasRender() || this.paint()
        }
        ,
        e.hide = function() {
            this._eachSymbolizer(function(t) {
                t.hide()
            })
        }
        ,
        e.repaint = function() {
            this._altAtGLZoom = this._getGeometryAltitude(),
                this.removeCache();
            var t = this.getLayer();
            !t || (t = t.getRenderer()) && t.setToRedraw() && t.setToRedraw()
        }
        ,
        e.refreshSymbol = function() {
            this.removeCache(),
                this._removeSymbolizers(),
                this.symbolizers = this._createSymbolizers()
        }
        ,
        e.remove = function() {
            this.removeCache(),
                this._removeSymbolizers()
        }
        ,
        e._removeSymbolizers = function() {
            this._eachSymbolizer(function(t) {
                delete t.painter,
                    t.remove()
            }),
                delete this.symbolizers
        }
        ,
        e.removeCache = function() {
            delete this._renderPoints,
                delete this._paintParams,
                delete this._sprite,
                delete this._extent2D,
                delete this._fixedExtent,
                delete this._cachedParams,
                delete this._unsimpledParams,
            this.geometry && delete this.geometry[$n.CACHE_KEY]
        }
        ,
        e.getAltitude = function() {
            return this.geometry.getAltitude() !== this._propAlt && (this._altAtGLZoom = this._getGeometryAltitude()),
            this._altAtGLZoom || 0
        }
        ,
        e.getMinAltitude = function() {
            return this.minAltitude || 0
        }
        ,
        e.getMaxAltitude = function() {
            return this.maxAltitude || 0
        }
        ,
        e._getGeometryAltitude = function() {
            var e = this;
            if (!this.getMap())
                return 0;
            var t = this.geometry.getAltitude();
            if (!(this._propAlt = t))
                return this.minAltitude = this.maxAltitude = 0;
            var i = this.geometry.getCenter();
            return i ? Array.isArray(t) ? (this.minAltitude = Number.MAX_VALUE,
                this.maxAltitude = Number.MIN_VALUE,
                t.map(function(t) {
                    t = e._meterToPoint(i, t);
                    return t < e.minAltitude && (e.minAltitude = t),
                    t > e.maxAltitude && (e.maxAltitude = t),
                        t
                })) : (this.minAltitude = this.maxAltitude = this._meterToPoint(i, t),
                this.minAltitude) : 0
        }
        ,
        e._meterToPoint = function(t, e) {
            var i = this.getMap()
                , n = i.getGLZoom();
            return i.distanceToPoint(e, 0, n, t).x * ht(e)
        }
        ,
        e._verifyProjection = function() {
            var t = this.geometry._getProjection();
            this._projCode && this._projCode !== t.code && this.removeCache(),
                this._projCode = t.code
        }
        ,
        e._beforePaint = function() {
            var t = this.geometry[$n.CACHE_KEY];
            if (t)
                for (var e in t)
                    J(t, e) && (t[e].active = !1)
        }
        ,
        e._afterPaint = function() {
            var t = this.geometry[$n.CACHE_KEY];
            if (t)
                for (var e in t)
                    !J(t, e) || t[e].active || delete t[e]
        }
        ,
        yr);
    function yr(t) {
        var e = hr.call(this) || this;
        return e.geometry = t,
            e.symbolizers = e._createSymbolizers(),
            e._altAtGLZoom = e._getGeometryAltitude(),
            e
    }
    var vr, xr = new U, wr = (s(Cr, vr = _e),
        (e = Cr.prototype)._eachPainter = function(t) {
            for (var e, i = this.geometry.getGeometries(), n = 0, r = i.length; n < r && (!(e = this.isMask ? i[n]._getMaskPainter() : i[n]._getPainter()) || !e || !1 !== t.call(this, e)); n++)
                ;
        }
        ,
        e.paint = function(e) {
            this.geometry && this._eachPainter(function(t) {
                t.paint(e)
            })
        }
        ,
        e.get2DExtent = function(e, t) {
            t && t.set(null, null, null, null);
            var i = t || new U;
            return this._eachPainter(function(t) {
                i = i._combine(t.get2DExtent(e, xr))
            }),
                i
        }
        ,
        e.getContainerExtent = function() {
            var e = new U;
            return this._eachPainter(function(t) {
                e = e.combine(t.getContainerExtent())
            }),
                e
        }
        ,
        e.remove = function() {
            var e = arguments;
            this._eachPainter(function(t) {
                t.remove.apply(t, e)
            })
        }
        ,
        e.setZIndex = function() {
            var e = arguments;
            this._eachPainter(function(t) {
                t.setZIndex.apply(t, e)
            })
        }
        ,
        e.show = function() {
            var e = arguments;
            this._eachPainter(function(t) {
                t.show.apply(t, e)
            })
        }
        ,
        e.hide = function() {
            var e = arguments;
            this._eachPainter(function(t) {
                t.hide.apply(t, e)
            })
        }
        ,
        e.repaint = function() {
            var e = arguments;
            this._eachPainter(function(t) {
                t.repaint.apply(t, e)
            })
        }
        ,
        e.refreshSymbol = function() {
            var e = arguments;
            this._eachPainter(function(t) {
                t.refreshSymbol.apply(t, e)
            })
        }
        ,
        e.hasPoint = function() {
            var e = !1;
            return this._eachPainter(function(t) {
                return !t.hasPoint() || !(e = !0)
            }),
                e
        }
        ,
        e.getMinAltitude = function() {
            var e = !0
                , i = 0;
            return this._eachPainter(function(t) {
                t = t.getMinAltitude();
                (e || t < i) && (e = !1,
                    i = t)
            }),
                i
        }
        ,
        e.getMaxAltitude = function() {
            var e = 0;
            return this._eachPainter(function(t) {
                t = t.getMaxAltitude();
                e < t && (e = t)
            }),
                e
        }
        ,
        Cr);
    function Cr(t, e) {
        var i = vr.call(this) || this;
        return i.geometry = t,
            i.isMask = e,
            i
    }
    var Pr = {
        "EPSG:3857": {
            resolutions: function() {
                for (var t = [], e = 12756274 * Math.PI, i = 0; i < 21; i++)
                    t[i] = e / (256 * Math.pow(2, i));
                return t
            }(),
            fullExtent: {
                top: 6378137 * Math.PI,
                left: -6378137 * Math.PI,
                bottom: -6378137 * Math.PI,
                right: 6378137 * Math.PI
            }
        },
        "EPSG:4326": {
            fullExtent: {
                top: 90,
                left: -180,
                bottom: -90,
                right: 180
            },
            resolutions: function() {
                for (var t = [], e = 0; e < 20; e++)
                    t[e] = 180 / (128 * Math.pow(2, e));
                return t
            }()
        },
        BAIDU: {
            resolutions: function() {
                for (var t = Math.pow(2, 18), e = [], i = 0; i < 20; i++)
                    e[i] = t,
                        t *= .5;
                return e
            }(),
            fullExtent: {
                top: 33554432,
                left: -33554432,
                bottom: -33554432,
                right: 33554432
            }
        },
        IDENTITY: {
            resolutions: function() {
                for (var t = Math.pow(2, 8), e = [], i = 0; i < 18; i++)
                    e[i] = t,
                        t *= .5;
                return e
            }(),
            fullExtent: {
                top: 2e5,
                left: -2e5,
                bottom: -2e5,
                right: 2e5
            }
        }
    }
        , br = (Pr["EPSG:4490"] = Pr["EPSG:4326"],
        Mr.getProjectionInstance = function(t) {
            if (!t)
                return null;
            if (W(t))
                return t;
            for (var e in t = (t + "").toLowerCase(),
                yn)
                if (J(yn, e)) {
                    var i = yn[e].code;
                    if (i && i.toLowerCase() === t)
                        return yn[e]
                }
            return null
        }
        ,
        Mr.equals = function(t, e) {
            if (!t && !e)
                return !0;
            if (!t || !e)
                return !1;
            if (t.projection !== e.projection)
                return !1;
            var i = t.fullExtent
                , n = e.fullExtent;
            if (i && !n || !i && n)
                return !1;
            if (i && n && (i.top !== n.top || i.bottom !== n.bottom || i.left !== n.left || i.right !== n.right))
                return !1;
            var r = t.resolutions
                , o = e.resolutions;
            if (r && o) {
                if (r.length !== o.length)
                    return !1;
                for (var s = 0; s < r.length; s++)
                    if (r[s] !== o[s])
                        return !1
            }
            return !0
        }
        ,
        (e = Mr.prototype)._initSpatialRef = function() {
            var t = this.options.projection;
            if (!(t = t ? Mr.getProjectionInstance(t) : _n))
                throw new Error("must provide a valid projection in map's spatial reference.");
            (t = m({}, hn, t)).measureLength || m(t, mn.DEFAULT),
                this._projection = t;
            var e = this.options.resolutions;
            if (!e && (t.code && (i = Pr[t.code]) && (e = i.resolutions,
                this.isEPSG = "IDENTITY" !== t.code),
                !e))
                throw new Error("must provide valid resolutions in map's spatial reference.");
            this._resolutions = e;
            e = this.options.fullExtent;
            if (!e && !(e = t.code && (i = Pr[t.code]) ? i.fullExtent : e))
                throw new Error("must provide a valid fullExtent in map's spatial reference.");
            if (V(e.left) ? (this._fullExtent = new g(e),
                e.left = e.xmin,
                e.right = e.xmax,
                e.top = e.ymax,
                e.bottom = e.ymin) : this._fullExtent = new g(new M(e.left,e.top),new M(e.right,e.bottom)),
            V(e.top) || V(e.bottom) || V(e.left) || V(e.right))
                throw new Error("must provide valid top/bottom/left/right in fullExtent.");
            m(this._fullExtent, e);
            var t = (this._projection.fullExtent = e).right >= e.left ? 1 : -1
                , i = e.top >= e.bottom ? -1 : 1;
            this._transformation = new on([t, i, 0, 0])
        }
        ,
        e.getResolutions = function() {
            return this._resolutions || []
        }
        ,
        e.getResolution = function(t) {
            var e = 0 | t
                , i = (e < 0 ? e = 0 : e > this._resolutions.length - 1 && (e = this._resolutions.length - 1),
                this._resolutions[e]);
            return e !== t && 0 < t && e < this._resolutions.length - 1 ? i + (this._resolutions[e + 1] - i) * (t - e) : i
        }
        ,
        e.getProjection = function() {
            return this._projection
        }
        ,
        e.getFullExtent = function() {
            return this._fullExtent
        }
        ,
        e.getTransformation = function() {
            return this._transformation
        }
        ,
        e.getMinZoom = function() {
            for (var t = 0; t < this._resolutions.length; t++)
                if (!V(this._resolutions[t]))
                    return t;
            return 0
        }
        ,
        e.getMaxZoom = function() {
            for (var t = this._resolutions.length - 1; 0 <= t; t--)
                if (!V(this._resolutions[t]))
                    return t;
            return this._resolutions.length - 1
        }
        ,
        e.getZoomDirection = function() {
            return ht(this._resolutions[this.getMinZoom()] - this._resolutions[this.getMaxZoom()])
        }
        ,
        e.toJSON = function() {
            return this.json || (this.json = {
                resolutions: this._resolutions,
                fullExtent: {
                    top: this._fullExtent.top,
                    left: this._fullExtent.left,
                    bottom: this._fullExtent.bottom,
                    right: this._fullExtent.right
                },
                projection: this._projection.code
            }),
                this.json
        }
        ,
        Mr);
    function Mr(t) {
        this.options = t = void 0 === t ? {} : t,
            this._initSpatialRef()
    }
    s(Tr, Sr = Ai(Si(Oi(_e)))),
        (e = Tr.prototype).getFirstCoordinate = function() {
            var t;
            if ("GeometryCollection" === this.type)
                return (t = this.getGeometries()).length ? t[0].getFirstCoordinate() : null;
            var e = this.getCoordinates();
            if (!Array.isArray(e))
                return e;
            for (; e = e[0],
                   Array.isArray(e) && 0 < e.length; )
                ;
            return e
        }
        ,
        e.getLastCoordinate = function() {
            var t;
            if ("GeometryCollection" === this.type)
                return (t = this.getGeometries()).length ? t[t.length - 1].getLastCoordinate() : null;
            var e = this.getCoordinates();
            if (!Array.isArray(e))
                return e;
            for (; e = e[e.length - 1],
                   Array.isArray(e) && 0 < e.length; )
                ;
            return e
        }
        ,
        e.addTo = function(t, e) {
            return t.addGeometry(this, e),
                this
        }
        ,
        e.getLayer = function() {
            return this._layer || null
        }
        ,
        e.getMap = function() {
            return this._layer ? this._layer.getMap() : null
        }
        ,
        e.getId = function() {
            return this._id
        }
        ,
        e.setId = function(t) {
            var e = this.getId();
            return this._id = t,
                this._fireEvent("idchange", {
                    old: e,
                    new: t
                }),
                this
        }
        ,
        e.getProperties = function() {
            return this.properties || (this._getParent() ? this._getParent().getProperties() : null)
        }
        ,
        e.setProperties = function(t) {
            var e = this.properties;
            return this.properties = W(t) ? m({}, t) : t,
                this._repaint(),
                this._fireEvent("propertieschange", {
                    old: e,
                    new: t
                }),
                this
        }
        ,
        e.getType = function() {
            return this.type
        }
        ,
        e.getSymbol = function() {
            var t = this._symbol;
            return t ? Array.isArray(t) ? re(t) : m({}, t) : null
        }
        ,
        e.setSymbol = function(t) {
            return this._symbol = this._prepareSymbol(t),
                this.onSymbolChanged(),
                this
        }
        ,
        e.updateSymbol = function(t) {
            if (!t)
                return this;
            var e = re((e = this._getSymbol()) || this._getInternalSymbol(), t);
            return this._eventSymbolProperties = t,
                this.setSymbol(e)
        }
        ,
        e.getCenter = function() {
            return this._computeCenter(this._getMeasurer())
        }
        ,
        e.getExtent = function() {
            var t, e = this._getPrjExtent(), i = this._getProjection();
            return e && i ? (t = i.unproject(new M(e.xmin,e.ymin)),
                e = i.unproject(new M(e.xmax,e.ymax)),
                new g(t,e,i)) : this._computeExtent(this._getMeasurer())
        }
        ,
        e.getContainerExtent = function(t) {
            var e = this._getPainter();
            return e ? e.getContainerExtent(t) : null
        }
        ,
        e.getSize = function() {
            var t = this.getContainerExtent();
            return t ? t.getSize() : null
        }
        ,
        e.containsPoint = function(t, e) {
            if (this.getMap())
                return t instanceof M && (t = this.getMap().coordToContainerPoint(t)),
                    this._containsPoint(t, e);
            throw new Error('The geometry is required to be added on a map to perform "containsPoint".')
        }
        ,
        e._containsPoint = function(t, e) {
            var i = this._getPainter();
            return !!i && (V(e) && this._hitTestTolerance && (e = this._hitTestTolerance()),
                i.hitTest(t, e))
        }
        ,
        e.show = function() {
            var t;
            return this.options.visible = !0,
            this.getMap() && ((t = this._getPainter()) && t.show(),
                this._fireEvent("show")),
                this
        }
        ,
        e.hide = function() {
            var t;
            return this.options.visible = !1,
            this.getMap() && (this.onHide(),
            (t = this._getPainter()) && t.hide(),
                this._fireEvent("hide")),
                this
        }
        ,
        e.isVisible = function() {
            if (!this.options.visible)
                return !1;
            var t = this._getInternalSymbol();
            if (!t)
                return !0;
            if (Array.isArray(t)) {
                if (!t.length)
                    return !0;
                for (var e = 0, i = t.length; e < i; e++)
                    if (V(t[e].opacity) || 0 < t[e].opacity)
                        return !0;
                return !1
            }
            return V(t.opacity) || P(t.opacity) && 0 < t.opacity
        }
        ,
        e.getZIndex = function() {
            return this.options.zIndex || 0
        }
        ,
        e.setZIndex = function(t) {
            var e = this.options.zIndex;
            return this.options.zIndex = t,
                this._fireEvent("zindexchange", {
                    old: e,
                    new: t
                }),
                this
        }
        ,
        e.setZIndexSilently = function(t) {
            return this.options.zIndex = t,
                this
        }
        ,
        e.bringToFront = function() {
            var t = this.getLayer();
            if (!t || !t.getGeoMaxZIndex)
                return this;
            t = t.getGeoMaxZIndex();
            return this.setZIndex(t + 1),
                this
        }
        ,
        e.bringToBack = function() {
            var t = this.getLayer();
            if (!t || !t.getGeoMinZIndex)
                return this;
            t = t.getGeoMinZIndex();
            return this.setZIndex(t - 1),
                this
        }
        ,
        e.translate = function(t, e) {
            if (V(t))
                return this;
            var i = new M(t,e);
            if (0 === i.x && 0 === i.y)
                return this;
            t = this.getCoordinates();
            return t && (Array.isArray(t) ? (e = at(t, function(t) {
                return t.add(i)
            }),
                this.setCoordinates(e)) : this.setCoordinates(t.add(i))),
                this
        }
        ,
        e.flash = function(t, e, i, n) {
            return bt.call(this, t, e, i, n)
        }
        ,
        e.copy = function() {
            var t = this.toJSON()
                , t = Tr.fromJSON(t);
            return t.options.visible = !0,
                t
        }
        ,
        e.remove = function() {
            return this.getLayer() && (this._fireEvent("removestart"),
                this._unbind(),
                this._fireEvent("removeend"),
                this._fireEvent("remove")),
                this
        }
        ,
        e.toGeoJSONGeometry = function() {
            return this._exportGeoJSONGeometry()
        }
        ,
        e.toGeoJSON = function(t) {
            var e, i = {
                type: "Feature",
                geometry: null
            }, n = ((V((t = t || {}).geometry) || t.geometry) && (n = this._exportGeoJSONGeometry(),
                i.geometry = n),
                this.getId());
            return V(n) || (i.id = n),
            (V(t.properties) || t.properties) && (e = this._exportProperties()),
                i.properties = e,
                i
        }
        ,
        e.toJSON = function(t) {
            var e = this._toJSON(t = t || {});
            return m(e, this._exportGraphicOptions(t)),
                e
        }
        ,
        e.getLength = function() {
            return this._computeGeodesicLength(this._getMeasurer())
        }
        ,
        e.getArea = function() {
            return this._computeGeodesicArea(this._getMeasurer())
        }
        ,
        e.rotate = function(e, i) {
            if ("GeometryCollection" === this.type)
                return this.getGeometries().forEach(function(t) {
                    return t.rotate(e, i)
                }),
                    this;
            i = i ? new M(i) : this.getCenter();
            var n = this._getMeasurer()
                , t = this.getCoordinates();
            return Array.isArray(t) ? (at(t, function(t) {
                return n._rotate(t, i, e)
            }),
                this.setCoordinates(t)) : i.x === t.x && i.y === t.y || (t = n._rotate(t, i, e),
                this.setCoordinates(t)),
                this
        }
        ,
        e._getConnectPoints = function() {
            return [this.getCenter()]
        }
        ,
        e._initOptions = function(t) {
            var t = m({}, t)
                , e = t.symbol
                , i = t.properties
                , n = t.id;
            delete t.symbol,
                delete t.id,
                delete t.properties,
                this.setOptions(t),
            e && this.setSymbol(e),
            i && this.setProperties(i),
            V(n) || this.setId(n)
        }
        ,
        e._bindLayer = function(t) {
            if (this.getLayer())
                throw new Error("Geometry cannot be added to two or more layers at the same time.");
            this._layer = t,
                this._clearCache()
        }
        ,
        e._prepareSymbol = function(t) {
            if (Array.isArray(t)) {
                for (var e = [], i = 0; i < t.length; i++)
                    e.push($t(this._checkAndCopySymbol(t[i])));
                return e
            }
            return t ? $t(t = this._checkAndCopySymbol(t)) : null
        }
        ,
        e._checkAndCopySymbol = function(t) {
            var e, i = {};
            for (e in t)
                H[e] && b(t[e]) ? i[e] = +t[e] : i[e] = t[e];
            return i
        }
        ,
        e._getSymbol = function() {
            return this._symbol
        }
        ,
        e._setExternSymbol = function(t) {
            return this._eventSymbolProperties = t,
                this._externSymbol = this._prepareSymbol(t),
                this.onSymbolChanged(),
                this
        }
        ,
        e._getInternalSymbol = function() {
            return this._symbol || this._externSymbol || this.options.symbol || null
        }
        ,
        e._getPrjExtent = function() {
            var t = this._getProjection();
            return this._verifyProjection(),
            !this._extent && t && (this._extent = this._computePrjExtent(t)),
                this._extent
        }
        ,
        e._unbind = function() {
            var t = this.getLayer();
            t && (this._animPlayer && this._animPlayer.finish(),
                this._clearHandlers(),
                this._unbindMenu(),
                this._unbindInfoWindow(),
            this.isEditing() && this.endEdit(),
                this._removePainter(),
            this.onRemove && this.onRemove(),
            t.onRemoveGeometry && t.onRemoveGeometry(this),
                delete this._layer,
                delete this._internalId,
                delete this._extent)
        }
        ,
        e._getInternalId = function() {
            return this._internalId
        }
        ,
        e._setInternalId = function(t) {
            this._internalId = t
        }
        ,
        e._getMeasurer = function() {
            return this._getProjection() ? this._getProjection() : br.getProjectionInstance(this.options.defaultProjection)
        }
        ,
        e._getProjection = function() {
            var t = this.getMap();
            return t ? t.getProjection() : null
        }
        ,
        e._verifyProjection = function() {
            var t = this._getProjection();
            this._projCode && t && this._projCode !== t.code && this._clearProjection(),
                this._projCode = t ? t.code : this._projCode
        }
        ,
        e._getExternalResources = function() {
            return Qt(this._getInternalSymbol())
        }
        ,
        e._getPainter = function() {
            var t, e = this.getLayer();
            return !this._painter && e && (-1 !== I.indexOf(this.type) ? e.constructor.getCollectionPainterClass && (t = e.constructor.getCollectionPainterClass(),
                this._painter = new t(this)) : e.constructor.getPainterClass && (t = e.constructor.getPainterClass(),
                this._painter = new t(this))),
                this._painter
        }
        ,
        e._getMaskPainter = function() {
            return this._maskPainter || (this._maskPainter = this.getGeometries && this.getGeometries() ? new wr(this,!0) : new _r(this),
                this._maskPainter)
        }
        ,
        e._removePainter = function() {
            this._painter && this._painter.remove(),
                delete this._painter
        }
        ,
        e._paint = function(t) {
            this._painter && this._painter.paint(t)
        }
        ,
        e._clearCache = function() {
            delete this._extent
        }
        ,
        e._clearProjection = function() {
            delete this._extent
        }
        ,
        e._repaint = function() {
            this._painter && this._painter.repaint()
        }
        ,
        e.onHide = function() {
            this.closeMenu(),
                this.closeInfoWindow()
        }
        ,
        e.onShapeChanged = function() {
            this._clearCache(),
                this._repaint(),
                this._fireEvent("shapechange")
        }
        ,
        e.onPositionChanged = function() {
            this._clearCache(),
                this._repaint(),
                this._fireEvent("positionchange")
        }
        ,
        e.onSymbolChanged = function() {
            this._painter && this._painter.refreshSymbol();
            var t = {};
            this._eventSymbolProperties && (t.properties = m({}, this._eventSymbolProperties),
                delete this._eventSymbolProperties),
                this._fireEvent("symbolchange", t)
        }
        ,
        e.onConfig = function(t) {
            t.properties && (e = t.properties,
                delete t.properties);
            var e, i, n = !1;
            for (i in t)
                if (t.hasOwnProperty(i)) {
                    var r = i.slice(0, 5);
                    if ("arrow" === r || "smoot" === r) {
                        n = !0;
                        break
                    }
                }
            e ? (this.setProperties(e),
                this._repaint()) : n && this._repaint()
        }
        ,
        e._setParent = function(t) {
            t && (this._parent = t)
        }
        ,
        e._getParent = function() {
            return this._parent
        }
        ,
        e._fireEvent = function(t, e) {
            this.getLayer() && this.getLayer()._onGeometryEvent && ((e = e || {}).type = t,
                (e.target = this).getLayer()._onGeometryEvent(e)),
                this.fire(t, e)
        }
        ,
        e._toJSON = function(t) {
            return {
                feature: this.toGeoJSON(t)
            }
        }
        ,
        e._exportGraphicOptions = function(t) {
            var e = {};
            return (V(t.options) || t.options) && (e.options = this.config()),
            (V(t.symbol) || t.symbol) && (e.symbol = this.getSymbol()),
            (V(t.infoWindow) || t.infoWindow) && this._infoWinOptions && (e.infoWindow = this._infoWinOptions),
                e
        }
        ,
        e._exportGeoJSONGeometry = function() {
            var t = this.getCoordinates()
                , t = M.toNumberArrays(t);
            return {
                type: this.getType(),
                coordinates: t
            }
        }
        ,
        e._exportProperties = function() {
            var t = null
                , e = this.getProperties();
            return t = V(e) ? t : W(e) ? m({}, e) : e
        }
        ,
        e.getAltitude = function() {
            var t = this.getLayer();
            if (!t)
                return 0;
            var e = t.options
                , i = this.getProperties()
                , i = e.enableAltitude && i ? i[e.altitudeProperty] : 0
                , n = t.getAltitude ? t.getAltitude() : 0;
            return Array.isArray(i) ? i.map(function(t) {
                return t + n
            }) : i + n
        }
    ;
    var Sr, y = Tr;
    function Tr(t) {
        var t = m({}, t)
            , e = t.symbol
            , i = t.properties
            , n = t.id;
        return delete t.symbol,
            delete t.id,
            delete t.properties,
            t = Sr.call(this, t) || this,
        e && t.setSymbol(e),
        i && t.setProperties(i),
        V(n) || t.setId(n),
            t
    }
    y.mergeOptions({
        id: null,
        visible: !0,
        interactive: !0,
        editable: !0,
        cursor: null,
        defaultProjection: "EPSG:4326"
    });
    var Er, e = {
        attribution: null,
        minZoom: null,
        maxZoom: null,
        visible: !0,
        opacity: 1,
        globalCompositeOperation: null,
        renderer: "canvas",
        debugOutline: "#0f0",
        cssFilter: null,
        forceRenderOnMoving: !1,
        forceRenderOnZooming: !1,
        forceRenderOnRotating: !1,
        hitDetect: !c.mobile
    }, kr = (s(Rr, Er = Ai(Si(pn(_e)))),
        (a = Rr.prototype).load = function() {
            return this.getMap() && this.onLoad() && (this._initRenderer(),
            V(t = this.getZIndex()) || (this._renderer.setZIndex(t),
            this.isCanvasRender() || this._renderer.render()),
                this.onLoadEnd()),
                this;
            var t
        }
        ,
        a.getId = function() {
            return this._id
        }
        ,
        a.setId = function(t) {
            var e = this._id;
            return V(t) || (t += ""),
                this._id = t,
                this.fire("idchange", {
                    old: e,
                    new: t
                }),
                this
        }
        ,
        a.addTo = function(t) {
            return t.addLayer(this),
                this
        }
        ,
        a.setZIndex = function(t) {
            return V(this._zIndex = t) ? delete this.options.zIndex : this.options.zIndex = t,
            this.map && this.map._sortLayersByZIndex(),
            this._renderer && this._renderer.setZIndex(t),
                this
        }
        ,
        a.getZIndex = function() {
            return this._zIndex || 0
        }
        ,
        a.getMinZoom = function() {
            var t = this.getMap()
                , e = this.options.minZoom;
            return t ? Math.max(t.getMinZoom(), e || 0) : e
        }
        ,
        a.getMaxZoom = function() {
            var t = this.getMap()
                , e = this.options.maxZoom;
            return t ? Math.min(t.getMaxZoom(), V(e) ? 1 / 0 : e) : e
        }
        ,
        a.getOpacity = function() {
            return this.options.opacity
        }
        ,
        a.setOpacity = function(t) {
            return this.config("opacity", t),
                this
        }
        ,
        a.isCanvasRender = function() {
            var t = this._getRenderer();
            return t && t instanceof vn
        }
        ,
        a.getMap = function() {
            return this.map || null
        }
        ,
        a.getProjection = function() {
            var t = this.getMap();
            return t ? t.getProjection() : null
        }
        ,
        a.bringToFront = function() {
            var t = this._getLayerList();
            if (!t.length)
                return this;
            var e = t[t.length - 1];
            if (1 === t.length || e === this)
                return this;
            t = e.getZIndex();
            return this.setZIndex(t + 1),
                this
        }
        ,
        a.bringToBack = function() {
            var t = this._getLayerList();
            if (!t.length)
                return this;
            var e = t[0];
            if (1 === t.length || e === this)
                return this;
            t = e.getZIndex();
            return this.setZIndex(t - 1),
                this
        }
        ,
        a.show = function() {
            var t, e, i = this;
            return this.options.visible || (this.options.visible = !0,
            (t = this.getRenderer()) && t.show(),
                e = this.getMap(),
                t && e ? e.once("renderend", function() {
                    i.fire("show")
                }) : this.fire("show")),
                this
        }
        ,
        a.hide = function() {
            var t, e, i = this;
            return this.options.visible && (this.options.visible = !1,
            (t = this.getRenderer()) && t.hide(),
                e = this.getMap(),
                t && e ? e.once("renderend", function() {
                    i.fire("hide")
                }) : this.fire("hide")),
                this
        }
        ,
        a.isVisible = function() {
            if (P(this.options.opacity) && this.options.opacity <= 0)
                return !1;
            var t = this.getMap();
            if (t) {
                t = t.getZoom();
                if (!V(this.options.maxZoom) && this.options.maxZoom < t || !V(this.options.minZoom) && this.options.minZoom > t)
                    return !1
            }
            return V(this.options.visible) && (this.options.visible = !0),
                this.options.visible
        }
        ,
        a.remove = function() {
            return this.map && this.map.removeLayer(this),
                this
        }
        ,
        a.getMask = function() {
            return this._mask
        }
        ,
        a.setMask = function(t) {
            if (!("Point" === t.type && t._isVectorMarker() || "Polygon" === t.type || "MultiPolygon" === t.type))
                throw new Error("Mask for a layer must be a marker with vector marker symbol or a Polygon(MultiPolygon).");
            if (t._bindLayer(this),
                "Point" === t.type ? t.updateSymbol({
                    markerLineColor: "rgba(0, 0, 0, 0)",
                    markerFillOpacity: 0
                }) : t.setSymbol({
                    lineColor: "rgba(0, 0, 0, 0)",
                    polygonOpacity: 0
                }),
                this._mask = t,
                this.options.mask = t.toJSON(),
            !this.getMap() || this.getMap().isZooming())
                return this;
            t = this._getRenderer();
            return t && t.setToRedraw && this._getRenderer().setToRedraw(),
                this
        }
        ,
        a.removeMask = function() {
            if (delete this._mask,
                delete this.options.mask,
            !this.getMap() || this.getMap().isZooming())
                return this;
            var t = this._getRenderer();
            return t && t.setToRedraw && this._getRenderer().setToRedraw(),
                this
        }
        ,
        a.onLoad = function() {
            return !0
        }
        ,
        a.onLoadEnd = function() {}
        ,
        a.isLoaded = function() {
            return !!this._loaded
        }
        ,
        a.getRenderer = function() {
            return this._getRenderer()
        }
        ,
        a.onConfig = function(t) {
            (P(t.opacity) || t.cssFilter) && (t = this.getRenderer()) && t.setToRedraw()
        }
        ,
        a.onAdd = function() {}
        ,
        a.onRendererCreate = function() {}
        ,
        a.onCanvasCreate = function() {}
        ,
        a.onRemove = function() {}
        ,
        a._bindMap = function(t, e) {
            t && (this.map = t,
            V(e) || this.setZIndex(e),
                this._switchEvents("on", this),
                this.onAdd(),
                this.fire("add"))
        }
        ,
        a._initRenderer = function() {
            var t = this.options.renderer;
            if (this.constructor.getRendererClass) {
                var e = this.constructor.getRendererClass(t);
                if (!e)
                    throw new Error("Invalid renderer for Layer(" + this.getId() + "):" + t);
                this._renderer = new e(this),
                    (this._renderer.layer = this)._renderer.setZIndex(this.getZIndex()),
                    this._switchEvents("on", this._renderer),
                this._renderer.onAdd && this._renderer.onAdd(),
                    this.onRendererCreate(),
                    this.fire("renderercreate", {
                        renderer: this._renderer
                    })
            }
        }
        ,
        a._doRemove = function() {
            this._loaded = !1,
                this.onRemove(),
                this._switchEvents("off", this),
            this._renderer && (this._switchEvents("off", this._renderer),
                this._renderer.remove(),
                delete this._renderer),
                delete this.map
        }
        ,
        a._switchEvents = function(t, e) {
            e && e.getEvents && this.getMap()[t](e.getEvents(), e)
        }
        ,
        a._getRenderer = function() {
            return this._renderer
        }
        ,
        a._getLayerList = function() {
            return this.map ? this.map._layers : []
        }
        ,
        a._getMask2DExtent = function() {
            if (!this._mask || !this.getMap())
                return null;
            var t = this._mask._getMaskPainter();
            return t ? t.get2DExtent() : null
        }
        ,
        Rr);
    function Rr(t, e) {
        var i, n;
        return e && (n = e.canvas,
            delete e.canvas),
            (i = Er.call(this, e) || this)._canvas = n,
            i.setId(t),
        e && (i.setZIndex(e.zIndex),
        e.mask && i.setMask(y.fromJSON(e.mask))),
            i
    }
    kr.mergeOptions(e);
    var Ar, Lr, Or, Dr, Ir, jr, zr, Zr, Hr, Gr, Fr, Nr, Wr, Br, Vr, Ur, Jr, qr, Yr, Xr, Kr, Qr, $r, to, eo, io, no = kr.prototype.fire, a = {
        maxVisualPitch: 70,
        maxPitch: 80,
        centerCross: !(kr.prototype.fire = function(t, e) {
                return "layerload" === t && (this._loaded = !0),
                this.map && ((e = e || {}).type = t,
                    (e.target = this).map._onLayerEvent(e)),
                    no.apply(this, arguments)
            }
        ),
        zoomInCenter: !1,
        zoomOrigin: null,
        zoomAnimation: !$,
        zoomAnimationDuration: 330,
        panAnimation: !$,
        panAnimationDuration: 600,
        zoomable: !0,
        enableInfoWindow: !0,
        hitDetect: !c.mobile,
        hitDetectLimit: 5,
        fpsOnInteracting: 25,
        layerCanvasLimitOnInteracting: -1,
        maxZoom: null,
        minZoom: null,
        maxExtent: null,
        fixCenterOnResize: !0,
        checkSize: !0,
        checkSizeInterval: 1e3,
        renderer: "canvas",
        cascadePitches: [10, 60]
    }, h = (s(ro, Ar = Oi(Si(pn(_e)))),
        ro.addOnLoadHook = function(t) {
            var e = Array.prototype.slice.call(arguments, 1)
                , i = "function" == typeof t ? t : function() {
                    this[t].apply(this, e)
                }
            ;
            return this.prototype._onLoadHooks = this.prototype._onLoadHooks || [],
                this.prototype._onLoadHooks.push(i),
                this
        }
        ,
        (e = ro.prototype).isLoaded = function() {
            return !!this._loaded
        }
        ,
        e.getContainer = function() {
            return this._containerDOM
        }
        ,
        e.getSpatialReference = function() {
            return this._spatialReference
        }
        ,
        e.setSpatialReference = function(t) {
            var e = this.options.spatialReference;
            return this._loaded && br.equals(e, t) || this._updateSpatialReference(t, e),
                this
        }
        ,
        e._updateSpatialReference = function(t, e) {
            return t = m({}, t),
                this._center = this.getCenter(),
                this.options.spatialReference = t,
                this._spatialReference = new br(t),
            this.options.spatialReference && p(this.options.spatialReference.projection) && (t = this._spatialReference.getProjection(),
                this.options.spatialReference.projection = t.code),
                this._resetMapStatus(),
                this._fireEvent("spatialreferencechange", {
                    old: e,
                    new: m({}, this.options.spatialReference)
                }),
                this
        }
        ,
        e.onConfig = function(t) {
            t = t.spatialReference || t.view;
            return V(t) || this._updateSpatialReference(t, null),
                this
        }
        ,
        e.getProjection = function() {
            return this._spatialReference ? this._spatialReference.getProjection() : null
        }
        ,
        e.getFullExtent = function() {
            return this._spatialReference ? this._spatialReference.getFullExtent() : null
        }
        ,
        e.setCursor = function(t) {
            return delete this._cursor,
                this._trySetCursor(t),
                this._cursor = t,
                this
        }
        ,
        e.resetCursor = function() {
            return this.setCursor(null)
        }
        ,
        e.getCenter = function() {
            return this._loaded && this._prjCenter ? this.getProjection().unproject(this._prjCenter) : this._center
        }
        ,
        e.setCenter = function(t) {
            if (!t)
                return this;
            t = new M(t);
            var e = this.getProjection().project(t);
            return this._verifyExtent(e) && (this._loaded ? (this.onMoveStart(),
                this._setPrjCenter(e),
                this.onMoveEnd(this._parseEventFromCoord(this.getCenter()))) : this._center = t),
                this
        }
        ,
        e.getSize = function() {
            return V(this.width) || V(this.height) ? this._getContainerDomSize() : new Le(this.width,this.height)
        }
        ,
        e.getContainerExtent = function() {
            var t = this.height
                , e = this.getPitch()
                , i = this.options.maxVisualPitch;
            return i && i < e && (t = this._getVisualHeight(i)),
                new U(0,this.height - t,this.width,this.height)
        }
        ,
        e._getVisualHeight = function(t) {
            t = t || .01;
            var e = (90 - this.getPitch()) * Math.PI / 180
                , i = this.getFov() * Math.PI / 180
                , n = (t *= Math.PI / 180,
            this.cameraCenterDistance / this.getGLScale())
                , i = Math.tan(i / 2)
                , i = n * i / (1 / Math.tan(t) - i) / Math.sin(t)
                , t = n * (Math.sin(e) * i / (n + Math.cos(e) * i));
            return this.height / 2 + t
        }
        ,
        e.getExtent = function() {
            return this._pointToExtent(this._get2DExtent())
        }
        ,
        e.getProjExtent = function() {
            var t = this._get2DExtent();
            return new g(this._pointToPrj(t.getMin()),this._pointToPrj(t.getMax()))
        }
        ,
        e.getPrjExtent = function() {
            return this.getProjExtent()
        }
        ,
        e.getMaxExtent = function() {
            return this.options.maxExtent ? new g(this.options.maxExtent,this.getProjection()) : null
        }
        ,
        e.setMaxExtent = function(t) {
            var e;
            return t ? (t = new g(t,this.getProjection()),
                this.options.maxExtent = t,
            this._verifyExtent(this._getPrjCenter()) || this._panTo(this._prjMaxExtent().getCenter()),
                e = this.getProjection(),
                this._prjMaxExtent = t.convertTo(function(t) {
                    return e.project(t)
                })) : (delete this.options.maxExtent,
                delete this._prjMaxExtent),
                this
        }
        ,
        e.getZoom = function() {
            return this._zoomLevel
        }
        ,
        e.getZoomForScale = function(t, e, i) {
            var n = this.getZoom();
            if (V(e) && (e = n),
            1 === t && e === n)
                return n;
            n = this._getResolution(e),
                e = this.getZoomFromRes(n / t);
            return i ? e : this.getSpatialReference().getZoomDirection() < 0 ? Math.ceil(e - 1e-6) : Math.floor(e + 1e-6)
        }
        ,
        e.getZoomFromRes = function(t) {
            var e = this._getResolutions()
                , i = this._getResolution(this.getMinZoom())
                , n = this._getResolution(this.getMaxZoom());
            if (i <= n) {
                if (t <= i)
                    return this.getMinZoom();
                if (n <= t)
                    return this.getMaxZoom()
            } else {
                if (i <= t)
                    return this.getMinZoom();
                if (t <= n)
                    return this.getMaxZoom()
            }
            for (var r = e.length, o = 0; o < r - 1; o++)
                if (e[o]) {
                    var s = e[o + 1] - e[o]
                        , a = t - e[o];
                    if (ht(s) === ht(a) && Math.abs(s) >= Math.abs(a))
                        return o + a / s
                }
            return r - 1
        }
        ,
        e.setZoom = function(t, e) {
            return void 0 === e && (e = {
                animation: !0
            }),
            isNaN(t) || V(t) || (t = +t,
                this._loaded && this.options.zoomAnimation && e.animation ? this._zoomAnimation(t) : this._zoom(t)),
                this
        }
        ,
        e.getMaxZoom = function() {
            return V(this.options.maxZoom) ? this.getMaxNativeZoom() : this.options.maxZoom
        }
        ,
        e.setMaxZoom = function(t) {
            var e = this.getMaxNativeZoom();
            return null !== (t = e < t ? e : t) && t < this._zoomLevel && (this.setZoom(t),
                t = +t),
                this.options.maxZoom = t,
                this
        }
        ,
        e.getMinZoom = function() {
            return V(this.options.minZoom) ? this._spatialReference.getMinZoom() : this.options.minZoom
        }
        ,
        e.setMinZoom = function(t) {
            var e;
            return null !== t && (t = (t = +t) < (e = this._spatialReference.getMinZoom()) ? e : t) > this._zoomLevel && this.setZoom(t),
                this.options.minZoom = t,
                this
        }
        ,
        e.getMaxNativeZoom = function() {
            var t = this.getSpatialReference();
            return t ? t.getMaxZoom() : null
        }
        ,
        e.getGLZoom = function() {
            return this.getMaxNativeZoom() / 2
        }
        ,
        e.getGLScale = function(t) {
            return V(t) && (t = this.getZoom()),
            this._getResolution(t) / this._getResolution(this.getGLZoom())
        }
        ,
        e.zoomIn = function() {
            return this.setZoom(this.getZoom() + 1)
        }
        ,
        e.zoomOut = function() {
            return this.setZoom(this.getZoom() - 1)
        }
        ,
        e.isZooming = function() {
            return !!this._zooming
        }
        ,
        e.isInteracting = function() {
            return this.isZooming() || this.isMoving() || this.isRotating()
        }
        ,
        e.setCenterAndZoom = function(t, e) {
            return V(e) || this._zoomLevel === e ? this.setCenter(t) : (this.setCenter(t),
                this.setZoom(e, {
                    animation: !1
                })),
                this
        }
        ,
        e.getFitZoom = function(t, e) {
            var i = this;
            if (!(t && t instanceof g))
                return this._zoomLevel;
            if (t.xmin === t.xmax && t.ymin === t.ymax)
                return this.getMaxZoom();
            var n = this.getSize()
                , t = t.convertTo(function(t) {
                return i.coordToContainerPoint(t)
            })
                , r = t.getWidth()
                , t = t.getHeight()
                , r = n.width / r
                , n = n.height / t
                , t = this.getSpatialReference().getZoomDirection() < 0 ? Math.max(r, n) : Math.min(r, n);
            return this.getZoomForScale(t, null, e)
        }
        ,
        e.getView = function() {
            return {
                center: this.getCenter().toArray(),
                zoom: this.getZoom(),
                pitch: this.getPitch(),
                bearing: this.getBearing()
            }
        }
        ,
        e.setView = function(t) {
            return t && (t.center && this.setCenter(t.center),
            null === t.zoom || isNaN(+t.zoom) || this.setZoom(+t.zoom, {
                animation: !1
            }),
            null === t.pitch || isNaN(+t.pitch) || this.setPitch(+t.pitch),
            null === t.pitch || isNaN(+t.bearing) || this.setBearing(+t.bearing)),
                this
        }
        ,
        e.getResolution = function(t) {
            return this._getResolution(t)
        }
        ,
        e.getScale = function(t) {
            var t = V(t) ? this.getZoom() : t
                , e = this._getResolution(this.getMaxNativeZoom());
            return this._getResolution(t) / e
        }
        ,
        e.fitExtent = function(t, e, i, n) {
            if (void 0 === i && (i = {}),
                !t)
                return this;
            t = new g(t,this.getProjection());
            e = this.getFitZoom(t) + (e || 0),
                t = t.getCenter();
            return void 0 === i.animation || i.animation ? this._animateTo({
                center: t,
                zoom: e
            }, {
                duration: i.duration || this.options.zoomAnimationDuration,
                easing: i.easing || "out"
            }, n) : this.setCenterAndZoom(t, e)
        }
        ,
        e.getBaseLayer = function() {
            return this._baseLayer
        }
        ,
        e.setBaseLayer = function(t) {
            var e = !1;
            return this._baseLayer && (e = !0,
                this._fireEvent("baselayerchangestart"),
                this._baseLayer.remove()),
                t ? ((this._baseLayer = t)._bindMap(this, -1),
                    this._baseLayer.on("layerload", function() {
                        this._fireEvent("baselayerload"),
                        e && (e = !1,
                            this._fireEvent("baselayerchangeend"))
                    }, this),
                this._loaded && this._baseLayer.load()) : (delete this._baseLayer,
                    this._fireEvent("baselayerchangeend")),
                this._fireEvent("setbaselayer"),
                this
        }
        ,
        e.removeBaseLayer = function() {
            return this._baseLayer && (this._baseLayer.remove(),
                delete this._baseLayer,
                this._fireEvent("baselayerremove")),
                this
        }
        ,
        e.getLayers = function(e) {
            return this._getLayers(function(t) {
                return !(t === this._baseLayer || 0 <= t.getId().indexOf(D)) && (!e || e(t))
            })
        }
        ,
        e.getLayer = function(t) {
            if (!t)
                return null;
            var e = this._layerCache ? this._layerCache[t] : null;
            if (e)
                return e;
            e = this.getBaseLayer();
            return e && e.getId() === t ? e : null
        }
        ,
        e.addLayer = function(t) {
            if (!t)
                return this;
            if (!Array.isArray(t))
                return t = Array.prototype.slice.call(arguments, 0),
                    this.addLayer(t);
            this._layerCache || (this._layerCache = {});
            for (var e = this._layers, i = 0, n = t.length; i < n; i++) {
                var r = t[i]
                    , o = r.getId();
                if (V(o))
                    throw new Error("Invalid id for the layer: " + o);
                if (r.getMap() !== this) {
                    if (this._layerCache[o])
                        throw new Error("Duplicate layer id in the map: " + o);
                    (this._layerCache[o] = r)._bindMap(this),
                        e.push(r),
                    this._loaded && r.load()
                }
            }
            return this._sortLayersByZIndex(),
                this._fireEvent("addlayer", {
                    layers: t
                }),
                this
        }
        ,
        e.removeLayer = function(t) {
            if (!t)
                return this;
            if (!Array.isArray(t))
                return this.removeLayer([t]);
            for (var e, i = [], n = 0, r = t.length; n < r; n++) {
                var o, s = t[n];
                (s = s instanceof kr ? s : this.getLayer(s)) && ((o = s.getMap()) && o === this && (i.push(s),
                    this._removeLayer(s, this._layers),
                this._loaded && s._doRemove(),
                    o = s.getId(),
                this._layerCache && delete this._layerCache[o]))
            }
            return 0 < i.length && ((e = this.getRenderer()) && e.setLayerCanvasUpdated(),
                this.once("frameend", function() {
                    i.forEach(function(t) {
                        t.fire("remove")
                    })
                })),
                this._fireEvent("removelayer", {
                    layers: t
                }),
                this
        }
        ,
        e.sortLayers = function(t) {
            if (!t || !Array.isArray(t))
                return this;
            for (var e = [], i = Number.MAX_VALUE, n = 0, r = t.length; n < r; n++) {
                var o = t[n];
                if (!((o = b(t[n]) ? this.getLayer(o) : o)instanceof kr && o.getMap() && o.getMap() === this))
                    throw new Error("It must be a layer added to this map to order.");
                o.getZIndex() < i && (i = o.getZIndex()),
                    e.push(o)
            }
            for (var s = 0, a = e.length; s < a; s++)
                e[s].setZIndex(i + s);
            return this
        }
        ,
        e.toDataURL = function(t) {
            var e = (e = (t = t || {}).mimeType) || "image/png"
                , i = t.save
                , n = this._getRenderer();
            return n && n.toDataURL ? (t = (t = t.fileName) || "export",
                n = n.toDataURL(e),
            i && n && (e = "undefined" != typeof Blob && "undefined" != typeof atob ? (i = vt(n.replace(/^data:image\/(png|jpeg|jpg);base64,/, ""), e),
                URL.createObjectURL(i)) : n,
                (i = document.createElement("a")).download = t,
                i.href = e,
                document.body.appendChild(i),
                i.click(),
                document.body.removeChild(i)),
                n) : null
        }
        ,
        e.coordToPoint = function(t, e, i) {
            return this.coordinateToPoint(t, e, i)
        }
        ,
        e.pointToCoord = function(t, e, i) {
            return this.pointToCoordinate(t, e, i)
        }
        ,
        e.coordToViewPoint = function(t, e, i) {
            return this.coordinateToViewPoint(t, e, i)
        }
        ,
        e.viewPointToCoord = function(t, e) {
            return this.viewPointToCoordinate(t, e)
        }
        ,
        e.coordToContainerPoint = function(t, e, i) {
            return this.coordinateToContainerPoint(t, e, i)
        }
        ,
        e.containerPointToCoord = function(t, e) {
            return this.containerPointToCoordinate(t, e)
        }
        ,
        e.containerPointToViewPoint = function(t, e) {
            return e ? e.set(t.x, t.y) : e = t.copy(),
                e._sub(this.getViewPoint())
        }
        ,
        e.viewPointToContainerPoint = function(t, e) {
            return e ? e.set(t.x, t.y) : e = t.copy(),
                e._add(this.getViewPoint())
        }
        ,
        e.checkSize = function() {
            var t = F() - this._initTime < 1500 && 0 === this.width || 0 === this.height
                , e = this._getContainerDomSize()
                , i = this.height
                , n = this.width;
            if (e.width === n && e.height === i)
                return this;
            var r, o = this.getCenter(), s = (this.options.fixCenterOnResize ? this._updateMapSize(e) : (s = this._getVisualHeight(this.getPitch()),
                s = new R(0,this.height - s),
                s = this._containerPointToPrj(s),
                this._updateMapSize(e),
                r = this._getVisualHeight(this.getPitch()),
                r = new R(0,this.height - r),
                this._setPrjCoordAtContainerPoint(s, r),
                this._mapViewCoord = this._getPrjCenter()),
            0 === e.width || 0 === e.height || 0 === n || 0 === i);
            return (t || s) && (this._eventSilence = !0,
                this.setCenter(o),
                delete this._eventSilence),
                this._fireEvent("resize"),
                this
        }
        ,
        e.locate = function(t, e, i) {
            return this.getProjection()._locate(new M(t), e, i)
        }
        ,
        e.getMainPanel = function() {
            return this._getRenderer().getMainPanel()
        }
        ,
        e.getPanels = function() {
            return this._panels
        }
        ,
        e.remove = function() {
            var e = this;
            if (this.isRemoved())
                return this;
            this._fireEvent("removestart"),
                this._removeDomEvents(),
                this._clearHandlers(),
                this.removeBaseLayer();
            for (var t = this.getLayers(), i = 0; i < t.length; i++)
                t[i].remove();
            return this._getRenderer() && this._getRenderer().remove(),
            this._containerDOM.childNodes && 0 < this._containerDOM.childNodes.length && Array.prototype.slice.call(this._containerDOM.childNodes, 0).filter(function(t) {
                return "maptalks-wrapper" === t.className
            }).forEach(function(t) {
                return e._containerDOM.removeChild(t)
            }),
                delete this._panels,
                delete this._containerDOM,
                delete this.renderer,
                this._fireEvent("removeend"),
                this._clearAllListeners(),
                this
        }
        ,
        e.isRemoved = function() {
            return !this._containerDOM
        }
        ,
        e.isMoving = function() {
            return !!this._moving
        }
        ,
        e.onMoveStart = function(t) {
            var e = this._getPrjCenter();
            this._originCenter && !this._verifyExtent(e) || (this._originCenter = e),
                this._moving = !0,
                this._trySetCursor("move"),
                this._fireEvent("movestart", this._parseEvent(t ? t.domEvent : null, "movestart"))
        }
        ,
        e.onMoving = function(t) {
            this._fireEvent("moving", this._parseEvent(t ? t.domEvent : null, "moving"))
        }
        ,
        e.onMoveEnd = function(t) {
            this._moving = !1,
                this._trySetCursor("default"),
                this._fireEvent("moveend", t && t.domEvent ? this._parseEvent(t.domEvent, "moveend") : t),
            !this._verifyExtent(this._getPrjCenter()) && this._originCenter && (t = this._originCenter,
                this._panTo(t))
        }
        ,
        e.onDragRotateStart = function(t) {
            this._dragRotating = !0,
                this._fireEvent("dragrotatestart", this._parseEvent(t ? t.domEvent : null, "dragrotatestart"))
        }
        ,
        e.onDragRotating = function(t) {
            this._fireEvent("dragrotating", this._parseEvent(t ? t.domEvent : null, "dragrotating"))
        }
        ,
        e.onDragRotateEnd = function(t) {
            this._dragRotating = !1,
                this._fireEvent("dragrotateend", this._parseEvent(t ? t.domEvent : null, "dragrotateend"))
        }
        ,
        e.isDragRotating = function() {
            return !!this._dragRotating
        }
        ,
        e.getRenderer = function() {
            return this._getRenderer()
        }
        ,
        e.getDevicePixelRatio = function() {
            return this.options.devicePixelRatio || c.devicePixelRatio || 1
        }
        ,
        e._initContainer = function(t) {
            if (b(t)) {
                if (this._containerDOM = document.getElementById(t),
                    !this._containerDOM)
                    throw new Error("Invalid container when creating map: '" + t + "'")
            } else
                this._containerDOM = t,
                $ && (this.CanvasClass = this._containerDOM.constructor);
            if (this._containerDOM.childNodes && 0 < this._containerDOM.childNodes.length && "maptalks-wrapper" === this._containerDOM.childNodes[0].className)
                throw new Error("Container is already loaded with another map instance, use map.remove() to clear it.")
        }
        ,
        e._trySetCursor = function(t) {
            return this._cursor || this._priorityCursor || this._setCursorToPanel(t = t || "default"),
                this
        }
        ,
        e._setPriorityCursor = function(t) {
            return t ? (this._priorityCursor = t,
                this._setCursorToPanel(t)) : (t = !1,
            this._priorityCursor && (t = !0),
                delete this._priorityCursor,
            t && this.setCursor(this._cursor)),
                this
        }
        ,
        e._setCursorToPanel = function(t) {
            var e = this.getMainPanel();
            e && e.style && e.style.cursor !== t && (e.style.cursor = t)
        }
        ,
        e._removeLayer = function(t, e) {
            t && e && (-1 < (t = e.indexOf(t)) && e.splice(t, 1))
        }
        ,
        e._sortLayersByZIndex = function() {
            if (this._layers) {
                for (var t = 0, e = this._layers.length; t < e; t++)
                    this._layers[t]._order = t;
                this._layers.sort(function(t, e) {
                    var i = t.getZIndex() - e.getZIndex();
                    return 0 == i ? t._order - e._order : i
                })
            }
        }
        ,
        e._fireEvent = function(t, e) {
            this._eventSilence || (this.fire("_" + t, e),
                this.fire(t, e))
        }
        ,
        e._Load = function() {
            this._resetMapStatus(),
            this.options.pitch && (this.setPitch(this.options.pitch),
                delete this.options.pitch),
            this.options.bearing && (this.setBearing(this.options.bearing),
                delete this.options.bearing),
                this._loadAllLayers(),
                this._getRenderer().onLoad(),
                this._loaded = !0,
                this._callOnLoadHooks(),
                this._initTime = F()
        }
        ,
        e._initRenderer = function() {
            var t = this.options.renderer
                , t = ro.getRendererClass(t);
            this._renderer = new t(this),
                this._renderer.load()
        }
        ,
        e._getRenderer = function() {
            return this._renderer
        }
        ,
        e._loadAllLayers = function() {
            this._baseLayer && this._baseLayer.load(),
                this._eachLayer(function(t) {
                    t && t.load()
                }, this.getLayers())
        }
        ,
        e._getLayers = function(t) {
            for (var e = this._baseLayer ? [this._baseLayer].concat(this._layers) : this._layers, i = [], n = 0; n < e.length; n++)
                t && !t.call(this, e[n]) || i.push(e[n]);
            return i
        }
        ,
        e._eachLayer = function(t) {
            if (!(arguments.length < 2)) {
                for (var e = Array.prototype.slice.call(arguments, 1), i = [], n = 0, r = (e = e && !Array.isArray(e) ? [e] : e).length; n < r; n++)
                    i = i.concat(e[n]);
                for (var o = 0, s = i.length; o < s; o++)
                    t.call(t, i[o])
            }
        }
        ,
        e._onLayerEvent = function(t) {
            t && "idchange" === t.type && (delete this._layerCache[t.old],
                this._layerCache[t.new] = t.target)
        }
        ,
        e._resetMapStatus = function() {
            var t = this.getMaxZoom()
                , e = this.getMinZoom()
                , i = this._spatialReference.getMaxZoom()
                , n = this._spatialReference.getMinZoom()
                , i = ((V(t) || -1 === t || i < t) && this.setMaxZoom(i),
            (V(e) || -1 === e || e < n) && this.setMinZoom(n),
            (t = this.getMaxZoom()) < (e = this.getMinZoom()) && this.setMaxZoom(e),
            (V(this._zoomLevel) || this._zoomLevel > t) && (this._zoomLevel = t),
            this._zoomLevel < e && (this._zoomLevel = e),
                delete this._prjCenter,
                this.getProjection())
                , n = (this._prjCenter = i.project(this._center),
                this._calcMatrices(),
                this._getRenderer());
            n && n.resetContainer()
        }
        ,
        e._getContainerDomSize = function() {
            if (!this._containerDOM)
                return null;
            var t = this._containerDOM;
            if (V(t.width) || V(t.height)) {
                if (V(t.clientWidth) || V(t.clientHeight))
                    throw new Error("can not get size of container");
                e = parseInt(t.clientWidth, 0),
                    i = parseInt(t.clientHeight, 0)
            } else {
                var e = t.width
                    , i = t.height
                    , n = this.getDevicePixelRatio();
                1 !== n && t.layer && (e /= n,
                    i /= n)
            }
            return new Le(e,i)
        }
        ,
        e._updateMapSize = function(t) {
            return this.width = t.width,
                this.height = t.height,
                this._getRenderer().updateMapSize(t),
                this._calcMatrices(),
                this
        }
        ,
        e._getPrjCenter = function() {
            return this._prjCenter
        }
        ,
        e._setPrjCenter = function(t) {
            this._prjCenter = t,
            this.isInteracting() && !this.isMoving() && (this._mapViewCoord = t),
                this._calcMatrices()
        }
        ,
        e._setPrjCoordAtContainerPoint = function(t, e) {
            if (e.x === this.width / 2 && e.y === this.height / 2)
                return this;
            e = this._containerPointToPoint(e)._sub(this._prjToPoint(this._getPrjCenter())),
                t = this._pointToPrj(this._prjToPoint(t).sub(e));
            return this._setPrjCenter(t),
                this
        }
        ,
        e._verifyExtent = function(t) {
            if (!t)
                return !1;
            var e = this._prjMaxExtent;
            return !e || e.contains(t)
        }
        ,
        e._offsetCenterByPixel = function(t) {
            t = new R(this.width / 2 - t.x,this.height / 2 - t.y),
                t = this._containerPointToPrj(t);
            return this._setPrjCenter(t),
                t
        }
        ,
        e.offsetPlatform = function(t) {
            return t ? (this._getRenderer().offsetPlatform(t),
                this._mapViewCoord = this._getPrjCenter(),
                this._mapViewPoint = this._mapViewPoint.add(t),
                this) : this._mapViewPoint
        }
        ,
        e.getViewPoint = function() {
            var t = this._getViewPointFrameOffset()
                , e = this.offsetPlatform();
            return e = t ? e.add(t) : e
        }
        ,
        e._resetMapViewPoint = function() {
            this._mapViewPoint = new R(0,0),
                this._mapViewCoord = this._getPrjCenter()
        }
        ,
        e._getResolution = function(t) {
            return void 0 !== t && t !== this._zoomLevel || void 0 === this._mapRes ? t === this.getGLZoom() && void 0 !== this._mapGlRes ? this._mapGlRes : (V(t) && (t = this._zoomLevel),
                this._spatialReference.getResolution(t)) : this._mapRes
        }
        ,
        e._getResolutions = function() {
            return this._spatialReference.getResolutions()
        }
        ,
        e._prjToPoint = function(t, e, i) {
            return e = V(e) ? this.getZoom() : e,
                this._spatialReference.getTransformation().transform(t, this._getResolution(e), i)
        }
        ,
        e._pointToPrj = function(t, e, i) {
            return e = V(e) ? this.getZoom() : e,
                this._spatialReference.getTransformation().untransform(t, this._getResolution(e), i)
        }
        ,
        e._pointToPoint = function(t, e, i) {
            return i ? (i.x = t.x,
                i.y = t.y) : i = t.copy(),
                V(e) ? i : i._multi(this._getResolution(e) / this._getResolution())
        }
        ,
        e._pointToPointAtZoom = function(t, e, i) {
            return i ? (i.x = t.x,
                i.y = t.y) : i = t.copy(),
                V(e) ? i : i._multi(this._getResolution() / this._getResolution(e))
        }
        ,
        e._containerPointToPrj = function(t, e) {
            return this._pointToPrj(this._containerPointToPoint(t, void 0, e), void 0, e)
        }
        ,
        e._callOnLoadHooks = function() {
            var t = ro.prototype;
            if (t._onLoadHooks)
                for (var e = 0, i = t._onLoadHooks.length; e < i; e++)
                    t._onLoadHooks[e].call(this)
        }
        ,
        ro);
    function ro(t, e) {
        var i;
        if (!e)
            throw new Error("Invalid options when creating map.");
        if (!e.center)
            throw new Error("Invalid center when creating map.");
        var e = m({}, e)
            , n = e.zoom
            , r = (delete e.zoom,
            new M(e.center))
            , o = (delete e.center,
            e.baseLayer)
            , s = (delete e.baseLayer,
            e.layers);
        return delete e.layers,
            (i = Ar.call(this, e) || this).VERSION = ro.VERSION,
            Object.defineProperty(Ee(i), "id", {
                value: it++,
                writable: !1
            }),
            i._loaded = !1,
            i._initContainer(t),
            i._panels = {},
            i._baseLayer = null,
            i._layers = [],
            i._zoomLevel = n,
            i._center = r,
            i.setSpatialReference(e.spatialReference || e.view),
            i.setMaxExtent(e.maxExtent),
            i._mapViewPoint = new R(0,0),
            i._initRenderer(),
            i._updateMapSize(i._getContainerDomSize()),
        o && i.setBaseLayer(o),
        s && i.addLayer(s),
            i._Load(),
            i
    }
    h.include({
        coordinateToPoint: (io = new M(0,0),
                function(t, e, i) {
                    t = this.getProjection().project(t, io);
                    return this._prjToPoint(t, e, i)
                }
        ),
        pointToCoordinate: (eo = new M(0,0),
                function(t, e, i) {
                    t = this._pointToPrj(t, e, eo);
                    return this.getProjection().unproject(t, i)
                }
        ),
        coordinateToViewPoint: (to = new M(0,0),
                function(t, e, i) {
                    return this._prjToViewPoint(this.getProjection().project(t, to), e, i)
                }
        ),
        viewPointToCoordinate: ($r = new M(0,0),
                function(t, e) {
                    return this.getProjection().unproject(this._viewPointToPrj(t, $r), e)
                }
        ),
        coordinateToContainerPoint: (Qr = new M(0,0),
                function(t, e, i) {
                    t = this.getProjection().project(t, Qr);
                    return this._prjToContainerPoint(t, e, i)
                }
        ),
        containerPointToCoordinate: (Kr = new M(0,0),
                function(t, e) {
                    t = this._containerPointToPrj(t, Kr);
                    return this.getProjection().unproject(t, e)
                }
        ),
        containerToExtent: (Yr = new R(0,0),
                Xr = new R(0,0),
                function(t) {
                    t = new U(this._containerPointToPoint(t.getMin(Yr), void 0, Yr),this._containerPointToPoint(t.getMax(Xr), void 0, Xr));
                    return this._pointToExtent(t)
                }
        ),
        distanceToPixel: (Jr = new R(0,0),
                qr = new R(0,0),
                function(t, e, i) {
                    var n = this.getProjection();
                    if (!n)
                        return null;
                    var i = this.getScale() / this.getScale(i)
                        , r = this.getCenter()
                        , n = n.locate(r, t, e)
                        , t = this.coordToContainerPoint(r, void 0, Jr)
                        , e = this.coordToContainerPoint(n, void 0, qr);
                    return e._sub(t)._multi(i)._abs(),
                        new Le(e.x,e.y)
                }
        ),
        distanceToPoint: (Ur = new R(0,0),
                function(t, e, i, n) {
                    var r = this.getProjection();
                    if (!r)
                        return null;
                    n = n || this.getCenter(),
                        r = r.locate(n, t, e),
                        t = this.coordToPoint(n, i, Ur),
                        e = this.coordToPoint(r, i);
                    return e._sub(t)._abs(),
                        e
                }
        ),
        pixelToDistance: (Br = new M(0,0),
                Vr = new M(0,0),
                function(t, e) {
                    var i = this.getProjection();
                    if (!i)
                        return null;
                    var n = this.getFullExtent()
                        , n = n.top > n.bottom ? -1 : 1
                        , t = Br.set(this.width / 2 + t, this.height / 2 + n * e)
                        , n = this.containerPointToCoord(t, Vr);
                    return i.measureLength(this.getCenter(), n)
                }
        ),
        pointToDistance: (Nr = new R(0,0),
                Wr = new M(0,0),
                function(t, e, i) {
                    var n = this.getProjection();
                    if (!n)
                        return null;
                    var r = this._prjToPoint(this._getPrjCenter(), i, Nr)
                        , t = (r._add(t, e),
                        this.pointToCoord(r, i, Wr));
                    return n.measureLength(this.getCenter(), t)
                }
        ),
        locateByPoint: (Fr = new R(0,0),
                function(t, e, i) {
                    t = this.coordToContainerPoint(t, void 0, Fr);
                    return this.containerPointToCoord(t._add(e, i))
                }
        ),
        _get2DExtent: (Gr = new R(0,0),
                function(e, t) {
                    var i, n = this;
                    return void 0 !== e && e !== this._zoomLevel || !this._mapExtent2D ? e === this.getGLZoom() && this._mapGlExtent2D && (i = this._mapGlExtent2D) : i = this._mapExtent2D,
                        i ? t ? (t.set(i.xmin, i.ymin, i.xmax, i.ymax),
                            t) : i.copy() : this.getContainerExtent().convertTo(function(t) {
                            return n._containerPointToPoint(t, e, Gr)
                        }, t)
                }
        ),
        _pointToExtent: (Zr = new M(0,0),
                Hr = new M(0,0),
                function(t) {
                    var e = t.getMin()
                        , t = t.getMax()
                        , i = this.getFullExtent()
                        , n = !i || i.left <= i.right ? [e.x, t.x] : [t.x, e.x]
                        , r = n[1]
                        , i = !i || i.top > i.bottom ? [t.y, e.y] : [e.y, t.y]
                        , o = i[0]
                        , e = e.set(n[0], i[1])
                        , n = t.set(r, o);
                    return new g(this.pointToCoord(e, void 0, Zr),this.pointToCoord(n, void 0, Hr),this.getProjection())
                }
        ),
        _getViewPointFrameOffset: (zr = new R(0,0),
                function() {
                    if (this.isZooming())
                        return null;
                    var t = this._getPrjCenter();
                    return this._mapViewCoord && !this._mapViewCoord.equals(t) ? this._prjToContainerPoint(this._mapViewCoord)._sub(this._prjToContainerPoint(t, void 0, zr)) : null
                }
        ),
        _viewPointToPrj: (jr = new R(0,0),
                function(t, e) {
                    return this._containerPointToPrj(this.viewPointToContainerPoint(t, jr), e)
                }
        ),
        _prjToContainerPoint: (Ir = new R(0,0),
                function(t, e, i, n) {
                    return this._pointToContainerPoint(this._prjToPoint(t, e, Ir), e, n || 0, i)
                }
        ),
        _prjToViewPoint: (Dr = new R(0,0),
                function(t, e, i) {
                    t = this._prjToContainerPoint(t, void 0, Dr, i);
                    return this.containerPointToViewPoint(t, e)
                }
        ),
        _viewPointToPoint: (Or = new R(0,0),
                function(t, e, i) {
                    return this._containerPointToPoint(this.viewPointToContainerPoint(t, Or), e, i)
                }
        ),
        _pointToViewPoint: (Lr = new M(0,0),
                function(t, e, i) {
                    return this._prjToViewPoint(this._pointToPrj(t, e, Lr), i)
                }
        )
    }),
        h.mergeOptions(a);
    s(so, oo = ki),
        (e = so.prototype).addHooks = function() {
            this.target && this.target.on("_dblclick", this._onDoubleClick, this)
        }
        ,
        e.removeHooks = function() {
            this.target && this.target.off("_dblclick", this._onDoubleClick, this)
        }
        ,
        e._onDoubleClick = function(t) {
            var e, i = this.target;
            i.options.doubleClickZoom && (e = i.getZoom(),
                e = t.domEvent.shiftKey ? Math.ceil(e) - 1 : Math.floor(e) + 1,
                i._zoomAnimation(e, t.containerPoint))
        }
    ;
    var oo, a = so;
    function so() {
        return oo.apply(this, arguments) || this
    }
    h.mergeOptions({
        doubleClickZoom: !0
    }),
        h.addOnLoadHook("addHandler", "doubleClickZoom", a);
    s(ho, ao = ki),
        (e = ho.prototype).addHooks = function() {
            var t = this.target;
            t && (t = t._panels.mapWrapper || t._containerDOM,
                this._dragHandler = new Zi(t,{
                    cancelOn: this._cancelOn.bind(this),
                    rightclick: !0
                }),
                this._dragHandler.on("mousedown", this._onMouseDown, this).on("dragstart", this._onDragStart, this).on("dragging", this._onDragging, this).on("dragend", this._onDragEnd, this).enable())
        }
        ,
        e.removeHooks = function() {
            this._dragHandler.off("mousedown", this._onMouseDown, this).off("dragstart", this._onDragStart, this).off("dragging", this._onDragging, this).off("dragend", this._onDragEnd, this),
                this._dragHandler.remove(),
                delete this._dragHandler
        }
        ,
        e._cancelOn = function(t) {
            return !(!this.target.isZooming() && !this._ignore(t))
        }
        ,
        e._ignore = function(t) {
            return !!t && (t.domEvent && (t = t.domEvent),
                this.target._ignoreEvent(t))
        }
        ,
        e._onMouseDown = function(t) {
            delete this.startDragTime,
                delete this._mode,
                2 === t.domEvent.button || t.domEvent.ctrlKey ? (this.target.options.dragRotate || this.target.options.dragPitch) && (this._mode = "rotatePitch") : this.target.options.dragPan && (this._mode = "move"),
                this.target._stopAnim(this.target._mapAnimPlayer),
                ei(t.domEvent)
        }
        ,
        e._onDragStart = function(t) {
            this.startDragTime = F(),
                "move" === this._mode ? this._moveStart(t) : "rotatePitch" === this._mode && this._rotateStart(t)
        }
        ,
        e._onDragging = function(t) {
            this.target._isEventOutMap(t.domEvent) || ("move" === this._mode ? this._moving(t) : "rotatePitch" === this._mode && this._rotating(t))
        }
        ,
        e._onDragEnd = function(t) {
            "move" === this._mode ? this._moveEnd(t) : "rotatePitch" === this._mode && this._rotateEnd(t),
                delete this.startDragTime,
                delete this.startBearing
        }
        ,
        e._start = function(t) {
            this.preX = t.mousePos.x,
                this.preY = t.mousePos.y,
                this.startX = this.preX,
                this.startY = this.preY
        }
        ,
        e._moveStart = function(t) {
            this._start(t);
            var e = this.target
                , t = (e.onMoveStart(t),
                si(e._getActualEvent(t.domEvent), e.getContainer()));
            this.startPrjCoord = e._containerPointToPrj(t)
        }
        ,
        e._moving = function(t) {
            var e, i;
            this.startDragTime && (i = si((e = this.target)._getActualEvent(t.domEvent), e.getContainer()),
                e._setPrjCoordAtContainerPoint(this.startPrjCoord, i),
                e.onMoving(t))
        }
        ,
        e._moveEnd = function(t) {
            var e, i, n, r;
            this.startDragTime && (e = this.target,
                i = F() - this.startDragTime,
                n = t.mousePos.x,
                r = t.mousePos.y,
                n = n - this.startX,
                r = r - this.startY,
                this._clear(),
                e.options.panAnimation && !t.interupted && e._verifyExtent(e._getPrjCenter()) && i < 280 && 5 < Math.abs(r) + Math.abs(n) ? (i = 5 * i * (Math.abs(n) + Math.abs(r)) / 500,
                    e.panBy(new R(n,r), {
                        duration: i
                    })) : e.onMoveEnd(t))
        }
        ,
        e._rotateStart = function(t) {
            this._start(t),
                delete this._rotateMode,
                this.startBearing = this.target.getBearing(),
                this.target.onDragRotateStart(t),
                this._db = 0
        }
        ,
        e._rotating = function(t) {
            var e, i = this.target, n = t.mousePos.x, r = t.mousePos.y, o = i.getPitch(), s = i.getBearing(), a = Math.abs(n - this.preX), h = Math.abs(r - this.preY);
            this._rotateMode || (i.options.dragRotatePitch ? this._rotateMode = "rotate_pitch" : this._rotateMode = !(h < a) && a < h ? "pitch" : "rotate"),
            "pitch" === this._rotateMode && 0 === o && h < 10 || (0 <= this._rotateMode.indexOf("rotate") && i.options.dragRotate && (e = 0,
                e = i.options.dragPitch || h < a ? -.6 * (this.preX - n) : n > i.width / 2 ? .6 * (this.preY - r) : -.6 * (this.preY - r),
                h = i.getBearing() + e,
                this._db = this._db || 0,
                this._db += e,
                i.setBearing(h)),
            0 <= this._rotateMode.indexOf("pitch") && i.options.dragPitch && i.setPitch(i.getPitch() + .4 * (this.preY - r)),
                this.preX = n,
                this.preY = r,
            i.getBearing() === s && i.getPitch() === o || i.onDragRotating(t))
        }
        ,
        e._rotateEnd = function(t) {
            var e = this.target
                , i = e.getBearing()
                , n = (this._clear(),
            F() - this.startDragTime);
            e.onDragRotateEnd(t),
            20 < Math.abs(i - this.startBearing) && ("rotate" === this._rotateMode || "rotate_pitch" === this._rotateMode) && !t.interupted && n < 400 && (i = e.getBearing(),
                e._animateTo({
                    bearing: i + this._db / 2
                }, {
                    easing: "out",
                    duration: 800
                }))
        }
        ,
        e._clear = function() {
            delete this.startPrjCoord,
                delete this.preX,
                delete this.preY,
                delete this.startX,
                delete this.startY
        }
    ;
    var ao, a = ho;
    function ho() {
        return ao.apply(this, arguments) || this
    }
    h.mergeOptions({
        draggable: !0,
        dragPan: !0,
        dragRotatePitch: !0,
        dragRotate: !0,
        dragPitch: !0
    }),
        h.addOnLoadHook("addHandler", "draggable", a);
    var lo, uo = "mousedown mouseup mousemove click dblclick contextmenu touchstart touchmove touchend", a = (s(co, lo = ki),
        (e = co.prototype).addHooks = function() {
            var t = this.target
                , t = t._panels.allLayers || t._containerDOM;
            _(t, uo, this._identifyGeometryEvents, this)
        }
        ,
        e.removeHooks = function() {
            var t = this.target
                , t = t._panels.allLayers || t._containerDOM;
            mi(t, uo, this._identifyGeometryEvents, this)
        }
        ,
        e._identifyGeometryEvents = function(c, t) {
            var d = this.target;
            if (!d.isInteracting() && !d._ignoreEvent(c)) {
                var e = d._getLayers(function(t) {
                    return !(!t.identify || !t.options.geometryEvents)
                });
                if (e.length) {
                    var g = null
                        , p = t || c.type;
                    if ("mousedown" === p || "touchstart" === p && 1 === c.touches.length)
                        this._mouseDownTime = F();
                    else if (("click" === p || "touchend" === p) && this._mouseDownTime) {
                        t = this._mouseDownTime;
                        if (delete this._mouseDownTime,
                        300 < F() - t) {
                            if ("click" === p)
                                return
                        } else
                            "touchend" === p && (g = "click")
                    }
                    var f, i, n, t = c.touches && 0 < c.touches.length ? c.touches[0] : c.changedTouches && 0 < c.changedTouches.length ? c.changedTouches[0] : c;
                    t && (t = si(t, d._containerDOM),
                        t = d.containerPointToCoordinate(t),
                    "touchstart" === p && ei(c),
                        i = {
                            includeInternals: !(f = null),
                            filter: function(t) {
                                if (!(t instanceof y))
                                    return !1;
                                var e = t._getEventTypeToFire(c);
                                if ("mousemove" === p) {
                                    if (!f && t.options.cursor && (f = t.options.cursor),
                                    !t.listens("mousemove") && !t.listens("mouseover") && !t.listens("mouseenter"))
                                        return !1
                                } else if (!t.listens(e) && !t.listens(g))
                                    return !1;
                                return !0
                            },
                            count: 1,
                            coordinate: t,
                            onlyVisible: d.options.onlyVisibleGeometryEvents,
                            layers: e
                        },
                        n = function(t) {
                            var e = !0;
                            if ("mousemove" === p) {
                                var i = {};
                                if (0 < t.length)
                                    for (var n = t.length - 1; 0 <= n; n--) {
                                        var r, o = t[n];
                                        o instanceof y && (r = o._getInternalId(),
                                            (i[r] = o)._onEvent(c),
                                        this._prevOverGeos && this._prevOverGeos.geomap[r] || o._onEvent(c, "mouseenter"),
                                            e = o._onEvent(c, "mouseover"))
                                    }
                                d._setPriorityCursor(f);
                                var s = this._prevOverGeos && this._prevOverGeos.geos;
                                if (this._prevOverGeos = {
                                    geos: t,
                                    geomap: i
                                },
                                s && 0 < s.length)
                                    for (var a = s.length - 1; 0 <= a; a--) {
                                        var h, l = s[a];
                                        l instanceof y && (h = s[a]._getInternalId(),
                                        i[h] || (e = l._onEvent(c, "mouseout")))
                                    }
                            } else {
                                if (!t || !t.length)
                                    return;
                                for (var u = t.length - 1; 0 <= u; u--)
                                    if (t[u]instanceof y) {
                                        e = t[u]._onEvent(c),
                                        g && t[u]._onEvent(c, g);
                                        break
                                    }
                            }
                            !1 === e && ii(c)
                        }
                            .bind(this),
                        "mousemove" === p || "touchmove" === p ? this._queryIdentifyTimeout = d.getRenderer().callInNextFrame(function() {
                            d.isInteracting() || d.identify(i, n)
                        }) : d.identify(i, n))
                }
            }
        }
        ,
        co);
    function co() {
        return lo.apply(this, arguments) || this
    }
    h.mergeOptions({
        geometryEvents: !0,
        onlyVisibleGeometryEvents: !0
    }),
        h.addOnLoadHook("addHandler", "geometryEvents", a);
    var go, po = 4.000244140625, a = (s(fo, go = ki),
        (e = fo.prototype).addHooks = function() {
            Qe(this.target._containerDOM, "wheel", this._onWheelScroll, this)
        }
        ,
        e.removeHooks = function() {
            $e(this.target._containerDOM, "wheel", this._onWheelScroll)
        }
        ,
        e._onWheelScroll = function(t) {
            ei(t),
                ii(t);
            var e = this.target;
            if (e._ignoreEvent(t) || !e.options.zoomable)
                return !1;
            var i = e._containerDOM
                , i = e._checkZoomOrigin(si(t, i));
            return e.options.seamlessZoom ? (this._zooming || (this._trackPadSuspect = 0,
                this._ensureTrackpad = !1),
                this._seamless(t, i)) : this._interval(t, i)
        }
        ,
        e._seamless = function(t, e) {
            var i = t.deltaMode === window.WheelEvent.DOM_DELTA_LINE ? 60 * t.deltaY : t.deltaY;
            i % po != 0 && (this._ensureTrackpad || (Math.abs(i) < 60 ? this._trackPadSuspect++ : this._trackPadSuspect = 0,
            2 <= this._trackPadSuspect && (this._ensureTrackpad = !0)),
            this._ensureTrackpad && (i *= 14)),
            t.shiftKey && i && (i /= 4),
                this._lastWheelEvent = t,
                this._delta -= i,
            !this._zooming && this._delta && (t = this.target,
                this._zoomOrigin = e,
                t.onZoomStart(null, e)),
                this._start()
        }
        ,
        e._start = function() {
            var t;
            this._delta && (this._zooming = !0,
                t = this.target,
            this._active || (t.getRenderer().callInNextFrame(this._thisScrollZoom),
                this._active = !0))
        }
        ,
        e._scrollZoom = function() {
            var t, e, i, n = this;
            this._active = !1,
            this._delta && (i = Math.abs(this._delta) > po ? this._wheelZoomRate : this._defaultZoomRate,
                i = 2 / (1 + Math.exp(-Math.abs(this._delta * i))),
            this._delta < 0 && 0 !== i && (i = 1 / i),
                e = (t = this.target).getZoom(),
                i = t.getZoomForScale(i, e, !0),
                this._delta = 0,
                t.onZooming(i, this._zoomOrigin),
            this._timeout && clearTimeout(this._timeout),
                this._timeout = setTimeout(function() {
                    n._zooming = !1,
                        delete n._timeout,
                        t.onZoomEnd(t.getZoom(), n._zoomOrigin)
                }, 210))
        }
        ,
        e._interval = function(e, t) {
            var i = this
                , n = this.target;
            if (this._zooming)
                return this._requesting++,
                    !1;
            var r = (this._requesting = 0) < (e.deltaY ? -1 * e.deltaY : e.wheelDelta || e.detail) ? 1 : -1
                , o = (e.detail && (r *= -1),
                n.getZoom())
                , s = o + r;
            if ((s = n._checkZoom(0 < r ? Math.ceil(s) : Math.floor(s))) === o)
                return !1;
            this._zooming = !0,
            this._delta || (n.onZoomStart(null, t),
                this._origin = t,
                this._delta = r,
                this._startZoom = n.getZoom());
            return n._animateTo({
                zoom: s - +this._delta / 2,
                around: this._origin
            }, {
                continueOnViewChanged: !0,
                easing: "linear",
                duration: 90,
                wheelZoom: !0
            }, function(t) {
                "finished" !== t.state.playState ? "running" !== t.state.playState && (delete i._zooming,
                    delete i._requesting) : i._requesting < 1 || 2 < Math.abs(s - i._startZoom) || s === n.getMaxZoom() || s === n.getMinZoom() ? (n._animateTo({
                    zoom: s,
                    around: i._origin
                }, {
                    continueOnViewChanged: !0,
                    duration: 100
                }, function(t) {
                    "running" !== t.state.playState && (delete i._zooming,
                        delete i._requesting)
                }),
                    delete i._startZoom,
                    delete i._origin,
                    delete i._delta,
                    i._requesting = 0) : V(i._requesting) || (delete i._zooming,
                    i._onWheelScroll(e))
            }),
                !1
        }
        ,
        fo);
    function fo(t) {
        t = go.call(this, t) || this;
        return t._thisScrollZoom = t._scrollZoom.bind(Ee(t)),
            t._wheelZoomRate = 1 / 450,
            t._defaultZoomRate = .01,
            t._delta = 0,
            t
    }
    h.mergeOptions({
        scrollWheelZoom: !0,
        seamlessZoom: !1
    }),
        h.addOnLoadHook("addHandler", "scrollWheelZoom", a);
    s(_o, mo = ki),
        (e = _o.prototype).addHooks = function() {
            Qe(this.target.getContainer(), "touchstart", this._onTouchStart, this)
        }
        ,
        e.removeHooks = function() {
            $e(this.target.getContainer(), "touchstart", this._onTouchStart)
        }
        ,
        e._onTouchStart = function(t) {
            var e, i, n = this.target;
            !t.touches || t.touches.length < 2 || (i = n.getContainer(),
                e = si(t.touches[0], i),
                i = si(t.touches[1], i),
                this.preY = e.y,
                this._startP1 = e,
                this._startP2 = i,
                this._startDist = e.distanceTo(i),
                this._startVector = e.sub(i),
                this._startZoom = n.getZoom(),
                this._startBearing = n.getBearing(),
                mi(document, "touchmove", this._onTouchMove, this),
                mi(document, "touchend", this._onTouchEnd, this),
                Qe(document, "touchmove", this._onTouchMove, this),
                Qe(document, "touchend", this._onTouchEnd, this),
                ei(t),
                n._fireEvent("touchactstart"))
        }
        ,
        e._onTouchMove = function(t) {
            var e, i, n, r, o, s, a, h = this.target;
            !t.touches || t.touches.length < 2 || (a = h.getContainer(),
                s = si(t.touches[0], a),
                a = si(t.touches[1], a),
                e = s.sub(this._startP1),
                i = a.sub(this._startP2),
                r = s.sub(a),
                n = s.distanceTo(a) / this._startDist,
                r = 180 * r.angleWith(this._startVector) / Math.PI,
                o = .4 * ((this.preY || s.y) - s.y),
                this.preY = s.y,
                t = {
                    domEvent: t,
                    mousePos: [s, a]
                },
            this.mode || (h.options.touchRotate && 8 < Math.abs(r) ? this.mode = h.options.touchZoomRotate ? "rotate_zoom" : "rotate" : h.options.touchPitch && 0 < e.y * i.y && 10 < Math.abs(e.y) && 10 < Math.abs(i.y) ? this.mode = "pitch" : h.options.zoomable && h.options.touchZoom && .15 < Math.abs(1 - n) && (this.mode = h.options.touchZoomRotate && h.options.touchRotate ? "rotate_zoom" : "zoom"),
                this._startTouching(t)),
            "zoom" !== this.mode && "rotate_zoom" !== this.mode || (this._scale = n,
                s = h._getResolution(this._startZoom) / n,
                a = h.getZoomFromRes(s),
                h.onZooming(a, this._Origin)),
                "rotate" === this.mode || "rotate_zoom" === this.mode ? (h.setBearing(this._startBearing + r),
                    h.onDragRotating(t)) : "pitch" === this.mode && (h.setPitch(h.getPitch() + o),
                    h.onDragRotating(t)),
                h._fireEvent("touchactinging"))
        }
        ,
        e._startTouching = function(t) {
            var e, i = this.target;
            "zoom" !== this.mode && "rotate_zoom" !== this.mode || (e = i.getSize(),
                this._Origin = new R(e.width / 2,e.height / 2),
                i.onZoomStart(null, this._Origin)),
            "rotate" !== this.mode && "pitch" !== this.mode && "rotate_zoom" !== this.mode || i.onDragRotateStart(t)
        }
        ,
        e._onTouchEnd = function(t) {
            delete this.preY;
            var e, i = this.target;
            mi(document, "touchmove", this._onTouchMove, this),
                mi(document, "touchend", this._onTouchEnd, this),
            "zoom" !== this.mode && "rotate_zoom" !== this.mode || (e = this._scale,
                e = i._getResolution(this._startZoom) / e,
                e = i.getZoomFromRes(e),
                i.onZoomEnd(e, this._Origin)),
            "pitch" !== this.mode && "rotate" !== this.mode && "rotate_zoom" !== this.mode || i.onDragRotateEnd({
                domEvent: t
            }),
                delete this.mode,
                i._fireEvent("touchactend")
        }
    ;
    var mo, a = _o;
    function _o() {
        return mo.apply(this, arguments) || this
    }
    h.mergeOptions({
        touchGesture: !0,
        touchZoom: !0,
        touchPitch: !0,
        touchRotate: !0,
        touchZoomRotate: !1
    }),
        h.addOnLoadHook("addHandler", "touchGesture", a);
    function yo(t, e) {
        this.state = t,
            this.styles = e
    }
    function vo(t, e, i, n) {
        this._animation = t,
            this.options = e,
            this._onFrame = i,
            this.playState = "idle",
            this.ready = !0,
            this.finished = !1,
            this.target = n
    }
    var xo, wo = "__anim_player", Co = {
        in: function(t) {
            return Math.pow(t, 2)
        },
        out: function(t) {
            return 1 - Co.in(1 - t)
        },
        inAndOut: function(t) {
            return 3 * t * t - 2 * t * t * t
        },
        linear: function(t) {
            return t
        },
        upAndDown: function(t) {
            return t < .5 ? Co.inAndOut(2 * t) : 1 - Co.inAndOut(2 * (t - .5))
        }
    }, Po = {
        speed: {
            slow: 2e3,
            normal: 1e3,
            fast: 500
        },
        _resolveStyles: function(t) {
            if (!t)
                return null;
            var e, i, n, r, o, s = {}, a = {}, h = {};
            for (e in t)
                !t.hasOwnProperty(e) || !(n = t[e]) || Array.isArray(n) && (V(n[0]) || V(n[1])) || (i = void 0,
                    o = n,
                (i = !Array.isArray(o) && o.constructor === Object || !(!Array.isArray(o) || o[0].constructor !== Object) ? function(t) {
                    if (!Array.isArray(t))
                        return Po._resolveStyles(t);
                    for (var e = [], i = [], n = [], r = 0; r < t.length; r++) {
                        var o = Po._resolveStyles(t[r]);
                        o && (e.push(o[0]),
                            i.push(o[1]),
                            n.push(o[2]))
                    }
                    return e.length ? [e, i, n] : null
                }(n) : (r = o = void 0,
                    r = n = n,
                    n = (r = Array.isArray(n) ? r : P(n) ? [0, n] : n instanceof R || n instanceof M ? [new (o = n.constructor)(0,0), n] : [n, n])[0],
                    r = r[1],
                    P(n) && P(r) ? n === r ? null : [n, r - n, r] : Array.isArray(n) && P(n[0]) || n instanceof M || n instanceof R ? (r = Array.isArray(n) ? (n = new M(n),
                        new M(r)) : (n = new (o = n.constructor)(n),
                        new o(r)),
                        n.equals(r) ? null : [n, r.sub(n), r]) : [n, r, r])) && (a[e] = i[0],
                    s[e] = i[1],
                    h[e] = i[2]));
            return [a, s, h]
        },
        framing: function(t, e) {
            function l(t, e, i) {
                if (!e || !i)
                    return null;
                var n, r = {};
                for (n in i)
                    if (i.hasOwnProperty(n))
                        if (e[n] === u[n])
                            r[n] = e[n];
                        else {
                            var o = e[n]
                                , s = i[n];
                            if (P(s))
                                r[n] = o + t * s;
                            else if (Array.isArray(s)) {
                                for (var a = [], h = 0; h < s.length; h++)
                                    a.push(l(t, o[h], s[h]));
                                r[n] = a
                            } else
                                s.constructor === Object ? r[n] = l(t, o, s) : r[n] = o instanceof R || o instanceof M ? o.add(s.multi(t)) : s
                        }
                return r
            }
            var r, o, u, s = (s = (e = e || {}).easing ? Co[e.easing] : Co.linear) || Co.linear;
            (t = Po._resolveStyles(t)) && (o = t[0],
                r = t[1],
                u = t[2]);
            return function(t, e) {
                var i, n;
                return n = t < 0 ? (i = {
                    playState: "idle",
                    delta: 0
                },
                    o) : t < e ? (i = {
                    playState: "running",
                    delta: n = s(t / e)
                },
                    l(n, o, r)) : (i = {
                    playState: "finished",
                    delta: 1
                },
                    u),
                    i.startStyles = o,
                    i.destStyles = u,
                    i.progress = t,
                    i.remainingMs = e - t,
                    new yo(i,n)
            }
        },
        _requestAnimFrame: function(t) {
            this._frameQueue || (this._frameQueue = []),
                this._frameQueue.push(t),
                this._a()
        },
        _a: function() {
            this._animationFrameId || (this._animationFrameId = K(Po._frameFn))
        },
        _run: function() {
            if (this._frameQueue.length) {
                var t = this._frameQueue;
                this._frameQueue = [];
                for (var e = 0, i = t.length; e < i; e++)
                    t[e]();
                this._frameQueue.length ? this._animationFrameId = K(Po._frameFn) : delete this._animationFrameId
            }
        },
        animate: function(t, e, i, n) {
            t = Po.framing(t, e = e || {});
            return new vo(t,e,i,n)
        }
    }, e = (Po._frameFn = Po._run.bind(Po),
        m(vo.prototype, {
            _prepare: function() {
                var t = this.options
                    , e = (e = b(e = t.speed || t.duration) ? (e = Po.speed[e]) || +e : e) || Po.speed.normal;
                this.duration = e,
                    this._framer = t.framer || Po._requestAnimFrame.bind(Po)
            },
            play: function() {
                if ("idle" !== this.playState && "paused" !== this.playState || this.target && this.target[wo])
                    return this;
                this.target && (this.target[wo] = 1),
                "idle" === this.playState && (this.currentTime = 0,
                    this._prepare());
                var t, e = F();
                return this.startTime || (t = this.options,
                    this.startTime = t.startTime || e),
                    this._playStartTime = Math.max(e, this.startTime),
                "paused" === this.playState && (this._playStartTime -= this.currentTime),
                    this.playState = "running",
                    this._run(),
                    this
            },
            pause: function() {
                return "paused" === this.playState || (this.playState = "paused",
                    this._run()),
                    this
            },
            cancel: function() {
                return "idle" === this.playState || (this.playState = "idle",
                    this.finished = !1,
                    this._run()),
                    this
            },
            finish: function() {
                return "finished" === this.playState || (this.playState = "finished",
                    this.finished = !0,
                    this._run()),
                    this
            },
            reverse: function() {},
            _run: function() {
                var t, e = this, i = this._onFrame, n = F(), r = n - this._playStartTime;
                if (this.options.repeat && r >= this.duration && (this._playStartTime = n,
                    r = 0),
                "running" !== this.playState)
                    return this.target && delete this.target[wo],
                        void (i && ("finished" === this.playState ? r = this.duration : "idle" === this.playState && (r = 0),
                            (t = this._animation(r, this.duration)).state.playState = this.playState,
                            i(t)));
                var o = this._animation(r, this.duration);
                this.playState = o.state.playState,
                "running" !== this.playState && this.target && delete this.target[wo],
                    "idle" === this.playState ? this.startTime > n && setTimeout(this._run.bind(this), this.startTime - n) : "running" === this.playState ? this._framer(function() {
                        "running" === e.playState && (e.currentTime = r,
                        i && i(o),
                            e._run())
                    }) : "finished" === this.playState && (this.finished = !0,
                    i && i(o))
            }
        }),
        Object.freeze({
            Animation: Po,
            Easing: Co,
            Player: vo,
            Frame: yo
        })), bo = Mi(function(t) {
        function n(t, e) {
            var i = t.length - 1
                , n = [t[0]];
            return function t(e, i, n, r, o) {
                for (var s, a, h, l, u, c, d, g = r, p = i + 1; p < n; p++) {
                    a = e[p],
                        h = e[i],
                        f = e[n],
                        d = c = u = l = void 0,
                        u = h.x,
                        h = h.y,
                        c = f.x - u,
                        d = f.y - h,
                    0 === c && 0 === d || (1 < (l = ((a.x - u) * c + (a.y - h) * d) / (c * c + d * d)) ? (u = f.x,
                        h = f.y) : 0 < l && (u += c * l,
                        h += d * l));
                    var f = (c = a.x - u) * c + (d = a.y - h) * d;
                    g < f && (s = p,
                        g = f)
                }
                r < g && (1 < s - i && t(e, i, s, r, o),
                    o.push(e[s]),
                1 < n - s && t(e, s, n, r, o))
            }(t, 0, i, e, n),
                n.push(t[i]),
                n
        }
        function e(t, e, i) {
            if (t.length <= 2)
                return t;
            e = void 0 !== e ? e * e : 1;
            return t = n(t = i ? t : function(t, e) {
                for (var i, n, r, o, s = t[0], a = [s], h = 1, l = t.length; h < l; h++)
                    i = t[h],
                        r = s,
                        o = void 0,
                        o = (n = i).x - r.x,
                        n = n.y - r.y,
                    e < o * o + n * n && (a.push(i),
                        s = i);
                return s !== i && a.push(i),
                    a
            }(t, e), e)
        }
        t.exports = e,
            t.exports.default = e
    }), a = (s(Mo, xo = y),
        (a = Mo.prototype).getOutline = function() {
            if (!this._getPainter())
                return null;
            var t = this.getExtent();
            return new S(t.toArray(),{
                symbol: {
                    lineWidth: 1,
                    lineColor: "6b707b"
                }
            })
        }
        ,
        a.animateShow = function(t, i) {
            var n = this
                , r = (void 0 === t && (t = {}),
            this._showPlayer && this._showPlayer.finish(),
            p(t) && (i = t = {}),
                this.getCoordinates());
            if (0 === r.length)
                return this;
            this._animIdx = 0,
                this._animLenSoFar = 0,
                this.show();
            for (var o = !!this.getShell ? this.getShell().concat(this.getShell()[0]) : this.getCoordinates(), e = this._getProjection(), s = e.projectCoords(o), a = (this._prjAniShowCenter = this._getPrjExtent().getCenter(),
                this._aniShowCenter = e.unproject(this._prjAniShowCenter),
            t.duration || 1e3), e = t.easing || "out", h = (this.setCoordinates([]),
                0), l = 1; l < s.length; l++)
                h += s[l].distanceTo(s[l - 1]);
            var u = this._showPlayer = Po.animate({
                t: a
            }, {
                duration: a,
                easing: e
            }, function(t) {
                var e;
                n.getMap() ? (e = n._drawAnimShowFrame(t.styles.t, a, h, o, s),
                "finished" === t.state.playState && (delete n._showPlayer,
                    delete n._aniShowCenter,
                    delete n._prjAniShowCenter,
                    delete n._animIdx,
                    delete n._animLenSoFar,
                    delete n._animTailRatio,
                    n.setCoordinates(r)),
                i && i(t, e)) : "finished" !== u.playState && (u.finish(),
                i && (e = n.getCoordinates(),
                    i(t, e[e.length - 1])))
            }, this);
            return u.play(),
                u
        }
        ,
        a._drawAnimShowFrame = function(t, e, i, n, r) {
            if (0 === t)
                return n[0];
            for (var o = this._getProjection(), s = t / e * i, a = 0, h = this._animIdx, l = r.length; h < l - 1 && (a = r[h].distanceTo(r[h + 1]),
                !(this._animLenSoFar + a > s)); h++)
                this._animLenSoFar += a;
            if (this._animIdx = h,
            this._animIdx >= l - 1)
                return this.setCoordinates(n),
                    n[n.length - 1];
            var t = this._animIdx
                , e = r[t]
                , i = r[t + 1]
                , t = (s - this._animLenSoFar) / a
                , u = (this._animTailRatio = t,
            e.x + (i.x - e.x) * t)
                , i = e.y + (i.y - e.y) * t
                , e = new M(u,i)
                , t = o.unproject(e)
                , u = !!this.getShell;
            return !u && 0 < this.options.smoothness ? (i = n.slice(0, this._animIdx + 3),
                this.setCoordinates(i),
                o = r.slice(0, this._animIdx + 3),
                this._setPrjCoordinates(o)) : ((i = n.slice(0, this._animIdx + 1)).push(t),
                (o = r.slice(0, this._animIdx + 1)).push(e),
                u ? (this.setCoordinates([this._aniShowCenter].concat(i)),
                    this._setPrjCoordinates([this._prjAniShowCenter].concat(o))) : (this.setCoordinates(i),
                    this._setPrjCoordinates(o))),
                t
        }
        ,
        a._getCenterInExtent = function(t, e, i) {
            var n = this.getExtent();
            if (!t.intersects(n))
                return null;
            n = i(e, t);
            if (0 === n.length)
                return null;
            var r = 0
                , o = 0
                , s = 0
                , i = (n.forEach(function(t) {
                Array.isArray(t) ? t.forEach(function(t) {
                    t.point && (t = t.point),
                        r += t.x,
                        o += t.y,
                        s++
                }) : (t.point && (t = t.point),
                    r += t.x,
                    o += t.y,
                    s++)
            }),
                new M(r,o)._multi(1 / s));
            return i.count = s,
                i
        }
        ,
        a._getPath2DPoints = function(t, e, i) {
            if (!L(t))
                return [];
            var n = this.getMap()
                , e = !e && this._shouldSimplify()
                , r = this.options.simplifyTolerance * n._getResolution()
                , o = Array.isArray(t[0]);
            return delete this._simplified,
            e && !o && (e = t.length,
                t = bo(t, r, !1),
                this._simplified = t.length < e),
            V(i) && (i = n.getZoom()),
                at(t, function(t) {
                    return n._prjToPoint(t, i)
                })
        }
        ,
        a._shouldSimplify = function() {
            var t = this.getLayer()
                , e = this.getProperties()
                , e = e && t.options.enableAltitude && !V(e[t.options.altitudeProperty]);
            return t && t.options.enableSimplify && !e && this.options.enableSimplify && !this._showPlayer
        }
        ,
        a._setPrjCoordinates = function(t) {
            this._prjCoords = t,
                this.onShapeChanged()
        }
        ,
        a._getPrjCoordinates = function() {
            return this._verifyProjection(),
            !this._prjCoords && this._getProjection() && (this._prjCoords = this._projectCoords(this._coordinates)),
                this._prjCoords
        }
        ,
        a._updateCache = function() {
            this._clearCache(),
            this._getProjection() && this._prjCoords && (this._coordinates = this._unprojectCoords(this._getPrjCoordinates()))
        }
        ,
        a._clearProjection = function() {
            this._prjCoords = null,
                xo.prototype._clearProjection.call(this)
        }
        ,
        a._projectCoords = function(t) {
            var e = this._getProjection();
            return e ? e.projectCoords(t) : []
        }
        ,
        a._unprojectCoords = function(t) {
            var e = this._getProjection();
            return e ? e.unprojectCoords(t) : []
        }
        ,
        a._computeCenter = function() {
            var t = this._coordinates;
            if (!L(t))
                return null;
            for (var e = 0, i = 0, n = 0, r = t.length, o = 0; o < r; o++)
                t[o] && P(t[o].x) && P(t[o].y) && (e += t[o].x,
                    i += t[o].y,
                    n++);
            return new M(e / n,i / n)
        }
        ,
        a._computeExtent = function() {
            var t = this._coordinates;
            if (!L(t))
                return null;
            t = [t];
            return this.hasHoles && this.hasHoles() && t.push.apply(t, this.getHoles()),
                this._coords2Extent(t, this._getProjection())
        }
        ,
        a._computePrjExtent = function() {
            var t = [this._getPrjCoordinates()];
            return this.hasHoles && this.hasHoles() && t.push.apply(t, this._getPrjHoles()),
                this._coords2Extent(t)
        }
        ,
        a._get2DLength = function() {
            for (var t = this._getPath2DPoints(this._getPrjCoordinates(), !0), e = 0, i = 1, n = t.length; i < n; i++)
                e += t[i].distanceTo(t[i - 1]);
            return e
        }
        ,
        a._hitTestTolerance = function() {
            var t = this._getInternalSymbol();
            if (Array.isArray(t))
                for (var e = 0, i = 0; i < t.length; i++)
                    P(t[i].lineWidth) && t[i].lineWidth > e && (e = t[i].lineWidth);
            else
                e = t.lineWidth;
            return P(e) ? e / 2 : 1.5
        }
        ,
        a._coords2Extent = function(t, e) {
            for (var i = new g(e), n = 0, r = t.length; n < r; n++)
                for (var o = 0, s = t[n].length; o < s; o++)
                    i._combine(t[n][o]);
            return i
        }
        ,
        Mo);
    function Mo() {
        return xo.apply(this, arguments) || this
    }
    a.mergeOptions({
        smoothness: 0,
        enableClip: !0,
        enableSimplify: !0,
        simplifyTolerance: 2,
        symbol: {
            lineColor: "#000",
            lineWidth: 2,
            lineOpacity: 1,
            polygonFill: "#fff",
            polygonOpacity: 1,
            opacity: 1
        }
    });
    var So, To = "Polygon", S = (s(Eo, So = a),
        (l = Eo.prototype).setCoordinates = function(t) {
            if (!t)
                return this._coordinates = null,
                    this._holes = null,
                    this._projectRings(),
                    this;
            var e = M.toCoordinates(t)
                , i = e.length;
            if (Array.isArray(e[0])) {
                if (this._coordinates = this._trimRing(e[0]),
                1 < i) {
                    for (var n = [], r = 1; r < i; r++)
                        e[r] && n.push(this._trimRing(e[r]));
                    this._holes = n
                }
            } else
                this._coordinates = this._trimRing(e);
            return this._projectRings(),
                this
        }
        ,
        l.getCoordinates = function() {
            if (!this._coordinates)
                return [];
            for (var t = this.getHoles(), e = [this._copyAndCloseRing(this._coordinates)], i = 0, n = t.length; i < n; i++)
                e.push(this._copyAndCloseRing(t[i]));
            return e
        }
        ,
        l.getCenterInExtent = function(t) {
            return this._getCenterInExtent(t, this.getShell(), Mn)
        }
        ,
        l.getShell = function() {
            return this._coordinates || []
        }
        ,
        l.getHoles = function() {
            return this._holes || []
        }
        ,
        l.hasHoles = function() {
            return 0 < this.getHoles().length
        }
        ,
        l._projectRings = function() {
            this.getMap() && (this._prjCoords = this._projectCoords(this._coordinates),
                this._prjHoles = this._projectCoords(this._holes)),
                this.onShapeChanged()
        }
        ,
        l._setPrjCoordinates = function(t) {
            this._prjCoords = t,
                this.onShapeChanged()
        }
        ,
        l._cleanRing = function(t) {
            for (var e = t.length - 1; 0 <= e; e--)
                t[e] || t.splice(e, 1)
        }
        ,
        l._checkRing = function(t) {
            if (this._cleanRing(t),
            !t || !L(t))
                return !1;
            var e = t[t.length - 1]
                , i = !0;
            return i = t[0].x === e.x && t[0].y === e.y ? i : !1
        }
        ,
        l._trimRing = function(t) {
            var e = this._checkRing(t);
            return L(t) && e && t.splice(t.length - 1, 1),
                t
        }
        ,
        l._copyAndCloseRing = function(t) {
            t = t.slice(0);
            var e = this._checkRing(t);
            return L(t) && !e && t.push(t[0].copy()),
                t
        }
        ,
        l._getPrjShell = function() {
            return this.getJSONType() === To ? this._getPrjCoordinates() : (this._verifyProjection(),
            this._getProjection() && !this._prjShell && (this._prjShell = this._projectCoords(this.getShell())),
                this._prjShell)
        }
        ,
        l._getPrjHoles = function() {
            var t = this._getProjection();
            return this._verifyProjection(),
            t && !this._prjHoles && (this._prjHoles = this._projectCoords(this.getHoles())),
                this._prjHoles
        }
        ,
        l._computeGeodesicLength = function(t) {
            var e = this.getCoordinates();
            if (!L(e))
                return 0;
            for (var i = 0, n = 0, r = e.length; n < r; n++)
                i += t.measureLength(e[n]);
            return i
        }
        ,
        l._computeGeodesicArea = function(t) {
            var e = this.getCoordinates();
            if (!L(e))
                return 0;
            for (var i = t.measureArea(e[0]), n = 1, r = e.length; n < r; n++)
                i -= t.measureArea(e[n]);
            return i
        }
        ,
        l._updateCache = function() {
            So.prototype._updateCache.call(this),
            this._prjHoles && (this._holes = this._unprojectCoords(this._getPrjHoles()))
        }
        ,
        l._clearCache = function() {
            return delete this._prjShell,
                So.prototype._clearCache.call(this)
        }
        ,
        l._clearProjection = function() {
            this._prjHoles && (this._prjHoles = null),
            this._prjShell && (this._prjShell = null),
                So.prototype._clearProjection.call(this)
        }
        ,
        Eo);
    function Eo(t, e) {
        e = So.call(this, e) || this;
        return e.type = "Polygon",
        t && e.setCoordinates(t),
            e
    }
    function ko(t) {
        return s(e, i = t),
            (t = e.prototype).getCoordinates = function() {
                return this._coordinates
            }
            ,
            t.setCoordinates = function(t) {
                t = t instanceof M ? t : new M(t);
                if (t.equals(this._coordinates))
                    return this;
                if (this._coordinates = t,
                    !this.getMap())
                    return this.onPositionChanged(),
                        this;
                t = this._getProjection();
                return this._setPrjCoordinates(t.project(this._coordinates)),
                    this
            }
            ,
            t._getCenter2DPoint = function(t) {
                var e = this.getMap();
                if (!e)
                    return null;
                var t = V(t) ? e.getZoom() : e.getGLZoom()
                    , i = this._getPrjCoordinates();
                return i ? e._prjToPoint(i, t) : null
            }
            ,
            t._getPrjCoordinates = function() {
                var t = this._getProjection();
                return this._verifyProjection(),
                !this._pcenter && t && this._coordinates && (this._pcenter = t.project(this._coordinates)),
                    this._pcenter
            }
            ,
            t._setPrjCoordinates = function(t) {
                this._pcenter = t,
                    this.onPositionChanged()
            }
            ,
            t._updateCache = function() {
                this._clearCache();
                var t = this._getProjection();
                this._pcenter && t && (this._coordinates = t.unproject(this._pcenter))
            }
            ,
            t._clearProjection = function() {
                this._pcenter = null,
                    i.prototype._clearProjection.call(this)
            }
            ,
            t._computeCenter = function() {
                return this._coordinates ? this._coordinates.copy() : null
            }
            ,
            e;
        function e() {
            return i.apply(this, arguments) || this
        }
        var i
    }
    S.registerJSONType(To);
    s(Lo, Ro = ko(y)),
        (l = Lo.prototype).getOutline = function() {
            var t = this._getPainter();
            if (!t)
                return null;
            var e = this.getCoordinates()
                , t = t.getContainerExtent()
                , i = this.getMap().coordToContainerPoint(e);
            return new Lo(e,{
                symbol: {
                    markerType: "square",
                    markerWidth: t.getWidth(),
                    markerHeight: t.getHeight(),
                    markerLineWidth: 1,
                    markerLineColor: "6b707b",
                    markerFill: "rgba(0, 0, 0, 0)",
                    markerDx: t.xmin - (i.x - t.getWidth() / 2),
                    markerDy: t.ymin - (i.y - t.getHeight() / 2)
                }
            })
        }
        ,
        l._isVectorMarker = function() {
            var t = this._getInternalSymbol();
            return !Array.isArray(t) && Zn.test(t)
        }
        ,
        l._canEdit = function() {
            var t = this._getInternalSymbol();
            return !Array.isArray(t) && (Zn.test(t) || ir.test(t) || Bn.test(t))
        }
        ,
        l._containsPoint = function(t, e) {
            var i = this.getContainerExtent();
            return !!(i = e ? i.expand(e) : i).contains(t) && (!this.options.hitTestForEvent || Ro.prototype._containsPoint.call(this, t, e))
        }
        ,
        l._computeExtent = function() {
            return Oo.call(this, "getCenter")
        }
        ,
        l._computePrjExtent = function() {
            return Oo.call(this, "_getPrjCoordinates")
        }
        ,
        l._computeGeodesicLength = function() {
            return 0
        }
        ,
        l._computeGeodesicArea = function() {
            return 0
        }
        ,
        l._getSprite = function(t, e) {
            return (this._getPainter() ? this._getPainter() : new _r(this)).getSprite(t, e)
        }
    ;
    var Ro, Ao = Lo;
    function Lo(t, e) {
        e = Ro.call(this, e) || this;
        return e.type = "Point",
        t && e.setCoordinates(t),
            e
    }
    function Oo(t) {
        t = this[t]();
        return t ? new g(t,t,this._getProjection()) : null
    }
    Ao.mergeOptions({
        symbol: {
            markerType: "path",
            markerPath: [{
                path: "M8 23l0 0 0 0 0 0 0 0 0 0c-4,-5 -8,-10 -8,-14 0,-5 4,-9 8,-9l0 0 0 0c4,0 8,4 8,9 0,4 -4,9 -8,14z M3,9 a5,5 0,1,0,0,-0.9Z",
                fill: "#DE3333"
            }],
            markerPathWidth: 16,
            markerPathHeight: 23,
            markerWidth: 24,
            markerHeight: 34
        },
        hitTestForEvent: !1
    }),
        Ao.registerJSONType("Marker");
    s(jo, Do = a),
        (l = jo.prototype).setCoordinates = function(t) {
            return t ? (this._coordinates = M.toCoordinates(t),
                this.getMap() ? this._setPrjCoordinates(this._projectCoords(this._coordinates)) : this.onShapeChanged()) : (this._coordinates = null,
                this._setPrjCoordinates(null)),
                this
        }
        ,
        l.getCoordinates = function() {
            return this._coordinates || []
        }
        ,
        l.getCenterInExtent = function(t) {
            return this._getCenterInExtent(t, this.getCoordinates(), bn)
        }
        ,
        l._computeGeodesicLength = function(t) {
            return t.measureLength(this.getCoordinates())
        }
        ,
        l._computeGeodesicArea = function() {
            return 0
        }
    ;
    var Do, Io = jo;
    function jo(t, e) {
        e = Do.call(this, e) || this;
        return e.type = "LineString",
        t && e.setCoordinates(t),
            e
    }
    Io.mergeOptions({
        arrowStyle: null,
        arrowPlacement: "vertex-last"
    }),
        Io.registerJSONType("LineString");
    s(Ho, zo = y),
        (l = Ho.prototype).setGeometries = function(t) {
            for (var e = this._checkGeometries(t || []), i = this._getSymbol(), n = this.config(), r = e.length - 1; 0 <= r; r--)
                e[r]._initOptions(n),
                    e[r]._setParent(this),
                    e[r]._setEventParent(this),
                i && e[r].setSymbol(i);
            return this._geometries = e,
            this.getLayer() && (this._bindGeometriesToLayer(),
                this.onShapeChanged()),
                this
        }
        ,
        l.getGeometries = function() {
            return this._geometries || []
        }
        ,
        l.forEach = function(t, e) {
            for (var i = this.getGeometries(), n = 0, r = i.length; n < r; n++)
                i[n] && (e ? t.call(e, i[n], n) : t(i[n], n));
            return this
        }
        ,
        l.filter = function(t, i) {
            if (!t)
                return new Ho;
            var n = []
                , r = p(t)
                , o = r ? t : St(t);
            return this.forEach(function(t) {
                var e = r ? t : It(t);
                (i ? o.call(i, e) : o(e)) && n.push(t)
            }, this),
                new Ho(n)
        }
        ,
        l.translate = function(t) {
            if (!t)
                return this;
            if (this.isEmpty())
                return this;
            var e = arguments;
            return this.forEach(function(t) {
                t && t.translate && t.translate.apply(t, e)
            }),
                this
        }
        ,
        l.isEmpty = function() {
            return !L(this.getGeometries())
        }
        ,
        l.remove = function() {
            return this.forEach(function(t) {
                t._unbind()
            }),
                y.prototype.remove.apply(this, arguments)
        }
        ,
        l.show = function() {
            return this.options.visible = !0,
                this.forEach(function(t) {
                    t.show()
                }),
                this
        }
        ,
        l.hide = function() {
            return this.options.visible = !1,
                this.forEach(function(t) {
                    t.hide()
                }),
                this
        }
        ,
        l.onConfig = function(e) {
            this.forEach(function(t) {
                t.config(e)
            })
        }
        ,
        l.getSymbol = function() {
            var e, i, t = zo.prototype.getSymbol.call(this);
            return t || (i = !(e = []),
                this.forEach(function(t) {
                    t.getSymbol() && !i && (i = !0),
                        e.push(t.getSymbol())
                }),
            i && (t = {
                children: e
            })),
                t
        }
        ,
        l.setSymbol = function(i) {
            var e;
            return i && i.children ? (this._symbol = null,
                this.forEach(function(t, e) {
                    t.setSymbol(i.children[e])
                })) : (e = this._prepareSymbol(i),
                this._symbol = e,
                this.forEach(function(t) {
                    t.setSymbol(e)
                })),
                this.onSymbolChanged(),
                this
        }
        ,
        l._setExternSymbol = function(e) {
            return e = this._prepareSymbol(e),
                this._externSymbol = e,
                this.forEach(function(t) {
                    t._setExternSymbol(e)
                }),
                this.onSymbolChanged(),
                this
        }
        ,
        l._bindLayer = function() {
            zo.prototype._bindLayer.apply(this, arguments),
                this._bindGeometriesToLayer()
        }
        ,
        l._bindGeometriesToLayer = function() {
            var e = this.getLayer();
            this.forEach(function(t) {
                t._bindLayer(e)
            })
        }
        ,
        l._checkGeometries = function(t) {
            var e = "The geometry added to collection is invalid.";
            if (t && !Array.isArray(t)) {
                if (t instanceof y)
                    return [t];
                throw new Error(e)
            }
            for (var i = 0, n = t.length; i < n; i++)
                if (!this._checkGeo(t[i]))
                    throw new Error(e + " Index: " + i);
            return t
        }
        ,
        l._checkGeo = function(t) {
            return t instanceof y
        }
        ,
        l._updateCache = function() {
            this._clearCache(),
            this.isEmpty() || this.forEach(function(t) {
                t && t._updateCache && t._updateCache()
            })
        }
        ,
        l._removePainter = function() {
            this._painter && this._painter.remove(),
                delete this._painter,
                this.forEach(function(t) {
                    t._removePainter()
                })
        }
        ,
        l._computeCenter = function(t) {
            if (!t || this.isEmpty())
                return null;
            for (var e, i = 0, n = 0, r = 0, o = this.getGeometries(), s = 0, a = o.length; s < a; s++)
                !o[s] || (e = o[s]._computeCenter(t)) && (i += e.x,
                    n += e.y,
                    r++);
            return 0 === r ? null : new M(i / r,n / r)
        }
        ,
        l._containsPoint = function(t, e) {
            if (this.isEmpty())
                return !1;
            for (var i = this.getGeometries(), n = 0, r = i.length; n < r; n++)
                if (i[n]._containsPoint(t, e))
                    return !0;
            return !1
        }
        ,
        l._computeExtent = function(t) {
            return Go.call(this, t, "_computeExtent")
        }
        ,
        l._computePrjExtent = function(t) {
            return Go.call(this, t, "_computePrjExtent")
        }
        ,
        l._computeGeodesicLength = function(t) {
            if (!t || this.isEmpty())
                return 0;
            for (var e = this.getGeometries(), i = 0, n = 0, r = e.length; n < r; n++)
                e[n] && (i += e[n]._computeGeodesicLength(t));
            return i
        }
        ,
        l._computeGeodesicArea = function(t) {
            if (!t || this.isEmpty())
                return 0;
            for (var e = this.getGeometries(), i = 0, n = 0, r = e.length; n < r; n++)
                e[n] && (i += e[n]._computeGeodesicArea(t));
            return i
        }
        ,
        l._exportGeoJSONGeometry = function() {
            var t = [];
            if (!this.isEmpty())
                for (var e = this.getGeometries(), i = 0, n = e.length; i < n; i++)
                    e[i] && t.push(e[i]._exportGeoJSONGeometry());
            return {
                type: "GeometryCollection",
                geometries: t
            }
        }
        ,
        l._clearProjection = function() {
            if (!this.isEmpty())
                for (var t = this.getGeometries(), e = 0, i = t.length; e < i; e++)
                    t[e] && t[e]._clearProjection()
        }
        ,
        l._getConnectPoints = function() {
            var t = this.getExtent();
            return [new M(t.xmin,t.ymax), new M(t.xmax,t.ymin), new M(t.xmin,t.ymin), new M(t.xmax,t.ymax)]
        }
        ,
        l._getExternalResources = function() {
            if (this.isEmpty())
                return [];
            for (var t, e = this.getGeometries(), i = [], n = {}, r = 0, o = e.length; r < o; r++)
                if (e[r])
                    for (var s, a = 0, h = (s = Qt(e[r]._getInternalSymbol())).length; a < h; a++)
                        n[t = s[a].join()] || (i.push(s[a]),
                            n[t] = 1);
            return i
        }
        ,
        l.startEdit = function(t) {
            var e = this;
            if (this.isEmpty())
                return this;
            (t = t || {}).symbol && (this._originalSymbol = this.getSymbol(),
                this.setSymbol(t.symbol)),
                this._draggbleBeforeEdit = this.options.draggable,
                this.config("draggable", !1);
            for (var i = this.getGeometries(), n = 0, r = i.length; n < r; n++)
                i[n].startEdit(t);
            return this._editing = !0,
                this.hide(),
                setTimeout(function() {
                    e.fire("editstart")
                }, 1),
                this
        }
        ,
        l.endEdit = function() {
            if (this.isEmpty())
                return this;
            for (var t = this.getGeometries(), e = 0, i = t.length; e < i; e++)
                t[e].endEdit();
            return this._originalSymbol && (this.setSymbol(this._originalSymbol),
                delete this._originalSymbol),
                this._editing = !1,
                this.show(),
                this.config("draggable", this._draggbleBeforeEdit),
                this.fire("editend"),
                this
        }
        ,
        l.isEditing = function() {
            return !!this._editing
        }
    ;
    var zo, Zo = Ho;
    function Ho(t, e) {
        e = zo.call(this, e) || this;
        return e.type = "GeometryCollection",
            e.setGeometries(t),
            e
    }
    function Go(t, e) {
        if (this.isEmpty())
            return null;
        for (var i = this.getGeometries(), n = null, r = 0, o = i.length; r < o; r++) {
            var s = i[r];
            s && ((s = s[e](t)) && (n = s.combine(n)))
        }
        return n
    }
    Zo.registerJSONType("GeometryCollection");
    s(No, Fo = Zo),
        (l = No.prototype).getCoordinates = function() {
            for (var t = [], e = this.getGeometries(), i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.push(r.getShell && "Polygon" !== r.getJSONType() ? [r.getShell()] : r.getCoordinates())
            }
            return t
        }
        ,
        l.setCoordinates = function(t) {
            for (var e = [], i = 0, n = (t = t || []).length; i < n; i++) {
                var r = new this.GeometryType(t[i],this.config());
                e.push(r)
            }
            return this.setGeometries(e),
                this
        }
        ,
        l._initData = function(t) {
            (t = t || []).length && (t[0]instanceof this.GeometryType ? this.setGeometries(t) : this.setCoordinates(t))
        }
        ,
        l._checkGeo = function(t) {
            return t instanceof this.GeometryType
        }
        ,
        l._exportGeoJSONGeometry = function() {
            var t = this.getCoordinates()
                , t = M.toNumberArrays(t);
            return {
                type: this.getType(),
                coordinates: t
            }
        }
    ;
    var Fo, l = No;
    function No(t, e, i, n) {
        n = Fo.call(this, null, n) || this;
        return n.GeometryType = t,
            n.type = e,
            n._initData(i),
            n
    }
    s(Vo, Wo = l),
        Vo.prototype.findClosest = function(n) {
            if (!n)
                return null;
            var t = this.getCoordinates()
                , r = null
                , o = 1 / 0;
            return t.forEach(function(t) {
                i = (e = n).x - t.x,
                    e = e.y - t.y;
                var e, i = Math.sqrt(i * i + e * e);
                i < o && (r = t,
                    o = i)
            }),
                r
        }
    ;
    var Wo, Bo = Vo;
    function Vo(t, e) {
        return Wo.call(this, Ao, "MultiPoint", t, e) || this
    }
    Bo.registerJSONType("MultiPoint");
    s(Jo, Uo = l),
        Jo.prototype.getCenterInExtent = function(e) {
            var t = this.getGeometries()
                , i = 0
                , n = 0
                , r = 0;
            return t.forEach(function(t) {
                t = t.getCenterInExtent(e);
                t && (i += t.x * t.count,
                    n += t.y * t.count,
                    r += t.count)
            }),
                0 === r ? null : new M(i,n)._multi(1 / r)
        }
    ;
    var Uo, l = Jo;
    function Jo() {
        return Uo.apply(this, arguments) || this
    }
    s(Xo, qo = l);
    var qo, Yo = Xo;
    function Xo(t, e) {
        return qo.call(this, Io, "MultiLineString", t, e) || this
    }
    Yo.registerJSONType("MultiLineString");
    s(Qo, Ko = l);
    var Ko, l = Qo;
    function Qo(t, e) {
        return Ko.call(this, S, "MultiPolygon", t, e) || this
    }
    l.registerJSONType("MultiPolygon");
    var $o, ts = {
        Marker: Ao,
        LineString: Io,
        Polygon: S,
        MultiPoint: Bo,
        MultiLineString: Yo,
        MultiPolygon: l
    }, es = {
        toGeometry: function(t, e) {
            if (b(t) && (t = rt(t)),
                Array.isArray(t)) {
                for (var i = [], n = 0, r = t.length; n < r; n++) {
                    var o = es._convert(t[n], e);
                    Array.isArray(o) ? ot(i, o) : i.push(o)
                }
                return i
            }
            return es._convert(t, e)
        },
        _convert: function(t, e) {
            if (!t || V(t.type))
                return null;
            var i = t.type;
            if ("Feature" === i)
                return n = t.geometry,
                    (n = es._convert(n)) ? (n.setId(t.id),
                        n.setProperties(t.properties),
                    e && e(n),
                        n) : null;
            if ("FeatureCollection" === i)
                return (n = t.features) ? es.toGeometry(n, e) : null;
            if (0 <= ["Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon"].indexOf(i))
                return n = new ts["Point" === i ? "Marker" : i](t.coordinates),
                e && e(n),
                    n;
            if ("GeometryCollection" !== i)
                return null;
            var n, r = t.geometries;
            if (!L(r))
                return n = new Zo,
                e && e(n),
                    n;
            for (var o = [], s = r.length, a = 0; a < s; a++)
                o.push(es._convert(r[a]));
            i = new Zo(o);
            return e && e(i),
                i
        }
    }, is = (s(ns, $o = ko(S)),
        ns.fromJSON = function(t) {
            var e = t.feature
                , t = new ns(t.coordinates,t.radius,t.options);
            return t.setProperties(e.properties),
                t
        }
        ,
        (u = ns.prototype).getRadius = function() {
            return this._radius
        }
        ,
        u.setRadius = function(t) {
            return this._radius = t,
                this.onShapeChanged(),
                this
        }
        ,
        u.getShell = function() {
            for (var t = this._getMeasurer(), e = this.getCoordinates(), i = this.options.numberOfShellPoints, n = this.getRadius(), r = [], o = 0, s = i - 1; o < s; o++) {
                var a = 360 * o / s * Math.PI / 180
                    , h = n * Math.cos(a)
                    , a = n * Math.sin(a)
                    , h = t.locate(e, h, a);
                r.push(h)
            }
            return r.push(r[0]),
                r
        }
        ,
        u.getHoles = function() {
            return []
        }
        ,
        u.animateShow = function() {
            return this.show()
        }
        ,
        u._containsPoint = function(t, e) {
            var i = this.getMap();
            if (i.getPitch())
                return $o.prototype._containsPoint.call(this, t, e);
            var i = i._pointToContainerPoint(this._getCenter2DPoint())
                , n = this.getSize()
                , e = V(e) ? this._hitTestTolerance() : e
                , n = i.add(n.width / 2, n.height / 2);
            return En(t, i, n, e)
        }
        ,
        u._computePrjExtent = function(e) {
            var t = this._getMinMax(e);
            if (!t)
                return null;
            var i = this._getPrjCoordinates()
                , t = t.map(function(t) {
                return e.project(t)
            })
                , n = t[0].x - i.x
                , r = t[1].x - i.x
                , o = t[2].y - i.y
                , t = t[3].y - i.y;
            return new g(i.add(n, o),i.add(r, t))
        }
        ,
        u._computeExtent = function(t) {
            t = this._getMinMax(t);
            return t ? new g(t[0].x,t[2].y,t[1].x,t[3].y,this._getProjection()) : null
        }
        ,
        u._getMinMax = function(t) {
            if (!t || !this._coordinates || V(this._radius))
                return null;
            var e = this._radius;
            return [t.locate(this._coordinates, -e, 0), t.locate(this._coordinates, e, 0), t.locate(this._coordinates, 0, e), t.locate(this._coordinates, 0, -e)]
        }
        ,
        u._computeGeodesicLength = function() {
            return V(this._radius) ? 0 : 2 * Math.PI * this._radius
        }
        ,
        u._computeGeodesicArea = function() {
            return V(this._radius) ? 0 : Math.PI * Math.pow(this._radius, 2)
        }
        ,
        u._exportGeoJSONGeometry = function() {
            return {
                type: "Polygon",
                coordinates: M.toNumberArrays([this.getShell()])
            }
        }
        ,
        u._toJSON = function(t) {
            var e = this.getCenter()
                , t = m({}, t)
                , t = (t.geometry = !1,
                this.toGeoJSON(t));
            return t.geometry = {
                type: "Polygon"
            },
                {
                    feature: t,
                    subType: "Circle",
                    coordinates: [e.x, e.y],
                    radius: this.getRadius()
                }
        }
        ,
        ns);
    function ns(t, e, i) {
        i = $o.call(this, null, i) || this;
        return t && i.setCoordinates(t),
            i._radius = e,
            i
    }
    is.mergeOptions({
        numberOfShellPoints: 60
    }),
        is.registerJSONType("Circle");
    s(ss, rs = ko(S)),
        ss.fromJSON = function(t) {
            var e = t.feature
                , t = new ss(t.coordinates,t.width,t.height,t.options);
            return t.setProperties(e.properties),
                t
        }
        ,
        (u = ss.prototype).getWidth = function() {
            return this.width
        }
        ,
        u.setWidth = function(t) {
            return this.width = t,
                this.onShapeChanged(),
                this
        }
        ,
        u.getHeight = function() {
            return this.height
        }
        ,
        u.setHeight = function(t) {
            return this.height = t,
                this.onShapeChanged(),
                this
        }
        ,
        u.getShell = function() {
            for (var t, e, i = this._getMeasurer(), n = this.getCoordinates(), r = this.options.numberOfShellPoints, o = this.getWidth(), s = this.getHeight(), a = [], h = Math.pow(o / 2, 2) * Math.pow(s / 2, 2), l = Math.pow(o / 2, 2), u = Math.pow(s / 2, 2), c = 0; c < r; c++) {
                e = (d = 360 * c / r) * Math.PI / 180,
                    t = Math.sqrt(h / (l * Math.pow(Math.tan(e), 2) + u)),
                    e = Math.sqrt(h / (u * Math.pow(1 / Math.tan(e), 2) + l)),
                90 < d && d < 270 && (t *= -1),
                180 < d && d < 360 && (e *= -1);
                var d = i.locate(n, t, e);
                a.push(d)
            }
            return a
        }
        ,
        u.getHoles = function() {
            return []
        }
        ,
        u.animateShow = function() {
            return this.show()
        }
        ,
        u._containsPoint = function(t, e) {
            var i = this.getMap();
            if (i.isTransforming())
                return rs.prototype._containsPoint.call(this, t, e);
            var n = i.getProjection()
                , e = V(e) ? this._hitTestTolerance() : e
                , n = n.projectCoords([this._coordinates, i.locate(this._coordinates, this.getWidth() / 2, this.getHeight() / 2)]);
            return En(t, i._prjToContainerPoint(n[0]), i._prjToContainerPoint(n[1]), e)
        }
        ,
        u._computePrjExtent = function() {
            return is.prototype._computePrjExtent.apply(this, arguments)
        }
        ,
        u._computeExtent = function() {
            return is.prototype._computeExtent.apply(this, arguments)
        }
        ,
        u._getMinMax = function(t) {
            if (!t || !this._coordinates || V(this.width) || V(this.height))
                return null;
            var e = this.getWidth()
                , i = this.getHeight();
            return [t.locate(this._coordinates, -e / 2, 0), t.locate(this._coordinates, e / 2, 0), t.locate(this._coordinates, 0, -i / 2), t.locate(this._coordinates, 0, i / 2)]
        }
        ,
        u._computeGeodesicLength = function() {
            if (V(this.width) || V(this.height))
                return 0;
            var t = this.width > this.height ? this.width : this.height;
            return 2 * Math.PI * t / 2 - 4 * Math.abs(this.width - this.height)
        }
        ,
        u._computeGeodesicArea = function() {
            return V(this.width) || V(this.height) ? 0 : Math.PI * this.width * this.height / 4
        }
        ,
        u._exportGeoJSONGeometry = function() {
            return {
                type: "Polygon",
                coordinates: M.toNumberArrays([this.getShell()])
            }
        }
        ,
        u._toJSON = function(t) {
            var t = m({}, t)
                , e = this.getCenter()
                , t = (t.geometry = !1,
                this.toGeoJSON(t));
            return t.geometry = {
                type: "Polygon"
            },
                {
                    feature: t,
                    subType: "Ellipse",
                    coordinates: [e.x, e.y],
                    width: this.getWidth(),
                    height: this.getHeight()
                }
        }
    ;
    var rs, os = ss;
    function ss(t, e, i, n) {
        n = rs.call(this, null, n) || this;
        return t && n.setCoordinates(t),
            n.width = e,
            n.height = i,
            n
    }
    os.mergeOptions({
        numberOfShellPoints: 80
    }),
        os.registerJSONType("Ellipse");
    s(ls, as = S),
        ls.fromJSON = function(t) {
            var e = t.feature
                , t = new ls(t.coordinates,t.width,t.height,t.options);
            return t.setProperties(e.properties),
                t
        }
        ,
        (u = ls.prototype).getCoordinates = function() {
            return this._coordinates
        }
        ,
        u.setCoordinates = function(t) {
            if (this._coordinates = t instanceof M ? t : new M(t),
            !this._coordinates || !this.getMap())
                return this.onPositionChanged(),
                    this;
            t = this._getProjection();
            return this._setPrjCoordinates(t.project(this._coordinates)),
                this
        }
        ,
        u.getWidth = function() {
            return this._width
        }
        ,
        u.setWidth = function(t) {
            return this._width = t,
                this.onShapeChanged(),
                this
        }
        ,
        u.getHeight = function() {
            return this._height
        }
        ,
        u.setHeight = function(t) {
            return this._height = t,
                this.onShapeChanged(),
                this
        }
        ,
        u.getShell = function() {
            var t = this._getMeasurer()
                , e = this._coordinates
                , i = this.getMap()
                , n = 1
                , r = -1
                , i = (i && ((i = i.getFullExtent()).left > i.right && (n = -1),
            i.bottom > i.top && (r = 1)),
                []);
            return i.push(e),
                i.push(t.locate(e, n * this._width, 0)),
                i.push(t.locate(e, n * this._width, r * this._height)),
                i.push(t.locate(e, 0, r * this._height)),
                i.push(e),
                i
        }
        ,
        u.getHoles = function() {
            return []
        }
        ,
        u.animateShow = function() {
            return this.show()
        }
        ,
        u._getPrjCoordinates = function() {
            var t = this._getProjection();
            return this._verifyProjection(),
            !this._pnw && t && this._coordinates && (this._pnw = t.project(this._coordinates)),
                this._pnw
        }
        ,
        u._setPrjCoordinates = function(t) {
            this._pnw = t,
                this.onPositionChanged()
        }
        ,
        u._getPrjShell = function() {
            var t = as.prototype._getPrjShell.call(this)
                , e = this._getProjection();
            if (!e.isSphere())
                return t;
            for (var e = e.getSphereExtent(), i = e.sx, n = e.sy, r = this._getProjection().getCircum(), o = t[0], s = 1, a = t.length; s < a; s++) {
                var h = t[s]
                    , l = 0
                    , u = 0;
                0 < i * (o.x - h.x) && (l = r.x * i),
                n * (o.y - h.y) < 0 && (u = r.y * n),
                    t[s]._add(l, u)
            }
            return t
        }
        ,
        u._updateCache = function() {
            this._clearCache();
            var t = this._getProjection();
            this._pnw && t && (this._coordinates = t.unproject(this._pnw))
        }
        ,
        u._clearProjection = function() {
            this._pnw = null,
                as.prototype._clearProjection.call(this)
        }
        ,
        u._computeCenter = function(t) {
            return t.locate(this._coordinates, this._width / 2, -this._height / 2)
        }
        ,
        u._containsPoint = function(t, e) {
            var i = this.getMap();
            if (i.isTransforming())
                return as.prototype._containsPoint.call(this, t, e);
            e = V(e) ? this._hitTestTolerance() : e,
                e = i._getResolution() * e,
                e = this._getPrjExtent().expand(e),
                i = i._containerPointToPrj(t);
            return e.contains(i)
        }
        ,
        u._computePrjExtent = function(t) {
            var e = this._getSouthEast(t);
            if (!e)
                return null;
            t = t.projectCoords([new M(this._coordinates.x,e.y), new M(e.x,this._coordinates.y)]);
            return new g(t[0],t[1])
        }
        ,
        u._computeExtent = function(t) {
            t = this._getSouthEast(t);
            return t ? new g(this._coordinates,t,this._getProjection()) : null
        }
        ,
        u._getSouthEast = function(t) {
            if (!t || !this._coordinates || V(this._width) || V(this._height))
                return null;
            var e, i = this.getWidth(), n = -this.getHeight();
            return t.fullExtent && (i *= (e = t.fullExtent).right > e.left ? 1 : -1,
                n *= e.top > e.bottom ? 1 : -1),
                t.locate(this._coordinates, i, n)
        }
        ,
        u._computeGeodesicLength = function() {
            return V(this._width) || V(this._height) ? 0 : 2 * (this._width + this._height)
        }
        ,
        u._computeGeodesicArea = function() {
            return V(this._width) || V(this._height) ? 0 : this._width * this._height
        }
        ,
        u._exportGeoJSONGeometry = function() {
            return {
                type: "Polygon",
                coordinates: M.toNumberArrays([this.getShell()])
            }
        }
        ,
        u._toJSON = function(t) {
            var t = m({}, t)
                , e = this.getCoordinates()
                , t = (t.geometry = !1,
                this.toGeoJSON(t));
            return t.geometry = {
                type: "Polygon"
            },
                {
                    feature: t,
                    subType: "Rectangle",
                    coordinates: [e.x, e.y],
                    width: this.getWidth(),
                    height: this.getHeight()
                }
        }
    ;
    var as, hs = ls;
    function ls(t, e, i, n) {
        n = as.call(this, null, n) || this;
        return t && n.setCoordinates(t),
            n._width = e,
            n._height = i,
            n
    }
    hs.registerJSONType("Rectangle");
    s(ds, us = is),
        ds.fromJSON = function(t) {
            var e = t.feature
                , t = new ds(t.coordinates,t.radius,t.startAngle,t.endAngle,t.options);
            return t.setProperties(e.properties),
                t
        }
        ,
        (u = ds.prototype).getStartAngle = function() {
            return this.startAngle
        }
        ,
        u.setStartAngle = function(t) {
            return this.startAngle = t,
                this.onShapeChanged(),
                this
        }
        ,
        u.getEndAngle = function() {
            return this.endAngle
        }
        ,
        u.setEndAngle = function(t) {
            return this.endAngle = t,
                this.onShapeChanged(),
                this
        }
        ,
        u.getShell = function() {
            for (var t = this._getMeasurer(), e = this.getCoordinates(), i = this.options.numberOfShellPoints - 2, n = this.getRadius(), r = [e.copy()], o = this.getStartAngle(), s = this.getEndAngle() - o, a = 0; a < i; a++) {
                var h = (s * a / (i - 1) + o) * Math.PI / 180
                    , l = n * Math.cos(h)
                    , h = n * Math.sin(h)
                    , l = t.locate(e, l, h);
                r.push(l)
            }
            return r.push(e.copy()),
                r
        }
        ,
        u._containsPoint = function(t, e) {
            var i = this.getMap();
            if (i.isTransforming())
                return us.prototype._containsPoint.call(this, t, e);
            var i = i._pointToContainerPoint(this._getCenter2DPoint())
                , e = V(e) ? this._hitTestTolerance() : e
                , n = this.getSize()
                , r = t.x - i.x
                , o = i.y - t.y
                , o = Math.atan2(o, r)
                , r = o < 0 ? 360 * (o + 2 * Math.PI) / (2 * Math.PI) : 360 * o / (2 * Math.PI)
                , o = this.startAngle % 360
                , s = this.endAngle % 360
                , a = !1
                , a = s < o ? !(s < r && r < o) : o <= r && r <= s;
            return t.distanceTo(i) <= n.width / 2 + e && a
        }
        ,
        u._computeGeodesicLength = function() {
            return V(this._radius) ? 0 : 2 * Math.PI * this._radius * Math.abs(this.startAngle - this.endAngle) / 360 + 2 * this._radius
        }
        ,
        u._computeGeodesicArea = function() {
            return V(this._radius) ? 0 : Math.PI * Math.pow(this._radius, 2) * Math.abs(this.startAngle - this.endAngle) / 360
        }
        ,
        u._toJSON = function(t) {
            var t = m({}, t)
                , e = this.getCenter()
                , t = (t.geometry = !1,
                this.toGeoJSON(t));
            return t.geometry = {
                type: "Polygon"
            },
                {
                    feature: t,
                    subType: "Sector",
                    coordinates: [e.x, e.y],
                    radius: this.getRadius(),
                    startAngle: this.getStartAngle(),
                    endAngle: this.getEndAngle()
                }
        }
    ;
    var us, cs = ds;
    function ds(t, e, i, n, r) {
        t = us.call(this, t, e, r) || this;
        return t.startAngle = i,
            t.endAngle = n,
            t
    }
    cs.mergeOptions({
        numberOfShellPoints: 60
    }),
        cs.registerJSONType("Sector");
    s(fs, gs = Io),
        (u = fs.prototype)._arc = function(t, e, i) {
            for (var n = this.options.arcDegree * Math.PI / 180, r = 1, o = e.length; r < o; r++) {
                var s = O._arcBetween(t, e[r - 1], e[r], n)
                    , s = [e[r - 1].x + e[r].x - s[0], e[r - 1].y + e[r].y - s[1]];
                e[r - 1].nextCtrlPoint = s,
                    e[r].prevCtrlPoint = s,
                    O._stroke(t, i)
            }
        }
        ,
        u._quadraticCurve = function(t, e) {
            if (e.length <= 2)
                O._path(t, e);
            else {
                for (var i = 2, n = e.length; i < n; i += 2)
                    t.quadraticCurveTo(e[i - 1].x, e[i - 1].y, e[i].x, e[i].y);
                if (--i < n)
                    for (; i < n; i++)
                        t.lineTo(e[i].x, e[i].y)
            }
        }
        ,
        u._bezierCurve = function(t, e) {
            if (e.length <= 3)
                O._path(t, e);
            else {
                for (var i = 1, n = e.length; i + 2 < n; i += 3)
                    t.bezierCurveTo(e[i].x, e[i].y, e[i + 1].x, e[i + 1].y, e[i + 2].x, e[i + 2].y);
                if (i < n)
                    for (; i < n; i++)
                        t.lineTo(e[i].x, e[i].y)
            }
        }
        ,
        u._getCurveArrowPoints = function(t, e, i, n, r, o) {
            for (var s = e.length, a = o; a < s; a += o) {
                var h = this._getArrowShape(e[a - 1], e[a], i, n, r);
                h && t.push(h)
            }
            if ((a -= o) < s - 1)
                for (a += 1; a < s; a++) {
                    var l = this._getArrowShape(e[a - 1], e[a], i, n, r);
                    l && t.push(l)
                }
        }
    ;
    var gs, ps = fs;
    function fs() {
        return gs.apply(this, arguments) || this
    }
    ps.mergeOptions({
        enableSimplify: !1,
        enableClip: !1
    });
    s(ys, ms = ps),
        (u = ys.prototype)._toJSON = function(t) {
            return {
                feature: this.toGeoJSON(t),
                subType: "ArcCurve"
            }
        }
        ,
        u._paintOn = function(t, e, i) {
            t.beginPath(),
                this._arc(t, e, i),
                O._stroke(t, i),
                this._paintArrow(t, e, i)
        }
        ,
        ys.fromJSON = function(t) {
            var e = t.feature
                , t = new ys(e.geometry.coordinates,t.options);
            return t.setProperties(e.properties),
                t
        }
    ;
    var ms, _s = ys;
    function ys() {
        return ms.apply(this, arguments) || this
    }
    _s.registerJSONType("ArcCurve"),
        _s.mergeOptions({
            arcDegree: 90
        });
    s(ws, vs = ps),
        ws.fromJSON = function(t) {
            var e = t.feature
                , t = new ws(e.geometry.coordinates,t.options);
            return t.setProperties(e.properties),
                t
        }
        ,
        (u = ws.prototype)._toJSON = function(t) {
            return {
                feature: this.toGeoJSON(t),
                subType: "CubicBezierCurve"
            }
        }
        ,
        u._paintOn = function(t, e, i) {
            t.beginPath(),
                t.moveTo(e[0].x, e[0].y),
                this._bezierCurve(t, e),
                O._stroke(t, i),
                this._paintArrow(t, e, i)
        }
        ,
        u._getArrowPoints = function(t, e, i, n, r) {
            return this._getCurveArrowPoints(t, e, i, n, r, 3)
        }
    ;
    var vs, xs = ws;
    function ws() {
        return vs.apply(this, arguments) || this
    }
    xs.registerJSONType("CubicBezierCurve");
    s(bs, Cs = ps),
        bs.fromJSON = function(t) {
            var e = t.feature
                , t = new bs(e.geometry.coordinates,t.options);
            return t.setProperties(e.properties),
                t
        }
        ,
        (u = bs.prototype)._toJSON = function(t) {
            return {
                feature: this.toGeoJSON(t),
                subType: "QuadBezierCurve"
            }
        }
        ,
        u._paintOn = function(t, e, i) {
            t.beginPath(),
                t.moveTo(e[0].x, e[0].y),
                this._quadraticCurve(t, e, i),
                O._stroke(t, i),
                this._paintArrow(t, e, i)
        }
        ,
        u._getArrowPoints = function(t, e, i, n, r) {
            return this._getCurveArrowPoints(t, e, i, n, r, 2)
        }
    ;
    var Cs, Ps = bs;
    function bs() {
        return Cs.apply(this, arguments) || this
    }
    Ps.registerJSONType("QuadBezierCurve");
    var Ms, Ss = {
        textFaceName: "monospace",
        textSize: 12,
        textLineSpacing: 8,
        textWrapCharacter: "\n",
        textHorizontalAlignment: "middle",
        textVerticalAlignment: "middle"
    }, Ts = {
        markerType: "square",
        markerLineColor: "#000",
        markerLineWidth: 2,
        markerLineOpacity: 1,
        markerFill: "#fff",
        markerOpacity: 1
    }, u = (s(Es, Ms = Ao),
        (u = Es.prototype).getContent = function() {
            return this._content
        }
        ,
        u.setContent = function(t) {
            var e = this._content;
            return this._content = je(t),
                this._refresh(),
                this._fireEvent("contentchange", {
                    old: e,
                    new: t
                }),
                this
        }
        ,
        u.onAdd = function() {
            this._refresh()
        }
        ,
        u.toJSON = function() {
            var t = Ms.prototype.toJSON.call(this);
            return delete t.symbol,
                t
        }
        ,
        u.setSymbol = function(t) {
            if (this._refreshing || !t)
                return Ms.prototype.setSymbol.call(this, t);
            var e, t = this._parseSymbol(t);
            return this.setTextStyle ? ((e = this.getTextStyle() || {}).symbol = t[0],
                this.setTextStyle(e)) : this.setTextSymbol && this.setTextSymbol(t[0]),
                this.setBoxStyle ? ((e = this.getBoxStyle() || {}).symbol = t[1],
                    this.setBoxStyle(e)) : this.setBoxSymbol && this.setBoxSymbol(t[1]),
                this
        }
        ,
        u._parseSymbol = function(t) {
            var e, i = {}, n = {};
            for (e in t)
                J(t, e) && (0 === e.indexOf("text") ? i[e] = t[e] : n[e] = t[e]);
            return [i, n]
        }
        ,
        u._getTextSize = function(t) {
            return Ue(this._content, t).size
        }
        ,
        u._getInternalSymbol = function() {
            return this._symbol
        }
        ,
        u._getDefaultTextSymbol = function() {
            return m({}, Ss)
        }
        ,
        u._getDefaultBoxSymbol = function() {
            return m({}, Ts)
        }
        ,
        u._getDefaultPadding = function() {
            return [12, 8]
        }
        ,
        Es);
    function Es() {
        return Ms.apply(this, arguments) || this
    }
    s(As, ks = u),
        (d = As.prototype).getWidth = function() {
            return this._width
        }
        ,
        d.setWidth = function(t) {
            return this._width = t,
                this._refresh(),
                this
        }
        ,
        d.getHeight = function() {
            return this._height
        }
        ,
        d.setHeight = function(t) {
            return this._height = t,
                this._refresh(),
                this
        }
        ,
        d.getBoxSymbol = function() {
            return m({}, this.options.boxSymbol)
        }
        ,
        d.setBoxSymbol = function(t) {
            return this.options.boxSymbol = t && m({}, t),
            this.getSymbol() && this._refresh(),
                this
        }
        ,
        d.getTextStyle = function() {
            return this.options.textStyle ? m({}, this.options.textStyle) : null
        }
        ,
        d.setTextStyle = function(t) {
            return this.options.textStyle = t && m({}, t),
            this.getSymbol() && this._refresh(),
                this
        }
        ,
        As.fromJSON = function(t) {
            var e = t.feature
                , i = new As(t.content,e.geometry.coordinates,t.width,t.height,t.options);
            return i.setProperties(e.properties),
                i.setId(e.id),
            t.symbol && i.setSymbol(t.symbol),
                i
        }
        ,
        d._toJSON = function(t) {
            return {
                feature: this.toGeoJSON(t),
                width: this.getWidth(),
                height: this.getHeight(),
                subType: "TextBox",
                content: this._content
            }
        }
        ,
        d._refresh = function() {
            var t = this.getTextStyle() || {}
                , e = t.padding || [12, 8]
                , i = this._width - 2 * e[0]
                , n = this._height - 2 * e[1]
                , n = m({}, t.symbol || this._getDefaultTextSymbol(), this.options.boxSymbol || this._getDefaultBoxSymbol(), {
                textName: this._content,
                markerWidth: this._width,
                markerHeight: this._height,
                textHorizontalAlignment: "middle",
                textVerticalAlignment: "middle",
                textMaxWidth: i,
                textMaxHeight: n
            })
                , i = (t.wrap && !n.textWrapWidth && (n.textWrapWidth = i),
                t.horizontalAlignment)
                , r = (n.textDx = n.markerDx || 0,
            n.markerWidth / 2 - e[0])
                , i = ("left" === i ? (n.textHorizontalAlignment = "right",
                n.textDx = n.textDx - r) : "right" === i && (n.textHorizontalAlignment = "left",
                n.textDx = n.textDx + r),
                t.verticalAlignment)
                , r = (n.textDy = n.markerDy || 0,
            n.markerHeight / 2 - e[1]);
            "top" === i ? (n.textVerticalAlignment = "bottom",
                n.textDy -= r) : "bottom" === i && (n.textVerticalAlignment = "top",
                n.textDy += r),
                this._refreshing = !0,
                this.updateSymbol(n),
                delete this._refreshing
        }
    ;
    var ks, Rs = As;
    function As(t, e, i, n, r) {
        return (e = ks.call(this, e, r = void 0 === r ? {} : r) || this)._content = je(t),
            e._width = V(i) ? 100 : i,
            e._height = V(n) ? 40 : n,
        r.boxSymbol && e.setBoxSymbol(r.boxSymbol),
        r.textStyle && e.setTextStyle(r.textStyle),
            e._refresh(),
            e
    }
    Rs.mergeOptions({
        textStyle: {
            wrap: !0,
            padding: [12, 8],
            verticalAlignment: "middle",
            horizontalAlignment: "middle"
        },
        boxSymbol: null
    }),
        Rs.registerJSONType("TextBox");
    s(Ds, Ls = u),
        (d = Ds.prototype).getBoxStyle = function() {
            return this.options.boxStyle ? m({}, this.options.boxStyle) : null
        }
        ,
        d.setBoxStyle = function(t) {
            return this.options.boxStyle = t && m({}, t),
                this._refresh(),
                this
        }
        ,
        d.getTextSymbol = function() {
            return m({}, this._getDefaultTextSymbol(), this.options.textSymbol)
        }
        ,
        d.setTextSymbol = function(t) {
            return this.options.textSymbol = t && m({}, t),
                this._refresh(),
                this
        }
        ,
        Ds.fromJSON = function(t) {
            var e = t.feature
                , i = new Ds(t.content,e.geometry.coordinates,t.options);
            return i.setProperties(e.properties),
                i.setId(e.id),
            t.symbol && i.setSymbol(t.symbol),
                i
        }
        ,
        d._canEdit = function() {
            return !1
        }
        ,
        d._toJSON = function(t) {
            return {
                feature: this.toGeoJSON(t),
                subType: "Label",
                content: this._content
            }
        }
        ,
        d._refresh = function() {
            var t, e, i, n, r = m({}, this.getTextSymbol(), {
                textName: this._content
            }), o = this.getBoxStyle();
            o && (m(r, o.symbol),
                t = (i = this._getBoxSize(r))[1],
                e = o.padding || this._getDefaultPadding(),
                i = i[0],
                r.markerWidth = i.width,
                r.markerHeight = i.height,
                i = r.textDx || 0,
                n = r.textDy || 0,
                i = Be(t, r.textHorizontalAlignment, r.textVerticalAlignment)._add(i, n),
                n = o.horizontalAlignment || "middle",
                r.markerDx = i.x,
                "left" === n ? r.markerDx += r.markerWidth / 2 - e[0] : "right" === n ? r.markerDx -= r.markerWidth / 2 - t.width - e[0] : r.markerDx += t.width / 2,
                n = o.verticalAlignment || "middle",
                r.markerDy = i.y,
                "top" === n ? r.markerDy += r.markerHeight / 2 - e[1] : "bottom" === n ? r.markerDy -= r.markerHeight / 2 - t.height - e[1] : r.markerDy += t.height / 2),
                this._refreshing = !0,
                this.updateSymbol(r),
                delete this._refreshing
        }
        ,
        d._getBoxSize = function(t) {
            t.markerType || (t.markerType = "square");
            var e = this.getBoxStyle()
                , t = this._getTextSize(t)
                , i = e.padding || this._getDefaultPadding()
                , n = t.width + 2 * i[0]
                , i = t.height + 2 * i[1];
            return e.minWidth && (!n || n < e.minWidth) && (n = e.minWidth),
            e.minHeight && (!i || i < e.minHeight) && (i = e.minHeight),
                [new Le(n,i), t]
        }
    ;
    var Ls, Os = Ds;
    function Ds(t, e, i) {
        e = Ls.call(this, e, i = void 0 === i ? {} : i) || this;
        return i.textSymbol && e.setTextSymbol(i.textSymbol),
        i.boxStyle && e.setBoxStyle(i.boxStyle),
            e._content = je(t),
            e._refresh(),
            e
    }
    Os.mergeOptions({
        boxStyle: null,
        textSymbol: null
    }),
        Os.registerJSONType("Label");
    function Is(t) {
        return s(e, i = t),
            e._hasConnectors = function(t) {
                return !V(t.__connectors) && 0 < t.__connectors.length
            }
            ,
            e._getConnectors = function(t) {
                return t.__connectors
            }
            ,
            (t = e.prototype).getConnectSource = function() {
                return this._connSource
            }
            ,
            t.setConnectSource = function(t) {
                var e = this._connTarget;
                return this.onRemove(),
                    this._connSource = t,
                    this._connTarget = e,
                    this.onAdd(),
                    this
            }
            ,
            t.getConnectTarget = function() {
                return this._connTarget
            }
            ,
            t.setConnectTarget = function(t) {
                var e = this._connSource;
                return this.onRemove(),
                    this._connSource = e,
                    this._connTarget = t,
                    this._updateCoordinates(),
                    this._registerEvents(),
                    this
            }
            ,
            t._updateCoordinates = function() {
                var t = this.getMap();
                if ((t = !(t = !t && this._connSource ? this._connSource.getMap() : t) && this._connTarget ? this._connTarget.getMap() : t) && this._connSource && this._connTarget) {
                    for (var e, i, n = this._connSource._getConnectPoints(), r = this._connTarget._getConnectPoints(), o = 0, s = this.getCoordinates(), a = 0, h = n.length; a < h; a++)
                        for (var l = n[a], u = 0, c = r.length; u < c; u++) {
                            var d = r[u]
                                , g = t.computeLength(l, d);
                            0 === a && 0 === u ? (e = l,
                                i = d,
                                o = g) : g < o && (e = l,
                                i = d)
                        }
                    L(s) && s[0].equals(e) && s[1].equals(i) || this.setCoordinates([e, i])
                }
            }
            ,
            t.onAdd = function() {
                this._registerEvents(),
                    this._updateCoordinates()
            }
            ,
            t.onRemove = function() {
                var t;
                this._connSource && (this._connSource.__connectors && st(this, this._connSource.__connectors),
                    this._connSource.off("dragging positionchange", this._updateCoordinates, this).off("remove", this.onRemove, this),
                    this._connSource.off("dragstart mousedown mouseover", this._showConnect, this),
                    this._connSource.off("dragend mouseup mouseout", this.hide, this),
                    this._connSource.off("show", this._showConnect, this).off("hide", this.hide, this),
                    delete this._connSource),
                this._connTarget && (st(this, this._connTarget.__connectors),
                    this._connTarget.off("dragging positionchange", this._updateCoordinates, this).off("remove", this.onRemove, this),
                    this._connTarget.off("show", this._showConnect, this).off("hide", this.hide, this),
                    delete this._connTarget),
                this._connSource instanceof y && this._connTarget instanceof y || (t = this.getMap()) && t.off("movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange", this._updateCoordinates, this)
            }
            ,
            t._showConnect = function() {
                this._connSource && this._connTarget && this._connSource.isVisible() && this._connTarget.isVisible() && (this._updateCoordinates(),
                    this.show())
            }
            ,
            t._registerEvents = function() {
                var t;
                this._connSource && this._connTarget && (this._connSource.__connectors || (this._connSource.__connectors = []),
                this._connTarget.__connectors || (this._connTarget.__connectors = []),
                    this._connSource.__connectors.push(this),
                    this._connTarget.__connectors.push(this),
                    this._connSource.on("dragging positionchange", this._updateCoordinates, this).on("remove", this.remove, this),
                    this._connTarget.on("dragging positionchange", this._updateCoordinates, this).on("remove", this.remove, this),
                    this._connSource.on("show", this._showConnect, this).on("hide", this.hide, this),
                    this._connTarget.on("show", this._showConnect, this).on("hide", this.hide, this),
                    t = this.options.showOn,
                    this.hide(),
                    "moving" === t ? (this._connSource.on("dragstart", this._showConnect, this).on("dragend", this.hide, this),
                        this._connTarget.on("dragstart", this._showConnect, this).on("dragend", this.hide, this)) : "click" === t ? (this._connSource.on("mousedown", this._showConnect, this).on("mouseup", this.hide, this),
                        this._connTarget.on("mousedown", this._showConnect, this).on("mouseup", this.hide, this)) : "mouseover" === t ? (this._connSource.on("mouseover", this._showConnect, this).on("mouseout", this.hide, this),
                        this._connTarget.on("mouseover", this._showConnect, this).on("mouseout", this.hide, this)) : this._showConnect(),
                this._connSource instanceof y && this._connTarget instanceof y || (t = this.getMap()) && t.on("movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange", this._updateCoordinates, this))
            }
            ,
            e;
        function e() {
            return i.apply(this, arguments) || this
        }
        var i
    }
    var js, d = {
        showOn: "always"
    }, zs = (s(Zs, js = Is(Io)),
        Zs);
    function Zs(t, e, i) {
        var n = js.call(this, null, i) || this;
        return 1 === arguments.length && (i = t,
            e = t = null),
            n._connSource = t,
            n._connTarget = e,
            n
    }
    zs.mergeOptions(d),
        zs.registerJSONType("ConnectorLine");
    s(Fs, Hs = Is(_s));
    var Hs, Gs = Fs;
    function Fs(t, e, i) {
        var n = Hs.call(this, null, i) || this;
        return 1 === arguments.length && (i = t,
            e = t = null),
            n._connSource = t,
            n._connTarget = e,
            n
    }
    Gs.mergeOptions(d),
        Gs.registerJSONType("ArcConnectorLine");
    s(Ws, Ns = kr),
        (d = Ws.prototype).getGeometryById = function(t) {
            return !V(t) && "" !== t && this._geoMap[t] || null
        }
        ,
        d.getGeometries = function(t, e) {
            if (!t)
                return this._geoList.slice(0);
            for (var i, n = [], r = 0, o = this._geoList.length; r < o; r++)
                i = this._geoList[r],
                (e ? t.call(e, i) : t(i)) && n.push(i);
            return n
        }
        ,
        d.getFirstGeometry = function() {
            return this._geoList.length ? this._geoList[0] : null
        }
        ,
        d.getLastGeometry = function() {
            var t = this._geoList.length;
            return 0 === t ? null : this._geoList[t - 1]
        }
        ,
        d.getCount = function() {
            return this._geoList.length
        }
        ,
        d.getExtent = function() {
            if (0 === this.getCount())
                return null;
            var e = new g(this.getProjection());
            return this.forEach(function(t) {
                e._combine(t.getExtent())
            }),
                e
        }
        ,
        d.forEach = function(t, e) {
            for (var i = this._geoList.slice(0), n = 0, r = i.length; n < r; n++)
                e ? t.call(e, i[n], n) : t(i[n], n);
            return this
        }
        ,
        d.filter = function(t, i) {
            var n = []
                , r = p(t)
                , o = r ? t : St(t);
            return this.forEach(function(t) {
                var e = r ? t : It(t);
                (i ? o.call(i, e) : o(e)) && n.push(t)
            }, this),
                n
        }
        ,
        d.isEmpty = function() {
            return !this._geoList.length
        }
        ,
        d.addGeometry = function(t, e) {
            if (!t)
                return this;
            if ("FeatureCollection" === t.type)
                return this.addGeometry(es.toGeometry(t), e);
            var i;
            if (!Array.isArray(t))
                return l = arguments[(d = arguments.length) - 1],
                    t = Array.prototype.slice.call(arguments, 0, d - 1),
                (e = l) && W(l) && ("type"in l || l instanceof y) && (t.push(l),
                    e = !1),
                    this.addGeometry(t, e);
            if (0 === t.length)
                return this;
            this._initCache(),
            e && (i = new g),
                this._toSort = 0 < this._maxZIndex;
            for (var n = [], r = 0, o = t.length; r < o; r++) {
                var s = t[r];
                if (!s)
                    throw new Error("Invalid geometry to add to layer(" + this.getId() + ") at index:" + r);
                if (!(s instanceof y) && (s = y.fromJSON(s),
                    Array.isArray(s)))
                    for (var a = 0, h = s.length; a < h; a++)
                        this._add(s[a], i, r),
                            n.push(s[a]);
                Array.isArray(s) || (this._add(s, i, r),
                    n.push(s))
            }
            var l, u, c, d = this.getMap();
            return d && (this._getRenderer().onGeometryAdd(n),
            i && !V(i.xmin) && (l = i.getCenter(),
                u = d.getFitZoom(i),
                W(e) ? (c = p(e.step) ? e.step : function() {}
                    ,
                    d.animateTo({
                        center: l,
                        zoom: u
                    }, m({
                        duration: d.options.zoomAnimationDuration,
                        easing: "out"
                    }, e), c)) : !0 === e && d.setCenterAndZoom(l, u))),
                this.fire("addgeo", {
                    geometries: t
                }),
                this
        }
        ,
        d.getGeoMinZIndex = function() {
            return this._minZIndex
        }
        ,
        d.getGeoMaxZIndex = function() {
            return this._maxZIndex
        }
        ,
        d._add = function(t, e, i) {
            this._toSort || (this._toSort = 0 !== t.getZIndex()),
                this._updateZIndex(t.getZIndex());
            var n = t.getId();
            if (!V(n)) {
                if (!V(this._geoMap[n]))
                    throw new Error("Duplicate geometry id in layer(" + this.getId() + "):" + n + ", at index:" + i);
                this._geoMap[n] = t
            }
            i = it++;
            t._setInternalId(i),
                this._geoList.push(t),
                this.onAddGeometry(t),
                t._bindLayer(this),
            t.onAdd && t.onAdd(),
            e && e._combine(t.getExtent()),
                t._fireEvent("add", {
                    layer: this
                }),
            this._cookedStyles && this._styleGeometry(t)
        }
        ,
        d.removeGeometry = function(t) {
            if (!Array.isArray(t))
                return this.removeGeometry([t]);
            for (var e = t.length - 1; 0 <= e; e--)
                t[e]instanceof y || (t[e] = this.getGeometryById(t[e])),
                t[e] && this === t[e].getLayer() && t[e].remove();
            return this.fire("removegeo", {
                geometries: t
            }),
                this
        }
        ,
        d.clear = function() {
            this._clearing = !0,
                this.forEach(function(t) {
                    t.remove()
                }),
                this._geoMap = {};
            var t = this._geoList;
            return this._geoList = [],
            this._getRenderer() && this._getRenderer().onGeometryRemove(t),
                this._clearing = !1,
                this.fire("clear"),
                this
        }
        ,
        d.onRemoveGeometry = function(t) {
            var e;
            !t || this._clearing || this !== t.getLayer() || V(t._getInternalId()) || (V(e = t.getId()) || delete this._geoMap[e],
            0 <= (e = this._findInList(t)) && this._geoList.splice(e, 1),
            this._getRenderer() && this._getRenderer().onGeometryRemove([t]))
        }
        ,
        d.getStyle = function() {
            return this.options.style || null
        }
        ,
        d.setStyle = function(t) {
            return t = oe(this.options.style = t),
                this._cookedStyles = jt(t),
                this.forEach(function(t) {
                    this._styleGeometry(t)
                }, this),
                this.fire("setstyle", {
                    style: t
                }),
                this
        }
        ,
        d._styleGeometry = function(t) {
            if (!this._cookedStyles)
                return !1;
            for (var e = It(t), i = 0, n = this._cookedStyles.length; i < n; i++)
                if (!0 === this._cookedStyles[i].filter(e))
                    return t._setExternSymbol(this._cookedStyles[i].symbol),
                        !0;
            return !1
        }
        ,
        d.removeStyle = function() {
            return this.options.style && (delete this.options.style,
                delete this._cookedStyles,
                this.forEach(function(t) {
                    t._setExternSymbol(null)
                }, this),
                this.fire("removestyle")),
                this
        }
        ,
        d.onAddGeometry = function(t) {
            this.getStyle() && this._styleGeometry(t)
        }
        ,
        d.hide = function() {
            for (var t = 0, e = this._geoList.length; t < e; t++)
                this._geoList[t].onHide();
            return kr.prototype.hide.call(this)
        }
        ,
        d._initCache = function() {
            this._geoList || (this._geoList = [],
                this._geoMap = {})
        }
        ,
        d._updateZIndex = function() {
            for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
                e[i] = arguments[i];
            this._maxZIndex = Math.max(this._maxZIndex, Math.max.apply(Math, e)),
                this._minZIndex = Math.min(this._minZIndex, Math.min.apply(Math, e))
        }
        ,
        d._sortGeometries = function() {
            var i = this;
            this._toSort && (this._maxZIndex = 0,
                this._minZIndex = 0,
                this._geoList.sort(function(t, e) {
                    return i._updateZIndex(t.getZIndex(), e.getZIndex()),
                        i._compare(t, e)
                }),
                this._toSort = !1)
        }
        ,
        d._compare = function(t, e) {
            return t.getZIndex() === e.getZIndex() ? t._getInternalId() - e._getInternalId() : t.getZIndex() - e.getZIndex()
        }
        ,
        d._findInList = function(t) {
            var e = this._geoList.length;
            if (0 === e)
                return -1;
            for (var i, n = 0, r = e - 1; n <= r; ) {
                if (i = Math.floor((n + r) / 2),
                this._geoList[i] === t)
                    return i;
                0 < this._compare(this._geoList[i], t) ? r = i - 1 : n = i + 1
            }
            return -1
        }
        ,
        d._onGeometryEvent = function(t) {
            var e;
            t && t.target && ("idchange" === (e = t.type) ? this._onGeometryIdChange(t) : "zindexchange" === e ? this._onGeometryZIndexChange(t) : "positionchange" === e ? this._onGeometryPositionChange(t) : "shapechange" === e ? this._onGeometryShapeChange(t) : "symbolchange" === e ? this._onGeometrySymbolChange(t) : "show" === e ? this._onGeometryShow(t) : "hide" === e ? this._onGeometryHide(t) : "propertieschange" === e && this._onGeometryPropertiesChange(t))
        }
        ,
        d._onGeometryIdChange = function(t) {
            if (t.new !== t.old || !this._geoMap[t.old] || this._geoMap[t.old] !== t.target) {
                if (!V(t.new)) {
                    if (this._geoMap[t.new])
                        throw new Error("Duplicate geometry id in layer(" + this.getId() + "):" + t.new);
                    this._geoMap[t.new] = t.target
                }
                V(t.old) || t.new === t.old || delete this._geoMap[t.old]
            }
        }
        ,
        d._onGeometryZIndexChange = function(t) {
            t.old !== t.new && (this._updateZIndex(t.new),
                this._toSort = !0,
            this._getRenderer() && this._getRenderer().onGeometryZIndexChange(t))
        }
        ,
        d._onGeometryPositionChange = function(t) {
            this._getRenderer() && this._getRenderer().onGeometryPositionChange(t)
        }
        ,
        d._onGeometryShapeChange = function(t) {
            this._getRenderer() && this._getRenderer().onGeometryShapeChange(t)
        }
        ,
        d._onGeometrySymbolChange = function(t) {
            this._getRenderer() && this._getRenderer().onGeometrySymbolChange(t)
        }
        ,
        d._onGeometryShow = function(t) {
            this._getRenderer() && this._getRenderer().onGeometryShow(t)
        }
        ,
        d._onGeometryHide = function(t) {
            this._getRenderer() && this._getRenderer().onGeometryHide(t)
        }
        ,
        d._onGeometryPropertiesChange = function(t) {
            this._getRenderer() && this._getRenderer().onGeometryPropertiesChange(t)
        }
    ;
    var Ns, d = Ws;
    function Ws(t, e, i) {
        e && !(e instanceof y) && !Array.isArray(e) && j.indexOf(e.type) < 0 && (i = e,
            e = null),
            (t = Ns.call(this, t, i) || this)._maxZIndex = 0,
            t._minZIndex = 0,
            t._initCache(),
        e && t.addGeometry(e);
        i = t.options.style;
        return i && t.setStyle(i),
            t
    }
    d.mergeOptions({
        drawImmediate: !1
    });
    var Bs, Vs = new U, v = {
        debug: !1,
        enableSimplify: !0,
        geometryEvents: !0,
        defaultIconSize: [20, 20],
        cacheVectorOnCanvas: !0,
        cacheSvgOnCanvas: c.gecko,
        enableAltitude: !1,
        altitudeProperty: "altitude",
        drawAltitude: !1,
        altitude: 0
    }, Us = (s(Js, Bs = d),
        (x = Js.prototype).onConfig = function(t) {
            Bs.prototype.onConfig.call(this, t),
            (t.enableAltitude || t.drawAltitude || t.altitudeProperty) && (t = this.getRenderer()) && t.setToRedraw && t.setToRedraw()
        }
        ,
        x.identify = function(t, e) {
            void 0 === e && (e = {});
            var i = this.getRenderer();
            return e.onlyVisible && i && i.identify ? i.identify(t, e) : (t instanceof M || (t = new M(t)),
                this._hitGeos(this._geoList, t, e))
        }
        ,
        x._hitGeos = function(t, e, i) {
            for (var n = (i = void 0 === i ? {} : i).filter, r = i.tolerance, o = [], s = this.getMap(), e = s.coordToPoint(e), a = s._pointToContainerPoint(e, void 0, 0, e), h = t.length - 1; 0 <= h; h--) {
                var l = t[h];
                if (l && l.isVisible() && l._getPainter() && l.options.interactive) {
                    if (!(l instanceof Io && (l._getArrowStyle() || l instanceof ps))) {
                        var u = l.getContainerExtent(Vs);
                        if (!(u = r ? u._expand(r) : u) || !u.contains(a))
                            continue
                    }
                    if (l._containsPoint(a, r) && (!n || n(l)) && (o.push(l),
                    i.count && o.length >= i.count))
                        break
                }
            }
            return o
        }
        ,
        x.getAltitude = function() {
            return this.options.altitude || 0
        }
        ,
        x.toJSON = function(t) {
            t = t || {};
            var e = {
                type: this.getJSONType(),
                id: this.getId(),
                options: this.config()
            };
            if (V(t.geometries) || t.geometries) {
                t.clipExtent && (i = (i = this.getMap()) ? i.getProjection() : null,
                    n = new g(t.clipExtent,i));
                for (var i, n, r = [], o = this.getGeometries(), s = 0, a = o.length; s < a; s++) {
                    var h = o[s]
                        , l = h.getExtent();
                    !l || n && !n.intersects(l) || (l = h.toJSON(t.geometries),
                        r.push(l))
                }
                e.geometries = r
            }
            return e
        }
        ,
        Js.fromJSON = function(t) {
            if (!t || "VectorLayer" !== t.type)
                return null;
            for (var e = new Js(t.id,t.options), i = t.geometries, n = [], r = 0; r < i.length; r++) {
                var o = y.fromJSON(i[r]);
                o && n.push(o)
            }
            return e.addGeometry(n),
                e
        }
        ,
        Js.getPainterClass = function() {
            return _r
        }
        ,
        Js.getCollectionPainterClass = function() {
            return wr
        }
        ,
        Js);
    function Js(t, e, i) {
        return Bs.call(this, t, e, i) || this
    }
    Us.mergeOptions(v),
        Us.registerJSONType("VectorLayer");
    var qs, Ys = "_map_tool", Xs = (s(Ks, qs = Si(_e)),
        (x = Ks.prototype).addTo = function(t) {
            return t && ((this._map = t)[Ys] && t[Ys].disable(),
            this.onAdd && this.onAdd(),
                this.enable(),
                (t[Ys] = this)._fireEvent("add")),
                this
        }
        ,
        x.getMap = function() {
            return this._map
        }
        ,
        x.enable = function() {
            return !this._map || this._enabled || (this._enabled = !0,
                this._switchEvents("off"),
                this._registerEvents(),
            this.onEnable && this.onEnable(),
                this._fireEvent("enable")),
                this
        }
        ,
        x.disable = function() {
            return this._enabled && this._map && (this._enabled = !1,
                this._switchEvents("off"),
            this.onDisable && this.onDisable(),
                this._fireEvent("disable")),
                this
        }
        ,
        x.isEnabled = function() {
            return !!this._enabled
        }
        ,
        x.remove = function() {
            return this._map && (this.disable(),
            this._map && (delete this._map[Ys],
                delete this._map),
                this._fireEvent("remove")),
                this
        }
        ,
        x._registerEvents = function() {
            this._switchEvents("on")
        }
        ,
        x._switchEvents = function(t) {
            var e = this.getEvents();
            e && this._map[t](e, this)
        }
        ,
        x._fireEvent = function(t, e) {
            this.fire(t, e = e || {})
        }
        ,
        Ks);
    function Ks() {
        return qs.apply(this, arguments) || this
    }
    var Qs, $s = {}, ta = (s(ea, Qs = Xs),
        ea.registerMode = function(t, e) {
            $s[t.toLowerCase()] = e
        }
        ,
        ea.getRegisterMode = function(t) {
            return $s[t.toLowerCase()]
        }
        ,
        (v = ea.prototype).getMode = function() {
            return this.options.mode ? this.options.mode.toLowerCase() : null
        }
        ,
        v.setMode = function(t) {
            return this._geometry && (this._geometry.remove(),
                delete this._geometry),
                this._clearStage(),
                this._switchEvents("off"),
                this.options.mode = t,
                this._checkMode(),
            this.isEnabled() && (this._switchEvents("on"),
                this._restoreMapCfg(),
                this._saveMapCfg()),
                this
        }
        ,
        v.getSymbol = function() {
            var t = this.options.symbol;
            return re(t || this.options.symbol)
        }
        ,
        v.setSymbol = function(t) {
            return t && (this.options.symbol = t,
            this._geometry && this._geometry.setSymbol(t)),
                this
        }
        ,
        v.getCurrentGeometry = function() {
            return this._geometry
        }
        ,
        v.onAdd = function() {
            this._checkMode()
        }
        ,
        v.onEnable = function() {
            var t;
            return this._saveMapCfg(),
                this._drawToolLayer = this._getDrawLayer(),
                this._clearStage(),
                this._loadResources(),
            this.options.autoPanAtEdge && (t = this.getMap(),
                this._mapAutoPanAtEdge = t.options.autoPanAtEdge,
            this._mapAutoPanAtEdge || t.config({
                autoPanAtEdge: !0
            })),
                this
        }
        ,
        v.onDisable = function() {
            var t = this.getMap();
            return this._restoreMapCfg(),
                this.endDraw(),
            this._map && (t.removeLayer(this._getDrawLayer()),
            this.options.autoPanAtEdge && !this._mapAutoPanAtEdge && t.config({
                autoPanAtEdge: !1
            })),
                this
        }
        ,
        v.undo = function() {
            var t = this._getRegisterMode()
                , e = t.action;
            if (!this._shouldRecordHistory(e) || !this._historyPointer)
                return this;
            e = this._clickCoords.slice(0, --this._historyPointer);
            return t.update(this.getMap().getProjection(), e, this._geometry),
                this
        }
        ,
        v.redo = function() {
            var t = this._getRegisterMode()
                , e = t.action;
            if (!this._shouldRecordHistory(e) || V(this._historyPointer) || this._historyPointer === this._clickCoords.length)
                return this;
            e = this._clickCoords.slice(0, ++this._historyPointer);
            return t.update(this.getMap().getProjection(), e, this._geometry),
                this
        }
        ,
        v._shouldRecordHistory = function(t) {
            return Array.isArray(t) && "click" === t[0] && "mousemove" === t[1] && "dblclick" === t[2]
        }
        ,
        v._checkMode = function() {
            this._getRegisterMode()
        }
        ,
        v._saveMapCfg = function() {
            var t = this.getMap();
            this._mapDoubleClickZoom = t.options.doubleClickZoom,
                t.config({
                    doubleClickZoom: this.options.doubleClickZoom
                }),
            -1 < this._getRegisterMode().action.indexOf("mousedown") && (t = this.getMap(),
                this._mapDraggable = t.options.draggable,
                t.config({
                    draggable: !1
                }))
        }
        ,
        v._restoreMapCfg = function() {
            var t = this.getMap();
            t.config({
                doubleClickZoom: this._mapDoubleClickZoom
            }),
            V(this._mapDraggable) || t.config("draggable", this._mapDraggable),
                delete this._mapDraggable,
                delete this._mapDoubleClickZoom
        }
        ,
        v._loadResources = function() {
            var t = Qt(this.getSymbol());
            0 < t.length && this._drawToolLayer._getRenderer().loadResources(t)
        }
        ,
        v._getProjection = function() {
            return this._map.getProjection()
        }
        ,
        v._getRegisterMode = function() {
            var t = this.getMode()
                , e = ea.getRegisterMode(t);
            if (e)
                return e;
            throw new Error(t + " is not a valid mode of DrawTool.")
        }
        ,
        v.getEvents = function() {
            var t = this._getRegisterMode().action
                , e = {};
            if (Array.isArray(t)) {
                for (var i = 0; i < t.length; i++)
                    e[t[i]] = this._events[t[i]];
                return e
            }
            return null
        }
        ,
        v._mouseDownHandler = function(t) {
            this._createGeometry(t)
        }
        ,
        v._mouseUpHandler = function(t) {
            this.endDraw(t)
        }
        ,
        v._clickHandler = function(t) {
            var e = this._getRegisterMode();
            if (this._clickCoords && this._clickCoords.length) {
                var i = this._clickCoords.length
                    , n = this.getMap()._pointToPrj(t.point2d);
                if (this._clickCoords[i - 1].equals(n))
                    return
            }
            this._geometry ? (i = this.getMap()._pointToPrj(t.point2d),
            V(this._historyPointer) || (this._clickCoords = this._clickCoords.slice(0, this._historyPointer)),
                this._clickCoords.push(i),
                this._historyPointer = this._clickCoords.length,
                t.drawTool = this,
                e.update(this.getMap().getProjection(), this._clickCoords, this._geometry, t),
                this._fireEvent("drawvertex", t),
            e.clickLimit && e.clickLimit === this._historyPointer && this.endDraw(t)) : this._createGeometry(t)
        }
        ,
        v._createGeometry = function(t) {
            var e = this.getMode()
                , i = this._getRegisterMode()
                , n = this.getMap()._pointToPrj(t.point2d)
                , r = this.getSymbol();
            this._geometry || (this._clickCoords = [n],
                (t.drawTool = this)._geometry = i.create(this.getMap().getProjection(), this._clickCoords, t),
                r && "point" !== e ? this._geometry.setSymbol(r) : this.options.hasOwnProperty("symbol") && this._geometry.setSymbol(this.options.symbol),
                this._addGeometryToStage(this._geometry),
                this._fireEvent("drawstart", t)),
            "point" === e && this.endDraw(t)
        }
        ,
        v._mouseMoveHandler = function(t) {
            var e = this.getMap();
            if (this._geometry && e && !e.isInteracting()) {
                var i = this._getMouseContainerPoint(t);
                if (this._isValidContainerPoint(i)) {
                    var i = this.getMap()._pointToPrj(t.point2d)
                        , e = e.getProjection()
                        , n = (t.drawTool = this)._getRegisterMode();
                    if (this._shouldRecordHistory(n.action)) {
                        var r = this._clickCoords.slice(0, this._historyPointer);
                        if (r && 0 < r.length && i.equals(r[r.length - 1]))
                            return;
                        n.update(e, r.concat([i]), this._geometry, t)
                    } else
                        n.update(e, i, this._geometry, t);
                    this._fireEvent("mousemove", t)
                }
            }
        }
        ,
        v._doubleClickHandler = function(t) {
            if (this._geometry) {
                var e = this._getMouseContainerPoint(t);
                if (this._isValidContainerPoint(e)) {
                    var e = this._getRegisterMode()
                        , i = this._clickCoords;
                    if (!(i.length < 2)) {
                        var n = this.getMode();
                        if (!(n && -1 < n.indexOf("polygon") && i.length < 3)) {
                            for (var n = this.getMap().getProjection(), r = [i[0]], o = 1, s = i.length; o < s; o++)
                                i[o].x === i[o - 1].x && i[o].y === i[o - 1].y || r.push(i[o]);
                            r.length < 2 || this._geometry && this._geometry instanceof S && r.length < 3 || (t.drawTool = this,
                                e.update(n, r, this._geometry, t),
                                this.endDraw(t))
                        }
                    }
                }
            }
        }
        ,
        v._addGeometryToStage = function(t) {
            this._getDrawLayer().addGeometry(t)
        }
        ,
        v.endDraw = function(t) {
            if (!this._geometry || this._ending)
                return this;
            this._ending = !0;
            var e = this._geometry;
            return this._clearStage(),
                t = t || {},
                this._geometry = e,
                this._fireEvent("drawend", t),
                delete this._geometry,
            this.options.once && this.disable(),
                delete this._ending,
                delete this._historyPointer,
                this
        }
        ,
        v._clearStage = function() {
            this._getDrawLayer().clear(),
                delete this._geometry,
                delete this._clickCoords
        }
        ,
        v._getMouseContainerPoint = function(t) {
            return "mousedown" === this._getRegisterMode().action && ii(t.domEvent),
                t.containerPoint
        }
        ,
        v._isValidContainerPoint = function(t) {
            var e = this._map.getSize()
                , i = e.width
                , e = e.height;
            return !(t.x < 0 || t.y < 0) && !(t.x > i || t.y > e)
        }
        ,
        v._getDrawLayer = function() {
            var t = D + "drawtool"
                , e = this._map.getLayer(t);
            return e || (e = new Us(t,{
                enableSimplify: !1
            }),
                this._map.addLayer(e)),
                e
        }
        ,
        v._fireEvent = function(t, e) {
            e = e || {},
            this._geometry && (e.geometry = this._getRegisterMode().generate(this._geometry, {
                drawTool: this
            })),
                Xs.prototype._fireEvent.call(this, t, e)
        }
        ,
        ea);
    function ea(t) {
        t = Qs.call(this, t) || this;
        return t._checkMode(),
            t._events = {
                click: t._clickHandler,
                mousemove: t._mouseMoveHandler,
                dblclick: t._doubleClickHandler,
                mousedown: t._mouseDownHandler,
                mouseup: t._mouseUpHandler
            },
            t
    }
    ta.mergeOptions({
        symbol: {
            lineColor: "#000",
            lineWidth: 2,
            lineOpacity: 1,
            polygonFill: "#fff",
            polygonOpacity: .3
        },
        doubleClickZoom: !1,
        mode: null,
        once: !1,
        autoPanAtEdge: !1,
        ignoreMouseleave: !0
    });
    s(na, ia = ki),
        (x = na.prototype).addHooks = function() {
            this.target.on("_mousedown", this._onMouseDown, this)
        }
        ,
        x.removeHooks = function() {
            this.target.off("_mousedown", this._onMouseDown, this),
            this.drawTool.isEnabled() && this.drawTool.remove()
        }
        ,
        x._onMouseDown = function(t) {
            this.target.options.boxZoom && t.domEvent.shiftKey && this.drawTool.setSymbol(this.target.options.boxZoomSymbol).on("drawend", this._boxZoom, this).addTo(this.target)
        }
        ,
        x._boxZoom = function(t) {
            var e = this.target
                , t = (this.drawTool.remove(),
                t.geometry)
                , i = t.getCenter()
                , t = t.getSymbol()
                , n = t.markerWidth
                , t = t.markerHeight
                , i = new g(i,e.locateByPoint(i, n, t),e.getProjection())
                , n = e.getFitZoom(i);
            e._animateTo({
                center: i.getCenter(),
                zoom: n
            })
        }
    ;
    var ia, v = na;
    function na(t) {
        t = ia.call(this, t) || this;
        return t.drawTool = new ta({
            mode: "boxZoom",
            ignoreMouseleave: !1
        }),
            t
    }
    h.mergeOptions({
        boxZoom: !0,
        boxZoomSymbol: {
            markerType: "rectangle",
            markerLineWidth: 3,
            markerLineColor: "#1bbc9b",
            markerLineDasharray: [10, 5],
            markerFillOpacity: .1,
            markerFill: "#1bbc9b",
            markerWidth: 1,
            markerHeight: 1
        }
    }),
        h.addOnLoadHook("addHandler", "boxZoom", v);
    s(oa, ra = ki),
        (x = oa.prototype).addHooks = function() {
            this.target && this.target.on("_mousemove", this._onMouseMove, this)
        }
        ,
        x.removeHooks = function() {
            this.target && this.target.off("_mousemove", this._onMouseMove, this)
        }
        ,
        x._onMouseMove = function(t) {
            var e, i, n, r, o = this.target;
            o.options.autoPanAtEdge && (t = t.containerPoint,
            (n = o.getContainerExtent()) && (e = t.x,
                t = t.y,
                i = n.xmax,
                n = n.ymax,
            e < 30 && (r = [Math.abs(e - 30), 0]),
            t < 30 && (r = [0, Math.abs(t - 30)]),
            i < e + 30 && (r = [-Math.abs(e + 30 - i), 0]),
            (r = n < t + 30 ? [0, -Math.abs(t + 30 - n)] : r) && o.panBy(r, {
                duration: 1
            })))
        }
    ;
    var ra, v = oa;
    function oa() {
        return ra.apply(this, arguments) || this
    }
    h.mergeOptions({
        autoPanAtEdge: !1
    }),
        h.addOnLoadHook("addHandler", "autoPanAtEdge", v),
        h.include({
            animateTo: function(t, i, n) {
                var e, r, o, s = this, a = (p(i = void 0 === i ? {} : i) && (n = i,
                    i = {}),
                    this.getProjection()), h = this.getView(), l = {}, u = !0;
                for (e in t)
                    !J(t, e) || V(t[e]) || "prjCenter" !== e && V(h[e]) || (u = !1,
                        "center" === e ? (r = new M(h[e]).toFixed(7),
                            o = new M(t[e]).toFixed(7),
                        r.equals(o) || (l.center = [r, o])) : "prjCenter" === e ? (r = new M(this._getPrjCenter()),
                            o = new M(t[e]),
                        r.equals(o) || (l.prjCenter = [r, o])) : h[e] !== t[e] && "around" !== e && (l[e] = [h[e], t[e]]));
                if (u)
                    return null;
                this._animPlayer && (this._isInternalAnimation ? "running" === this._animPlayer.playState && (this._animPlayer.pause(),
                    this._prevAnimPlayer = this._animPlayer) : (delete this._prevAnimPlayer,
                    this._stopAnim(this._animPlayer)));
                var c = t.around || new R(this.width / 2,this.height / 2)
                    , d = this._getRenderer()
                    , g = this._animPlayer = Po.animate(l, {
                    easing: i.easing || "out",
                    duration: i.duration || this.options.zoomAnimationDuration,
                    framer: function(t) {
                        d.callInNextFrame(t)
                    }
                }, function(t) {
                    var e;
                    s.isRemoved() ? g.finish() : ("running" === g.playState ? (t.styles.center ? (e = t.styles.center,
                        s._setPrjCenter(a.project(e)),
                        s.onMoving(s._parseEventFromCoord(s.getCenter()))) : t.styles.prjCenter && (e = t.styles.prjCenter,
                        s._setPrjCenter(e),
                        s.onMoving(s._parseEventFromCoord(s.getCenter()))),
                    V(t.styles.zoom) || s.onZooming(t.styles.zoom, c),
                    V(t.styles.pitch) || s.setPitch(t.styles.pitch),
                    V(t.styles.bearing) || s.setBearing(t.styles.bearing),
                        s._fireEvent("animating")) : "paused" === g.playState && g !== s._mapAnimPlayer || (g._interupted || (l.center ? s._setPrjCenter(a.project(l.center[1])) : l.prjCenter && s._setPrjCenter(l.prjCenter[1]),
                    V(l.pitch) || s.setPitch(l.pitch[1]),
                    V(l.bearing) || s.setBearing(l.bearing[1])),
                        s._endAnim(g, l, c, i)),
                    n && n(t))
                }, this);
                return this._startAnim(l, c),
                    g
            },
            _animateTo: function(t, e, i) {
                return void 0 === e && (e = {}),
                this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer),
                    this._isInternalAnimation = !0,
                    this._mapAnimPlayer = this.animateTo(t, e, i),
                    delete this._isInternalAnimation,
                    this._mapAnimPlayer
            },
            isAnimating: function() {
                return !!this._animPlayer
            },
            isRotating: function() {
                return this.isDragRotating() || !!this._animRotating
            },
            _endAnim: function(t, e, i, n) {
                delete this._animRotating;
                var r, o, s = t._interupted ? "animateinterrupted" : "animateend";
                t === this._animPlayer && delete this._animPlayer,
                t === this._mapAnimPlayer && delete this._mapAnimPlayer,
                    e.center ? (r = t._interupted ? this.getCenter() : e.center[1],
                        this.onMoveEnd(this._parseEventFromCoord(r))) : e.prjCenter && (r = t._interupted ? this._getPrjCenter() : e.prjCenter[1],
                        (o = this._parseEventFromCoord(this.getProjection().unproject(r))).point2d = this._prjToPoint(r),
                        this.onMoveEnd(o)),
                V(e.zoom) || (t._interupted ? this.onZoomEnd(this.getZoom(), i) : n.wheelZoom ? this.onZooming(e.zoom[1], i) : this.onZoomEnd(e.zoom[1], i)),
                s && this._fireEvent(s),
                V(e.pitch) || this.getPitch() || this.getRenderer().setToRedraw(),
                    this._resumePrev(t)
            },
            _startAnim: function(t, e) {
                this._animPlayer && (t.center && this.onMoveStart(),
                t.zoom && !this.isZooming() && this.onZoomStart(t.zoom[1], e),
                (t.pitch || t.bearing) && (this._animRotating = !0),
                    this._fireEvent("animatestart"),
                    this._animPlayer.play())
            },
            _stopAnim: function(t) {
                t && (delete this._animRotating,
                "finished" !== t.playState && (t._interupted = !0,
                    t.cancel()),
                t === this._animPlayer && delete this._animPlayer,
                t === this._mapAnimPlayer && delete this._mapAnimPlayer)
            },
            _resumePrev: function(t) {
                var e;
                this._prevAnimPlayer && ("paused" !== (e = this._prevAnimPlayer).playState && delete this._prevAnimPlayer,
                t !== e && (this._animPlayer = e).play())
            }
        });
    var sa = "mousedown mouseup mouseover mouseout mouseenter mouseleave mousemove click dblclick contextmenu keypress touchstart touchmove touchend ";
    function aa(t, e, i, n, r) {
        var e = 1 / Math.tan(e / 2)
            , o = 1 / (n - r);
        t[0] = e / i,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = e,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = (r + n) * o,
            t[11] = -1,
            t[12] = 0,
            t[13] = 0,
            t[14] = 2 * r * n * o,
            t[15] = 0
    }
    function ha(t, e, i) {
        var n, r, o, s, a, h, l, u, c, d, g, p, f = i[0], m = i[1], i = i[2];
        e === t ? (t[12] = e[0] * f + e[4] * m + e[8] * i + e[12],
            t[13] = e[1] * f + e[5] * m + e[9] * i + e[13],
            t[14] = e[2] * f + e[6] * m + e[10] * i + e[14],
            t[15] = e[3] * f + e[7] * m + e[11] * i + e[15]) : (n = e[0],
            r = e[1],
            o = e[2],
            s = e[3],
            a = e[4],
            h = e[5],
            l = e[6],
            u = e[7],
            c = e[8],
            d = e[9],
            g = e[10],
            p = e[11],
            t[0] = n,
            t[1] = r,
            t[2] = o,
            t[3] = s,
            t[4] = a,
            t[5] = h,
            t[6] = l,
            t[7] = u,
            t[8] = c,
            t[9] = d,
            t[10] = g,
            t[11] = p,
            t[12] = n * f + a * m + c * i + e[12],
            t[13] = r * f + h * m + d * i + e[13],
            t[14] = o * f + l * m + g * i + e[14],
            t[15] = s * f + u * m + p * i + e[15])
    }
    function la(t, e, i) {
        var n = i[0]
            , r = i[1]
            , i = i[2];
        t[0] = e[0] * n,
            t[1] = e[1] * n,
            t[2] = e[2] * n,
            t[3] = e[3] * n,
            t[4] = e[4] * r,
            t[5] = e[5] * r,
            t[6] = e[6] * r,
            t[7] = e[7] * r,
            t[8] = e[8] * i,
            t[9] = e[9] * i,
            t[10] = e[10] * i,
            t[11] = e[11] * i,
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15]
    }
    function ua(t, e, i) {
        var n = e[0]
            , r = e[1]
            , o = e[2]
            , s = e[3]
            , a = e[4]
            , h = e[5]
            , l = e[6]
            , u = e[7]
            , c = e[8]
            , d = e[9]
            , g = e[10]
            , p = e[11]
            , f = e[12]
            , m = e[13]
            , _ = e[14]
            , e = e[15]
            , y = i[0]
            , v = i[1]
            , x = i[2]
            , w = i[3];
        return t[0] = y * n + v * a + x * c + w * f,
            t[1] = y * r + v * h + x * d + w * m,
            t[2] = y * o + v * l + x * g + w * _,
            t[3] = y * s + v * u + x * p + w * e,
            y = i[4],
            v = i[5],
            x = i[6],
            w = i[7],
            t[4] = y * n + v * a + x * c + w * f,
            t[5] = y * r + v * h + x * d + w * m,
            t[6] = y * o + v * l + x * g + w * _,
            t[7] = y * s + v * u + x * p + w * e,
            y = i[8],
            v = i[9],
            x = i[10],
            w = i[11],
            t[8] = y * n + v * a + x * c + w * f,
            t[9] = y * r + v * h + x * d + w * m,
            t[10] = y * o + v * l + x * g + w * _,
            t[11] = y * s + v * u + x * p + w * e,
            y = i[12],
            v = i[13],
            x = i[14],
            w = i[15],
            t[12] = y * n + v * a + x * c + w * f,
            t[13] = y * r + v * h + x * d + w * m,
            t[14] = y * o + v * l + x * g + w * _,
            t[15] = y * s + v * u + x * p + w * e,
            t
    }
    function ca(t, e) {
        var i = e[0]
            , n = e[1]
            , r = e[2]
            , o = e[3]
            , s = e[4]
            , a = e[5]
            , h = e[6]
            , l = e[7]
            , u = e[8]
            , c = e[9]
            , d = e[10]
            , g = e[11]
            , p = e[12]
            , f = e[13]
            , m = e[14]
            , e = e[15]
            , _ = i * a - n * s
            , y = i * h - r * s
            , v = i * l - o * s
            , x = n * h - r * a
            , w = n * l - o * a
            , C = r * l - o * h
            , P = u * f - c * p
            , b = u * m - d * p
            , M = u * e - g * p
            , S = c * m - d * f
            , T = c * e - g * f
            , E = d * e - g * m
            , k = _ * E - y * T + v * S + x * M - w * b + C * P;
        return k ? (t[0] = (a * E - h * T + l * S) * (k = 1 / k),
            t[1] = (r * T - n * E - o * S) * k,
            t[2] = (f * C - m * w + e * x) * k,
            t[3] = (d * w - c * C - g * x) * k,
            t[4] = (h * M - s * E - l * b) * k,
            t[5] = (i * E - r * M + o * b) * k,
            t[6] = (m * v - p * C - e * y) * k,
            t[7] = (u * C - d * v + g * y) * k,
            t[8] = (s * T - a * M + l * P) * k,
            t[9] = (n * M - i * T - o * P) * k,
            t[10] = (p * w - f * v + e * _) * k,
            t[11] = (c * v - u * w - g * _) * k,
            t[12] = (a * b - s * S - h * P) * k,
            t[13] = (i * S - n * b + r * P) * k,
            t[14] = (f * y - p * x - m * _) * k,
            t[15] = (u * x - c * y + d * _) * k,
            t) : null
    }
    function da(t) {
        return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = 1,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = 1,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t
    }
    function ga(t, e) {
        t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[3],
            t[4] = e[4],
            t[5] = e[5],
            t[6] = e[6],
            t[7] = e[7],
            t[8] = e[8],
            t[9] = e[9],
            t[10] = e[10],
            t[11] = e[11],
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15]
    }
    function pa(t, e, i, n) {
        return t[0] = e,
            t[1] = i,
            t[2] = n,
            t
    }
    function fa(t, e, i) {
        return t[0] = e[0] - i[0],
            t[1] = e[1] - i[1],
            t[2] = e[2] - i[2],
            t
    }
    function ma(t) {
        var e = t[0]
            , i = t[1]
            , t = t[2];
        return Math.sqrt(e * e + i * i + t * t)
    }
    function _a(t, e) {
        var i = e[0]
            , n = e[1]
            , r = e[2]
            , i = i * i + n * n + r * r;
        return 0 < i && (i = 1 / Math.sqrt(i),
            t[0] = e[0] * i,
            t[1] = e[1] * i,
            t[2] = e[2] * i),
            t
    }
    function ya(t, e, i) {
        var n = e[0]
            , r = e[1]
            , e = e[2]
            , o = i[0]
            , s = i[1]
            , i = i[2];
        t[0] = r * i - e * s,
            t[1] = e * o - n * i,
            t[2] = n * s - r * o
    }
    function va(t, e) {
        var i = e[0] - t[0]
            , n = e[1] - t[1]
            , e = e[2] - t[2];
        return Math.hypot ? Math.hypot(i, n, e) : function() {
            var t = 0
                , e = arguments.length;
            for (; e--; )
                t += arguments[e] * arguments[e];
            return Math.sqrt(t)
        }(i, n, e)
    }
    function xa(t, e, i) {
        var n = e[0]
            , r = e[1]
            , e = e[2]
            , o = 1 / (i[3] * n + i[7] * r + i[11] * e + i[15]);
        t[0] = (i[0] * n + i[4] * r + i[8] * e + i[12]) * o,
            t[1] = (i[1] * n + i[5] * r + i[9] * e + i[13]) * o,
            t[2] = (i[2] * n + i[6] * r + i[10] * e + i[14]) * o
    }
    h.include({
        _registerDomEvents: function() {
            Qe(this._panels.mapWrapper || this._containerDOM, sa, this._handleDOMEvent, this)
        },
        _removeDomEvents: function() {
            $e(this._panels.mapWrapper || this._containerDOM, sa, this._handleDOMEvent)
        },
        _handleDOMEvent: function(t) {
            var e = t.type;
            if ("contextmenu" === e && ei(t),
                !this._ignoreEvent(t)) {
                var i = !1;
                if ("mousedown" === e || "touchstart" === e && 1 === t.touches.length)
                    this._mouseDownTime = F();
                else if ("click" === e || "touchend" === e || "contextmenu" === e) {
                    if (!this._mouseDownTime)
                        return;
                    var n = this._mouseDownTime;
                    if (delete this._mouseDownTime,
                    300 < F() - n) {
                        if ("click" === e || "contextmenu" === e)
                            return
                    } else
                        "touchend" === e && (i = !0)
                }
                this._fireDOMEvent(this, t, e),
                i && (this._clickTime && F() - this._clickTime <= 300 ? (delete this._clickTime,
                    this._fireDOMEvent(this, t, "dblclick")) : (this._clickTime = F(),
                    this._fireDOMEvent(this, t, "click")))
            }
        },
        _ignoreEvent: function(t) {
            if (!t || !this._panels.control)
                return !1;
            if (this._isEventOutMap(t))
                return !0;
            var e, i = t.srcElement || t.target;
            if (i)
                for (; i && i !== this._containerDOM; ) {
                    if (i.className && i.className.indexOf && (0 <= i.className.indexOf("maptalks-control") || 0 <= i.className.indexOf("maptalks-ui") && !e.eventsPropagation))
                        return !0;
                    i = (e = i).parentNode
                }
            return !1
        },
        _isEventOutMap: function(t) {
            if (this.getPitch() > this.options.maxVisualPitch) {
                t = si(this._getActualEvent(t), this._containerDOM);
                if (!this.getContainerExtent().contains(t))
                    return !0
            }
            return !1
        },
        _parseEvent: function(t, e) {
            if (!t)
                return null;
            var i = {
                domEvent: t
            };
            return "keypress" !== e && (e = this._getActualEvent(t)) && (t = si(e, this._containerDOM),
                i = m(i, {
                    coordinate: this.containerPointToCoord(t),
                    containerPoint: t,
                    viewPoint: this.containerPointToViewPoint(t),
                    point2d: this._containerPointToPoint(t)
                })),
                i
        },
        _parseEventFromCoord: function(t) {
            var e = this.coordToContainerPoint(t);
            return {
                coordinate: t,
                containerPoint: e,
                viewPoint: this.containerPointToViewPoint(e),
                point2d: this.coordToPoint(t)
            }
        },
        _getActualEvent: function(t) {
            return t.touches && 0 < t.touches.length ? t.touches[0] : t.changedTouches && 0 < t.changedTouches.length ? t.changedTouches[0] : t
        },
        _fireDOMEvent: function(t, e, i) {
            this.isRemoved() || (e = this._parseEvent(e, i),
                this._fireEvent(i, e))
        }
    }),
        h.addOnLoadHook("_registerDomEvents"),
        h.include({
            isFullScreen: function() {
                return !!(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement)
            },
            requestFullScreen: function(t) {
                return this._fireEvent("fullscreenstart"),
                    this._requestFullScreen(t || this._containerDOM),
                    this._fireEvent("fullscreenend"),
                    this
            },
            cancelFullScreen: function() {
                return this._cancelFullScreen(),
                    this._fireEvent("cancelfullscreen"),
                    this
            },
            _requestFullScreen: function(t) {
                t.requestFullscreen ? t.requestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullScreen ? t.webkitRequestFullScreen() : t.msRequestFullScreen ? t.msRequestFullScreen() : (t = "fullscreen=1,status=no,resizable=yes,top=0,left=0,scrollbars=no,titlebar=no,menubar=no,location=no,toolbar=no,z-look=yes,width=" + (screen.availWidth - 8) + ",height=" + (screen.availHeight - 45),
                null !== window.open(location.href, "_blank", t) && (window.opener = null,
                    window.close()))
            },
            _cancelFullScreen: function() {
                document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen ? document.webkitCancelFullScreen() : null !== window.open(location.href, "_blank", "fullscreen=no,status=yes,resizable=yes,scrollbars=no,titlebar=no,menubar=yes,location=yes,toolbar=yes,z-look=yes") && (window.opener = null,
                    window.close())
            }
        }),
        h.include({
            panTo: function(t, e, i) {
                return t ? (p(e = void 0 === e ? {} : e) && (i = e,
                    e = {}),
                    t = new M(t),
                    void 0 === e.animation || e.animation ? (n = this.getProjection().project(t),
                        this._panAnimation(n, e.duration, i)) : (this.setCenter(t),
                        this)) : this;
                var n
            },
            _panTo: function(t, e) {
                return void 0 === (e = void 0 === e ? {} : e).animation || e.animation ? this._panAnimation(t, e.duration) : (this.onMoveStart(),
                    this._setPrjCenter(t),
                    this.onMoveEnd(this._parseEventFromCoord(this.getCenter())),
                    this)
            },
            panBy: function(t, e, i) {
                return t && (p(e = void 0 === e ? {} : e) && (i = e,
                    e = {}),
                    t = new R(t),
                0 < this.getContainerExtent().ymin && 30 < t.y && (n = t.y,
                    t.y = 30,
                    t.x = 30 * t.x / n,
                    console.warn("offset is limited to panBy when pitch is above maxPitch")),
                    this.onMoveStart(),
                    void 0 === e.animation || e.animation ? (t = t.multi(-1),
                        n = this._containerPointToPrj(new R(this.width / 2 + t.x,this.height / 2 + t.y)),
                        this._panAnimation(n, e.duration, i)) : (this._offsetCenterByPixel(t),
                        this.onMoveEnd(this._parseEventFromCoord(this.getCenter())))),
                    this;
                var n
            },
            _panAnimation: function(t, e, i) {
                return this._animateTo({
                    prjCenter: t
                }, {
                    duration: e || this.options.panAnimationDuration
                }, i)
            }
        }),
        y.fromJSON = function(t) {
            if (Array.isArray(t)) {
                for (var e = [], i = 0, n = t.length; i < n; i++) {
                    var r = y.fromJSON(t[i]);
                    Array.isArray(t) ? e = e.concat(r) : e.push(r)
                }
                return e
            }
            return t && !t.feature ? es.toGeometry(t) : (t.subType ? (o = y.getJSONClass(t.subType).fromJSON(t),
            V(t.feature.id) || o.setId(t.feature.id)) : (o = es.toGeometry(t.feature),
            t.options && o.config(t.options)),
            t.symbol && o.setSymbol(t.symbol),
            t.infoWindow && o.setInfoWindow(t.infoWindow),
                o);
            var o
        }
        ,
        kr.fromJSON = function(t) {
            if (!t)
                return null;
            var e = t.type
                , i = kr.getJSONClass(e);
            if (i && i.fromJSON)
                return i.fromJSON(t);
            throw new Error("unsupported layer type:" + e)
        }
        ,
        h.include({
            JSON_VERSION: "1.0",
            toJSON: function(t) {
                t = t || {};
                var e = {
                    jsonVersion: this.JSON_VERSION,
                    version: this.VERSION,
                    extent: this.getExtent().toJSON()
                }
                    , i = (e.options = this.config(),
                    e.options.center = this.getCenter(),
                    e.options.zoom = this.getZoom(),
                    e.options.bearing = this.getBearing(),
                    e.options.pitch = this.getPitch(),
                    this.getBaseLayer())
                    , n = ((V(t.baseLayer) || t.baseLayer) && i && (e.baseLayer = i.toJSON(t.baseLayer)),
                    {})
                    , r = (t.clipExtent && (!0 === t.clipExtent ? n.clipExtent = this.getExtent() : n.clipExtent = t.clipExtent),
                    []);
                if (V(t.layers) || t.layers && !Array.isArray(t.layers)) {
                    for (var o, s = this.getLayers(), a = 0, h = s.length; a < h; a++)
                        s[a].toJSON && (o = m({}, W(t.layers) ? t.layers : {}, n),
                            r.push(s[a].toJSON(o)));
                    e.layers = r
                } else if (L(t.layers)) {
                    for (var l = t.layers, u = 0; u < l.length; u++) {
                        var c = l[u]
                            , d = this.getLayer(c.id);
                        d.toJSON && (c = m({}, c.options, n),
                            r.push(d.toJSON(c)))
                    }
                    e.layers = r
                } else
                    e.layers = [];
                return e
            }
        }),
        h.fromJSON = function(t, e, i) {
            if (!t || !e)
                return null;
            i = i || {};
            var n, t = new h(t,e.options);
            if (!V(i.baseLayer) && !i.baseLayer || (n = kr.fromJSON(e.baseLayer)) && t.setBaseLayer(n),
            V(i.layers) || i.layers) {
                for (var r = [], o = e.layers, s = 0; s < o.length; s++) {
                    var a = kr.fromJSON(o[s]);
                    r.push(a)
                }
                t.addLayer(r)
            }
            return t
        }
        ,
        h.include({
            computeLength: function(t, e) {
                if (!this.getProjection())
                    return null;
                t = new M(t),
                    e = new M(e);
                return t.equals(e) ? 0 : this.getProjection().measureLength(t, e)
            },
            computeGeometryLength: function(t) {
                return t._computeGeodesicLength(this.getProjection())
            },
            computeGeometryArea: function(t) {
                return t._computeGeodesicArea(this.getProjection())
            },
            identify: function(t, e) {
                if (!t)
                    return this;
                var i = t.layers;
                if (!L(i))
                    return this;
                for (var n = [], r = 0, o = i.length; r < o; r++)
                    b(i[r]) ? n.push(this.getLayer(i[r])) : n.push(i[r]);
                for (var s = new M(t.coordinate), a = m({}, t), h = [], l = n.length - 1; 0 <= l && !(t.count && h.length >= t.count); l--) {
                    var u = n[l];
                    !u || !u.getMap() || !t.includeInvisible && !u.isVisible() || !t.includeInternals && 0 <= u.getId().indexOf(D) || (u = u.identify(s, a)) && (Array.isArray(u) ? ot(h, u) : h.push(u))
                }
                return e.call(this, h),
                    this
            }
        }),
        h.include({
            _zoom: function(t, e) {
                this.options.zoomable && !this.isZooming() && (e = this._checkZoomOrigin(e),
                    t = this._checkZoom(t),
                    this.onZoomStart(t, e),
                    this._frameZoom = this.getZoom(),
                    this.onZoomEnd(t, e))
            },
            _zoomAnimation: function(t, e, i) {
                this.options.zoomable && !this.isZooming() && (t = this._checkZoom(t),
                this.getZoom() !== t && (e = this._checkZoomOrigin(e),
                    this._startZoomAnim(t, e, i)))
            },
            _checkZoomOrigin: function(t) {
                return t && !this.options.zoomInCenter || (t = new R(this.width / 2,this.height / 2)),
                    t = this.options.zoomOrigin ? new R(this.options.zoomOrigin) : t
            },
            _startZoomAnim: function(t, e, i) {
                V(i) && (i = 1);
                var n = this._getResolution(this._startZoomVal) / this._getResolution(t)
                    , i = this.options.zoomAnimationDuration * Math.abs(n - i) / Math.abs(n - 1);
                this._frameZoom = this._startZoomVal,
                    this._animateTo({
                        zoom: t,
                        around: e
                    }, {
                        continueOnViewChanged: !0,
                        duration: i
                    })
            },
            onZoomStart: function(t, e) {
                this.options.zoomable && !this.isZooming() && (this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer),
                    this._zooming = !0,
                    this._startZoomVal = this.getZoom(),
                    this._startZoomCoord = this._containerPointToPrj(e),
                    this._fireEvent("zoomstart", {
                        from: this._startZoomVal,
                        to: t
                    }))
            },
            onZooming: function(t, e, i) {
                var n, r, o;
                this.options.zoomable && this._frameZoom !== t && (V(i) && (i = 1),
                    this._zoomTo(t, e),
                    n = this.getResolution(t),
                    n = this.getResolution(this._startZoomVal) / n / i,
                    i = this._prjToContainerPoint(this._startZoomCoord, this._startZoomVal),
                    r = this.getViewPoint(),
                this.isRotating() || i.equals(e) || 1 == n || (o = this.getPitch(),
                    i = i._sub(e)._multi(1 / (1 - n)),
                o && (i.y /= Math.cos(o * Math.PI / 180)),
                    e = e.add(i)),
                    o = {
                        view: [n, 0, 0, n, (e.x - r.x) * (1 - n), (e.y - r.y) * (1 - n)]
                    },
                1 !== (i = this.getDevicePixelRatio()) && (e = e.multi(i)),
                    o.container = [n, 0, 0, n, e.x * (1 - n), e.y * (1 - n)],
                    this._fireEvent("zooming", {
                        from: this._startZoomVal,
                        to: t,
                        origin: e,
                        matrix: o
                    }),
                    this._frameZoom = t)
            },
            onZoomEnd: function(t, e) {
                var i;
                this.options.zoomable && (i = this._startZoomVal,
                    this._zoomTo(t, e),
                    this._zooming = !1,
                    this._getRenderer().onZoomEnd(),
                    this._fireEvent("zoomend", {
                        from: i,
                        to: t
                    }),
                this._verifyExtent(this._getPrjCenter()) || this._panTo(this._prjMaxExtent.getCenter()))
            },
            _zoomTo: function(t, e) {
                this._zoomLevel = t,
                    this._calcMatrices(),
                e && this._setPrjCoordAtContainerPoint(this._startZoomCoord, e)
            },
            _checkZoom: function(t) {
                var e = this.getMaxZoom()
                    , i = this.getMinZoom();
                return t = e < (t = t < i ? i : t) ? e : t
            }
        });
    var wa, Ca, Pa, ba, Ma, Sa, Ta, Ea, ka, Ra, Aa, La, Oa, Da, Ia, ja = Math.PI / 180, za = new M(0,0);
    function Za(t, e, i) {
        var n = this.width
            , r = this.height
            , o = this.getFov() * Math.PI / 180
            , s = this._getCameraFar(o, e)
            , a = this.cameraCenterDistance
            , s = a + (s - a) / Math.cos((90 - e) * Math.PI / 180) * Math.cos((90 - t) * Math.PI / 180)
            , a = (aa(Sa, o, n / r, .1, s),
            this.viewMatrix);
        return ua(i, Sa, a)
    }
    function Ha() {
        return da(new Array(16))
    }
    h.include({
        getFov: function() {
            return this._fov || (this._fov = .6435011087932844),
            this._fov / ja
        },
        setFov: function(t) {
            if (this.isZooming())
                return this;
            if (t = Math.max(.01, Math.min(60, t)),
            this._fov === t)
                return this;
            var e = this.getFov();
            return this._fov = t * ja,
                this._calcMatrices(),
                this._renderLayers(),
                this._fireEvent("fovchange", {
                    from: e,
                    to: this.getFov()
                }),
                this
        },
        getBearing: function() {
            return this._angle ? -this._angle / ja : 0
        },
        setBearing: function(t) {
            if (c.ie9)
                throw new Error("map can't rotate in IE9.");
            t = -ct(t, -180, 180) * ja;
            if (this._angle === t)
                return this;
            var e = this.getBearing();
            return this._fireEvent("rotatestart", {
                from: e,
                to: t
            }),
                this._angle = t,
                this._calcMatrices(),
                this._renderLayers(),
                this._fireEvent("rotate", {
                    from: e,
                    to: t
                }),
                this._fireEvent("rotateend", {
                    from: e,
                    to: t
                }),
                this
        },
        getPitch: function() {
            return this._pitch ? this._pitch / Math.PI * 180 : 0
        },
        setPitch: function(t) {
            if (c.ie9)
                throw new Error("map can't tilt in IE9.");
            t = dt(t, 0, this.options.maxPitch) * ja;
            if (this._pitch === t)
                return this;
            var e = this.getPitch();
            return this._fireEvent("pitchstart", {
                from: e,
                to: t
            }),
                this._pitch = t,
                this._calcMatrices(),
                this._renderLayers(),
                this._fireEvent("pitch", {
                    from: e,
                    to: t
                }),
                this._fireEvent("pitchend", {
                    from: e,
                    to: t
                }),
                this
        },
        isTransforming: function() {
            return !(!this._pitch && !this._angle)
        },
        getFrustumAltitude: function() {
            return this._frustumAltitude
        },
        _calcFrustumAltitude: function() {
            var t = 90 - this.getPitch()
                , e = this.getFov() / 2
                , i = this.cameraPosition ? this.cameraPosition[2] : 0;
            if (e <= t)
                return i;
            var e = Math.PI * e / 180
                , t = new R(this.cameraPosition).distanceTo(new R(this.cameraLookAt))
                , n = i * Math.tan(2 * e);
            return i + Math.tan(e) * (t + n)
        },
        _pointToContainerPoint: (Ia = [0, 0, 0],
                function(t, e, i, n) {
                    var r;
                    return void 0 === i && (i = 0),
                        t = this._pointToPoint(t, e, n),
                        this.isTransforming() || i ? (i *= this._getResolution(e) / this._getResolution(),
                            e = this._glScale,
                            pa(Ia, t.x * e, t.y * e, i * e),
                            xa(i = this._projIfBehindCamera(Ia, this.cameraPosition, this.cameraForward), i, this.projViewMatrix),
                            e = this.width / 2,
                            r = this.height / 2,
                            i[0] = i[0] * e + e,
                            i[1] = -i[1] * r + r,
                            n ? (n.x = i[0],
                                n.y = i[1],
                                n) : new R(i[0],i[1])) : (e = this._prjToPoint(this._getPrjCenter(), void 0, za),
                            n ? (n.x = t.x,
                                n.y = t.y) : n = t,
                            n._sub(e.x, e.y),
                            n.set(n.x, -n.y),
                            n._add(this.width / 2, this.height / 2))
                }
        ),
        _projIfBehindCamera: (La = new Array(3),
                Oa = new Array(3),
                Da = new Array(3),
                function(t, e, i) {
                    fa(La, t, e);
                    var n, r = i[0] * La[0] + i[1] * La[1] + i[2] * La[2];
                    return r <= 0 && (i = i,
                        r = 1.01 * r,
                        (n = Oa)[0] = i[0] * r,
                        n[1] = i[1] * r,
                        n[2] = i[2] * r,
                        n = t,
                        i = e,
                        r = fa(Da, La, Oa),
                        n[0] = i[0] + r[0],
                        n[1] = i[1] + r[1],
                        n[2] = i[2] + r[2]),
                        t
                }
        ),
        _containerPointToPoint: (ka = [0, 0, 0],
                Ra = [0, 0, 0, 1],
                Aa = [0, 0, 0, 1],
                function(t, e, i) {
                    if (this.isTransforming())
                        return o = this.width / 2 || 1,
                            r = this.height / 2 || 1,
                            pa(ka, (t.x - o) / o, (r - t.y) / r, 0),
                            pa(Ra, ka[0], ka[1], 0),
                            pa(Aa, ka[0], ka[1], 1),
                            Ra[3] = Aa[3] = 1,
                            xa(Ra, Ra, this.projViewMatrixInverse),
                            xa(Aa, Aa, this.projViewMatrixInverse),
                            o = Ra[0],
                            r = Aa[0],
                            s = Ra[1],
                            n = Aa[1],
                            o = ut(o, r, r = (o = Ra[2]) === (r = Aa[2]) ? 0 : (0 - o) / (r - o)),
                            s = ut(s, n, r),
                            i ? (i.x = o,
                                i.y = s) : i = new R(o,s),
                            i._multi(1 / this._glScale),
                            void 0 === e || this.getZoom() === e ? i : this._pointToPointAtZoom(i, e, i);
                    var n = this._prjToPoint(this._getPrjCenter(), e, i)
                        , r = void 0 !== e ? this._getResolution() / this._getResolution(e) : 1
                        , o = r * (t.x - this.width / 2)
                        , s = r * (t.y - this.height / 2);
                    return n._add(o, -s)
                }
        ),
        _calcMatrices: (Ta = Ha(),
                Ea = Ha(),
                function() {
                    delete this._mapRes,
                        delete this._mapGlRes,
                        delete this._mapExtent2D,
                        delete this._mapGlExtent2D;
                    var t = this.getSize()
                        , e = t.width || 1
                        , t = t.height || 1
                        , i = (this._glScale = this.getGLScale(),
                    this.getPitch() * Math.PI / 180)
                        , n = this._getCameraWorldMatrix()
                        , r = this.getFov() * Math.PI / 180
                        , o = this._getCameraFar(r, this.getPitch())
                        , i = (this.cameraFar = o,
                        this.cameraNear = Math.max(this._glScale * this.getResolution(this.getGLZoom()) * Math.cos(i), .1),
                    this.projMatrix || Ha());
                    aa(i, r, e / t, this.cameraNear, o),
                        this.projMatrix = i,
                        this.viewMatrix = ca(Ta, n),
                        this.projViewMatrix = ua(this.projViewMatrix || Ha(), i, this.viewMatrix),
                        this._calcCascadeMatrixes(),
                        this.projViewMatrixInverse = ua(this.projViewMatrixInverse || Ha(), n, ca(Ea, i)),
                        this.domCssMatrix = this._calcDomMatrix(),
                        this._frustumAltitude = this._calcFrustumAltitude(),
                        this._mapRes = this._getResolution(),
                        this._mapGlRes = this._getResolution(this.getGLZoom()),
                        this._mapExtent2D = this._get2DExtent(),
                        this._mapGlExtent2D = this._get2DExtent(this.getGLZoom())
                }
        ),
        _getCameraFar: function(t, e) {
            var i = this.cameraCenterDistance = va(this.cameraPosition, this.cameraLookAt)
                , n = i;
            return 0 < e && (e = e * Math.PI / 180,
                n += 2 / Math.PI - e <= t / 2 ? 4 * i : i * (i = Math.tan(t / 2)) / (1 / Math.tan(e) - i)),
            n + 1
        },
        _calcCascadeMatrixes: (Sa = Ha(),
                function() {
                    var t = this.getPitch()
                        , e = this.options.cascadePitches[0]
                        , i = this.options.cascadePitches[1]
                        , n = this.cascadeFrustumMatrix0 = this.cascadeFrustumMatrix0 || Ha()
                        , r = this.cascadeFrustumMatrix1 = this.cascadeFrustumMatrix1 || Ha();
                    e < t ? Za.call(this, t, e, n) : ga(this.cascadeFrustumMatrix0, this.projViewMatrix),
                        i < t ? Za.call(this, t, i, r) : ga(this.cascadeFrustumMatrix1, this.cascadeFrustumMatrix0)
                }
        ),
        _calcDomMatrix: (Ca = Ha(),
                Pa = Ha(),
                ba = [1, -1, 1],
                Ma = [0, 0, 0],
                function() {
                    var t, e, i, n, r, o, s, a, h, l, u, c = this.width || 1, d = this.height || 1, g = .5 / Math.tan(this._fov / 2) * d;
                    return la(Ca, this.projMatrix, ba),
                        ha(Ca, Ca, pa(Ma, 0, 0, -g)),
                    this._pitch && (t = g = Ca,
                        h = this._pitch,
                        u = Math.sin(h),
                        h = Math.cos(h),
                        i = t[4],
                        r = t[5],
                        s = t[6],
                        l = t[7],
                        e = t[8],
                        n = t[9],
                        o = t[10],
                        a = t[11],
                    t !== g && (g[0] = t[0],
                        g[1] = t[1],
                        g[2] = t[2],
                        g[3] = t[3],
                        g[12] = t[12],
                        g[13] = t[13],
                        g[14] = t[14],
                        g[15] = t[15]),
                        g[4] = i * h + e * u,
                        g[5] = r * h + n * u,
                        g[6] = s * h + o * u,
                        g[7] = l * h + a * u,
                        g[8] = e * h - i * u,
                        g[9] = n * h - r * u,
                        g[10] = o * h - s * u,
                        g[11] = a * h - l * u),
                    this._angle && (e = t = Ca,
                        i = this._angle,
                        n = Math.sin(i),
                        i = Math.cos(i),
                        r = e[0],
                        o = e[1],
                        s = e[2],
                        g = e[3],
                        a = e[4],
                        h = e[5],
                        l = e[6],
                        u = e[7],
                    e !== t && (t[8] = e[8],
                        t[9] = e[9],
                        t[10] = e[10],
                        t[11] = e[11],
                        t[12] = e[12],
                        t[13] = e[13],
                        t[14] = e[14],
                        t[15] = e[15]),
                        t[0] = r * i + a * n,
                        t[1] = o * i + h * n,
                        t[2] = s * i + l * n,
                        t[3] = g * i + u * n,
                        t[4] = a * i - r * n,
                        t[5] = h * i - o * n,
                        t[6] = l * i - s * n,
                        t[7] = u * i - g * n),
                        da(Pa),
                        la(Pa, Pa, pa(Ma, c / 2, -d / 2, 1)),
                        ua(this.domCssMatrix || Ha(), Pa, Ca)
                }
        ),
        _getCameraWorldMatrix: (wa = {},
                function() {
                    var t, e, i, n, r, o, s, a = this.getGLZoom(), h = this.getSize(), l = this.getGLScale(), a = this._prjToPoint(this._prjCenter, a), u = (this.cameraLookAt = pa(this.cameraLookAt || [0, 0, 0], a.x, a.y, 0),
                    this.getPitch() * ja), c = this.getBearing() * ja, d = this._getFovRatio(), l = l * (h.height || 1) / 2 / d, h = l * Math.cos(u), d = Math.sin(u) * l, u = a.x - d * Math.sin(c), l = a.y - d * Math.cos(c), a = (this.cameraPosition = pa(this.cameraPosition || [0, 0, 0], u, l, h),
                    d || 1), u = this.cameraUp = pa(this.cameraUp || [0, 0, 0], Math.sin(c) * a, Math.cos(c) * a, 0), l = this.cameraWorldMatrix = this.cameraWorldMatrix || Ha(), d = (h = l,
                        d = this.cameraPosition,
                        c = this.cameraLookAt,
                        a = u,
                        u = [0, 0, 0],
                        n = [0, 0, 0],
                        fa(e = [0, 0, 0], d, c),
                    0 === ma(e) && (e[2] = 1),
                        _a(e, e),
                        ya(u, a, e),
                    0 === ma(e) && (1 === Math.abs(a[2]) ? e[0] += 1e-4 : e[2] += 1e-4,
                        _a(e, e),
                        ya(u, a, e)),
                        _a(u, u),
                        ya(n, e, u),
                        h[0] = u[0],
                        h[4] = n[0],
                        h[8] = e[0],
                        h[1] = u[1],
                        h[5] = n[1],
                        h[9] = e[1],
                        h[2] = u[2],
                        h[6] = n[2],
                        h[10] = e[2],
                    this.cameraForward || [0, 0, 0]);
                    return fa(d, this.cameraLookAt, this.cameraPosition),
                        this.cameraForward = _a(d, d),
                        c = wa,
                        u = (a = l)[0],
                        n = a[4],
                        h = a[8],
                        e = a[1],
                        d = a[5],
                        i = a[9],
                        r = a[2],
                        s = a[6],
                        a = a[10],
                        0 < (t = u + d + a) ? (o = .5 / Math.sqrt(t + 1),
                            c.w = .25 / o,
                            c.x = (s - i) * o,
                            c.y = (h - r) * o,
                            c.z = (e - n) * o) : d < u && a < u ? (o = 2 * Math.sqrt(1 + u - d - a),
                            c.w = (s - i) / o,
                            c.x = .25 * o,
                            c.y = (n + e) / o,
                            c.z = (h + r) / o) : a < d ? (o = 2 * Math.sqrt(1 + d - u - a),
                            c.w = (h - r) / o,
                            c.x = (n + e) / o,
                            c.y = .25 * o,
                            c.z = (i + s) / o) : (o = 2 * Math.sqrt(1 + a - u - d),
                            c.w = (e - n) / o,
                            c.x = (h + r) / o,
                            c.y = (i + s) / o,
                            c.z = .25 * o),
                        t = l,
                        u = (a = wa).x,
                        d = a.y,
                        e = a.z,
                        a = a.w,
                        h = u * (n = u + u),
                        i = u * (r = d + d),
                        u *= s = e + e,
                        c = d * r,
                        d *= s,
                        e *= s,
                        n *= a,
                        r *= a,
                        a *= s,
                        t[0] = 1 - (c + e),
                        t[4] = i - a,
                        t[8] = u + r,
                        t[1] = i + a,
                        t[5] = 1 - (h + e),
                        t[9] = d - n,
                        t[2] = u - r,
                        t[6] = d + n,
                        t[10] = 1 - (h + c),
                        t[3] = 0,
                        t[7] = 0,
                        t[11] = 0,
                        t[12] = 0,
                        t[13] = 0,
                        t[14] = 0,
                        t[15] = 1,
                        o = l,
                        s = this.cameraPosition,
                        o[12] = s[0],
                        o[13] = s[1],
                        o[14] = s[2],
                        l
                }
        ),
        _getFovRatio: function() {
            var t = this.getFov();
            return Math.tan(t / 2 * ja)
        },
        _renderLayers: function() {
            this.isInteracting() || this._getLayers().forEach(function(t) {
                !t || (t = t._getRenderer()) && t.setToRedraw && t.setToRedraw()
            })
        }
    }),
        h.include({
            _onViewChange: function(t) {
                this._viewHistory || (this._viewHistory = [],
                    this._viewHistoryPointer = 0);
                for (var e = this._getCurrentView(), i = this._viewHistory.length - 1; 0 <= i; i--)
                    if (Ct(t, this._viewHistory[i]))
                        return this._viewHistoryPointer = i,
                            void this._fireViewChange(e, t);
                this._viewHistoryPointer < this._viewHistory.length - 1 && this._viewHistory.splice(this._viewHistoryPointer + 1),
                    this._viewHistory.push(t);
                var n = this.options.viewHistoryCount;
                0 < n && this._viewHistory.length > n && this._viewHistory.splice(0, this._viewHistory.length - n),
                    this._viewHistoryPointer = this._viewHistory.length - 1,
                    this._fireViewChange(e, t)
            },
            zoomToPreviousView: function(t) {
                if (void 0 === t && (t = {}),
                    !this.hasPreviousView())
                    return null;
                var e = this._viewHistory[--this._viewHistoryPointer];
                return this._zoomToView(e, t),
                    e
            },
            hasPreviousView: function() {
                return !(!this._viewHistory || 0 === this._viewHistoryPointer)
            },
            zoomToNextView: function(t) {
                if (void 0 === t && (t = {}),
                    !this.hasNextView())
                    return null;
                var e = this._viewHistory[++this._viewHistoryPointer];
                return this._zoomToView(e, t),
                    e
            },
            hasNextView: function() {
                return !(!this._viewHistory || this._viewHistoryPointer === this._viewHistory.length - 1)
            },
            _zoomToView: function(e, t) {
                var i = this
                    , n = this.getView();
                t.animation ? this._animateTo(e, {
                    duration: t.duration
                }, function(t) {
                    "finished" === t.state.playState && i._fireViewChange(n, e)
                }) : (this.setView(e),
                    this._fireViewChange(n, e))
            },
            getViewHistory: function() {
                return this._viewHistory
            },
            _fireViewChange: function(t, e) {
                this._fireEvent("viewchange", {
                    old: t,
                    new: e
                })
            },
            _getCurrentView: function() {
                return this._viewHistory ? this._viewHistory[this._viewHistoryPointer] : null
            }
        }),
        h.mergeOptions({
            viewHistory: !0,
            viewHistoryCount: 10
        });
    s(Fa, Ga = ta),
        (x = Fa.prototype).clear = function() {
            if (L(this._measureLayers))
                for (var t = 0; t < this._measureLayers.length; t++)
                    this._measureLayers[t].remove();
            return delete this._lastMeasure,
                delete this._lastVertex,
                this._measureLayers = [],
                this
        }
        ,
        x.getMeasureLayers = function() {
            return this._measureLayers
        }
        ,
        x.getLastMeasure = function() {
            return this._lastMeasure || 0
        }
        ,
        x.undo = function() {
            Ga.prototype.undo.call(this);
            var t = this._historyPointer;
            if (t !== this._vertexes.length)
                for (var e = t; e < this._vertexes.length; e++)
                    this._vertexes[e].label && this._vertexes[e].label.remove(),
                        this._vertexes[e].marker.remove();
            return this
        }
        ,
        x.redo = function() {
            Ga.prototype.redo.call(this);
            var t = this._historyPointer - 1;
            return this._vertexes[t] && !this._vertexes[t].marker.getLayer() && (this._vertexes[t].label && this._vertexes[t].label.addTo(this._measureMarkerLayer),
                this._vertexes[t].marker.addTo(this._measureMarkerLayer)),
                this
        }
        ,
        x._measure = function(t) {
            var e, i = this.getMap(), t = (t instanceof y ? e = i.computeGeometryLength(t) : Array.isArray(t) && (e = i.getProjection().measureLength(t)),
                this._lastMeasure = e,
                i = "zh-CN" === this.options.language ? [" \u7c73", " \u516c\u91cc", " \u82f1\u5c3a", " \u82f1\u91cc"] : [" m", " km", " feet", " mile"],
                "");
            return this.options.metric && (t += e < 1e3 ? e.toFixed(0) + i[0] : (e / 1e3).toFixed(2) + i[1]),
            this.options.imperial && (0 < t.length && (t += "\n"),
                t += (e *= 3.2808399) < 5280 ? e.toFixed(0) + i[2] : (e / 5280).toFixed(2) + i[3]),
                t
        }
        ,
        x._registerMeasureEvents = function() {
            this.on("drawstart", this._msOnDrawStart, this).on("drawvertex", this._msOnDrawVertex, this).on("mousemove", this._msOnMouseMove, this).on("drawend", this._msOnDrawEnd, this)
        }
        ,
        x._afterEnable = function() {
            this._registerMeasureEvents()
        }
        ,
        x._afterDisable = function() {
            this.off("drawstart", this._msOnDrawStart, this).off("drawvertex", this._msOnDrawVertex, this).off("mousemove", this._msOnMouseMove, this).off("drawend", this._msOnDrawEnd, this)
        }
        ,
        x._msOnDrawStart = function(t) {
            var e = this.getMap()
                , i = e._pointToPrj(t.point2d)
                , n = it++
                , r = "distancetool_" + n
                , n = "distancetool_markers_" + n
                , r = (e.getLayer(r) ? (this._measureLineLayer = e.getLayer(r),
                this._measureMarkerLayer = e.getLayer(n)) : (this._measureLineLayer = new Us(r).addTo(e),
                this._measureMarkerLayer = new Us(n).addTo(e)),
                this._measureLayers.push(this._measureLineLayer),
                this._measureLayers.push(this._measureMarkerLayer),
                new Ao(t.coordinate,{
                    symbol: this.options.vertexSymbol
                }))
                , n = (r._setPrjCoordinates(i),
                "zh-CN" === this.options.language ? "\u8d77\u70b9" : "start")
                , e = new Os(n,t.coordinate,this.options.labelOptions);
            e._setPrjCoordinates(i),
                this._lastVertex = e,
                this._addVertexMarker(r, e)
        }
        ,
        x._msOnMouseMove = function(t) {
            var e = this._measure(this._msGetCoordsToMeasure(t))
                , i = (this._tailMarker || ((i = re(this.options.vertexSymbol)).markerWidth /= 2,
                i.markerHeight /= 2,
                this._tailMarker = new Ao(t.coordinate,{
                    symbol: i
                }).addTo(this._measureMarkerLayer),
                this._tailLabel = new Os(e,t.coordinate,this.options.labelOptions).addTo(this._measureMarkerLayer)),
                this._geometry._getPrjCoordinates())
                , i = i[i.length - 1];
            this._tailMarker.setCoordinates(t.coordinate),
                this._tailMarker._setPrjCoordinates(i),
                this._tailLabel.setContent(e),
                this._tailLabel.setCoordinates(t.coordinate),
                this._tailLabel._setPrjCoordinates(i)
        }
        ,
        x._msGetCoordsToMeasure = function(t) {
            return t.geometry.getCoordinates().concat([t.coordinate])
        }
        ,
        x._msOnDrawVertex = function(t) {
            var e = this._geometry._getPrjCoordinates()
                , e = e[e.length - 1]
                , i = t.geometry
                , n = new Ao(t.coordinate,{
                symbol: this.options.vertexSymbol
            })
                , i = this._measure(i)
                , i = new Os(i,t.coordinate,this.options.labelOptions);
            this._addVertexMarker(n, i),
                i._setPrjCoordinates(e),
                n._setPrjCoordinates(e),
                this._lastVertex = i
        }
        ,
        x._addVertexMarker = function(t, e) {
            this._vertexes || (this._vertexes = []),
                this._vertexes.push({
                    label: e,
                    marker: t
                }),
            void 0 !== this._historyPointer && (this._vertexes.length = this._historyPointer),
                this._measureMarkerLayer.addGeometry(t),
            e && this._measureMarkerLayer.addGeometry(e)
        }
        ,
        x._msOnDrawEnd = function(t) {
            this._clearTailMarker();
            var e = (e = this._lastVertex.getSize()) || new Le(10,10)
                , e = (this._addClearMarker(this._lastVertex.getCoordinates(), this._lastVertex._getPrjCoordinates(), e.width),
                t.geometry.copy());
            e._setPrjCoordinates(t.geometry._getPrjCoordinates()),
                e.addTo(this._measureLineLayer),
                this._lastMeasure = e.getLength()
        }
        ,
        x._addClearMarker = function(t, e, i) {
            var n = this.options.clearButtonSymbol
                , r = {
                markerDx: (n.markerDx || 0) + i,
                textDx: (n.textDx || 0) + i
            }
                , r = (Array.isArray(n) && (r = n.map(function(t) {
                return t ? {
                    markerDx: (t.markerDx || 0) + i,
                    textDx: (t.textDx || 0) + i
                } : null
            })),
                n = re(n, r),
                new Ao(t,{
                    symbol: n
                }))
                , o = this._measureLineLayer
                , s = this._measureMarkerLayer;
            r.on("click", function() {
                return o.remove(),
                    s.remove(),
                    !1
            }, this),
                r.addTo(this._measureMarkerLayer),
                r._setPrjCoordinates(e)
        }
        ,
        x._clearTailMarker = function() {
            this._tailMarker && (this._tailMarker.remove(),
                delete this._tailMarker),
            this._tailLabel && (this._tailLabel.remove(),
                delete this._tailLabel)
        }
    ;
    var Ga, v = Fa;
    function Fa(t) {
        t = Ga.call(this, t) || this;
        return t.on("enable", t._afterEnable, Ee(t)).on("disable", t._afterDisable, Ee(t)),
            t._measureLayers = [],
            t
    }
    v.mergeOptions({
        mode: "LineString",
        language: "zh-CN",
        metric: !0,
        imperial: !1,
        symbol: {
            lineColor: "#000",
            lineWidth: 3,
            lineOpacity: 1
        },
        vertexSymbol: {
            markerType: "ellipse",
            markerFill: "#fff",
            markerLineColor: "#000",
            markerLineWidth: 3,
            markerWidth: 11,
            markerHeight: 11
        },
        labelOptions: {
            textSymbol: {
                textFaceName: "monospace",
                textLineSpacing: 1,
                textHorizontalAlignment: "right",
                textDx: 15
            },
            boxStyle: {
                padding: [6, 2],
                symbol: {
                    markerType: "square",
                    markerFill: "#fff",
                    markerFillOpacity: .9,
                    markerLineColor: "#b4b3b3"
                }
            }
        },
        clearButtonSymbol: [{
            markerType: "square",
            markerFill: "#fff",
            markerLineColor: "#b4b3b3",
            markerLineWidth: 2,
            markerWidth: 15,
            markerHeight: 15,
            markerDx: 20
        }, {
            markerType: "x",
            markerWidth: 10,
            markerHeight: 10,
            markerDx: 20
        }]
    });
    s(Wa, Na = v),
        (x = Wa.prototype)._measure = function(t) {
            var e, i = this.getMap(), t = (t instanceof y ? e = i.computeGeometryArea(t) : Array.isArray(t) && (e = i.getProjection().measureArea(t)),
                this._lastMeasure = e,
                i = "zh-CN" === this.options.language ? [" \u5e73\u65b9\u7c73", " \u5e73\u65b9\u516c\u91cc", " \u5e73\u65b9\u82f1\u5c3a", " \u5e73\u65b9\u82f1\u91cc"] : [" sq.m", " sq.km", " sq.ft", " sq.mi"],
                "");
            return this.options.metric && (t += e < 1e6 ? e.toFixed(0) + i[0] : (e / 1e6).toFixed(2) + i[1]),
            this.options.imperial && (0 < t.length && (t += "\n"),
                t += (e *= 3.2808399) < 27878400 ? e.toFixed(0) + i[2] : (e / 27878400).toFixed(2) + i[3]),
                t
        }
        ,
        x._msGetCoordsToMeasure = function(t) {
            return t.geometry.getShell().concat([t.coordinate])
        }
        ,
        x._msOnDrawVertex = function(t) {
            var e = this.getMap()._pointToPrj(t.point2d)
                , i = new Ao(t.coordinate,{
                symbol: this.options.vertexSymbol
            });
            i._setPrjCoordinates(e),
                this._measure(t.geometry),
                this._lastVertex = i,
                this._addVertexMarker(i)
        }
        ,
        x._msOnDrawEnd = function(t) {
            this._clearTailMarker();
            var e = this.getMap()._pointToPrj(t.point2d)
                , i = this._measure(t.geometry)
                , i = new Os(i,t.coordinate,this.options.labelOptions).addTo(this._measureMarkerLayer);
            i._setPrjCoordinates(e);
            i = (i = i.getSize()) || new Le(10,10),
                this._addClearMarker(t.coordinate, e, i.width),
                e = t.geometry.copy();
            e._setPrjCoordinates(t.geometry._getPrjCoordinates()),
                e.addTo(this._measureLineLayer),
                this._lastMeasure = e.getArea()
        }
    ;
    var Na, x = Wa;
    function Wa(t) {
        t = Na.call(this, t) || this;
        return t.on("enable", t._afterEnable, Ee(t)).on("disable", t._afterDisable, Ee(t)),
            t._measureLayers = [],
            t
    }
    x.mergeOptions({
        mode: "Polygon",
        symbol: {
            lineColor: "#000000",
            lineWidth: 2,
            lineOpacity: 1,
            lineDasharray: "",
            polygonFill: "#ffffff",
            polygonOpacity: .5
        }
    });
    var w = {
        create: function(t, e) {
            t = t.unproject(e[0]),
                t = new is(t,0);
            return t._setPrjCoordinates(e[0]),
                t
        },
        update: function(t, e, i) {
            var n = i.getMap()
                , e = Array.isArray(e) ? e[e.length - 1] : e
                , t = t.unproject(e)
                , e = n.computeLength(i.getCenter(), t);
            i.setRadius(e)
        },
        generate: function(t) {
            return t
        }
    }
        , w = (ta.registerMode("circle", m({
        clickLimit: 2,
        action: ["click", "mousemove", "click"]
    }, w)),
        ta.registerMode("freeHandCircle", m({
            action: ["mousedown", "mousemove", "mouseup"]
        }, w)),
        {
            create: function(t, e) {
                t = t.unproject(e[0]),
                    t = new os(t,0,0);
                return t._setPrjCoordinates(e[0]),
                    t
            },
            update: function(t, e, i) {
                var n = i.getMap()
                    , r = i.getCenter()
                    , e = Array.isArray(e) ? e[e.length - 1] : e
                    , t = t.unproject(e)
                    , e = n.computeLength(r, new M({
                    x: t.x,
                    y: r.y
                }))
                    , n = n.computeLength(r, new M({
                    x: r.x,
                    y: t.y
                }));
                i.setWidth(2 * e),
                    i.setHeight(2 * n)
            },
            generate: function(t) {
                return t
            }
        })
        , w = (ta.registerMode("ellipse", m({
        clickLimit: 2,
        action: ["click", "mousemove", "click"]
    }, w)),
        ta.registerMode("freeHandEllipse", m({
            action: ["mousedown", "mousemove", "mouseup"]
        }, w)),
        {
            create: function(t, e) {
                var i = new S([]);
                return i._firstClick = e[0],
                    i
            },
            update: function(t, e, i, n) {
                var r = i.getMap()
                    , n = n.containerPoint
                    , o = r._prjToContainerPoint(i._firstClick)
                    , o = [[o.x, o.y], [n.x, o.y], [n.x, n.y], [o.x, n.y]];
                i.setCoordinates(o.map(function(t) {
                    return r.containerPointToCoord(new R(t))
                })),
                    i._setPrjCoordinates(o.map(function(t) {
                        return r._containerPointToPrj(new R(t))
                    }))
            },
            generate: function(t) {
                return t
            }
        })
        , w = (ta.registerMode("rectangle", m({
        clickLimit: 2,
        action: ["click", "mousemove", "click"]
    }, w)),
        ta.registerMode("freeHandRectangle", m({
            action: ["mousedown", "mousemove", "mouseup"]
        }, w)),
        ta.registerMode("point", {
            clickLimit: 1,
            action: ["click"],
            create: function(t, e) {
                t = t.unproject(e[0]),
                    t = new Ao(t);
                return t._setPrjCoordinates(e[0]),
                    t
            },
            generate: function(t) {
                return t
            }
        }),
        {
            create: function(e, t) {
                var i = t.map(function(t) {
                    return e.unproject(t)
                })
                    , i = new Io(i);
                return i._setPrjCoordinates(t),
                    i
            },
            update: function(e, t, i) {
                var n, r, o = i.getSymbol(), t = (Array.isArray(t) ? n = t : (n = i._getPrjCoordinates()).push(t),
                    n.map(function(t) {
                        return e.unproject(t)
                    })), i = (i.setCoordinates(t),
                    i._setPrjCoordinates(n),
                    i.getLayer());
                i && (!(r = i.getGeometryById("polygon")) && 3 <= n.length && (r = new S([t],{
                    id: "polygon"
                }),
                o && (t = re(o, {
                    lineOpacity: 0
                }),
                    r.setSymbol(t)),
                    r.addTo(i)),
                r && r._setPrjCoordinates(n))
            },
            generate: function(t) {
                var e = new S(t.getCoordinates(),{
                    symbol: t.getSymbol()
                });
                return e._setPrjCoordinates(t._getPrjCoordinates()),
                    e._projCode = t._projCode,
                    e
            }
        })
        , w = (ta.registerMode("polygon", m({
        action: ["click", "mousemove", "dblclick"]
    }, w)),
        ta.registerMode("freeHandPolygon", m({
            action: ["mousedown", "mousemove", "mouseup"]
        }, w)),
        {
            create: function(e, t) {
                var i = t.map(function(t) {
                    return e.unproject(t)
                })
                    , i = new Io(i);
                return i._setPrjCoordinates(t),
                    i
            },
            update: function(e, t, i) {
                Array.isArray(t) ? n = t : (n = i._getPrjCoordinates()).push(t);
                var n, t = n.map(function(t) {
                    return e.unproject(t)
                });
                i.setCoordinates(t),
                    i._setPrjCoordinates(n)
            },
            generate: function(t) {
                return t
            }
        });
    function Ba(t) {
        for (var e = t.tileInfo, i = [e.cols, e.rows], n = [], r = e.lods, o = 0, s = r.length; o < s; o++)
            n.push(r[o].resolution);
        t = t.fullExtent,
            e = e.origin,
            e = [1, -1, e.x, e.y];
        return delete t.spatialReference,
            {
                spatialReference: {
                    resolutions: n,
                    fullExtent: t
                },
                tileSystem: e,
                tileSize: i
            }
    }
    function Va(i, t) {
        return (t = void 0 === t ? [] : t).forEach(function(t) {
            var e = t[0]
                , t = t[1];
            i = i.replace(e, t)
        }),
            i
    }
    function Ua(t, e, i) {
        var n = (new DOMParser).parseFromString(t, "text/xml").querySelectorAll("Contents")[0];
        if (!n)
            return [];
        var r = n.getElementsByTagName("Layer");
        if (!r.length)
            return [];
        for (var o = [], s = 0, a = n.childNodes.length; s < a; s++)
            "TileMatrixSet" === n.childNodes[s].nodeName && o.push(n.childNodes[s]);
        if (!o.length)
            return [];
        for (var h = [], l = 0, u = r.length; l < u; l++) {
            var c = r[l]
                , d = (d = (d = c.querySelectorAll("Style")[0]) && d.getElementsByTagName("ows:Identifier")[0]) && d.textContent
                , g = (g = c.getElementsByTagName("ows:Identifier")[0]) && g.textContent
                , c = c.querySelectorAll("ResourceURL")[0]
                , p = ""
                , c = (c && (p = c.attributes.template.value),
                function(t, e, i) {
                    void 0 === i && (i = {});
                    var n, r, t = t[e], o = t.getElementsByTagName("TileMatrix"), s = [], a = [], h = [];
                    if (!n) {
                        e = t.getElementsByTagName("ows:SupportedCRS")[0];
                        if (e) {
                            for (n = (n = e.textContent).split("EPSG")[1]; -1 < n.indexOf(":"); )
                                n = n.replace(":", "");
                            n = function(t) {
                                return Va(-1 < t.indexOf("EPSG") ? t : "EPSG:" + t, [["4490", "4326"], ["102100", "3857"], ["900913", "3857"]])
                            }(n)
                        }
                    }
                    r = r || (r = t.getElementsByTagName("ows:Identifier")[0]) && r.textContent;
                    var l = .0002645833333333333;
                    i.isArcgis && (l = 28e-5);
                    n && -1 < n.indexOf("4326") && (l = 2.3767925226029154e-9,
                    i.isArcgis && (l = 2.518101729011901e-9));
                    for (var u = 1 / 0, c = 0; c < o.length; c++) {
                        var d = o[c]
                            , g = d.getElementsByTagName("ows:Identifier")[0].textContent
                            , g = (g = parseInt(g),
                            u = Math.min(u, g),
                            d.getElementsByTagName("ScaleDenominator")[0].textContent)
                            , p = d.getElementsByTagName("TopLeftCorner")[0].textContent
                            , f = d.getElementsByTagName("TileWidth")[0].textContent
                            , d = d.getElementsByTagName("TileHeight")[0].textContent
                            , f = (0 === h.length && h.push(parseInt(f), parseInt(d)),
                        0 === a.length && (f = p.split(" ").filter(function(t) {
                            return "" !== t
                        }).map(function(t) {
                            return parseFloat(t)
                        }),
                            d = f[0],
                            p = f[1],
                            0 < d ? a.push(1, -1, p, d) : a.push(1, -1, d, p)),
                        parseFloat(g) * l);
                        s.push(f)
                    }
                    if (0 < u)
                        for (var m = s[0], _ = u - 1; 0 <= _; _--)
                            m *= 2,
                                s.splice(0, 0, m);
                    return {
                        resolutions: s,
                        tileSize: h,
                        tileSystem: a,
                        projection: n,
                        TileMatrixSet: r
                    }
                }(o, l, i))
                , f = c.resolutions
                , m = c.tileSize
                , _ = c.tileSystem
                , y = c.projection
                , c = c.TileMatrixSet
                , p = (p.length || (p = e.substr(0, e.lastIndexOf("?")),
                p += "?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER={LAYER}&STYLE={Style}&TILEMATRIXSET={TileMatrixSet}&FORMAT=tiles&TILEMATRIX={TileMatrix}&TILEROW={TileRow}&TILECOL={TileCol}"),
                Va(p, [["{LAYER}", g], ["{Layer}", g], ["{layer}", g], ["{STYLE}", d], ["{Style}", d], ["{style}", d], ["{TileMatrixSet}", c], ["{TileMatrix}", "{z}"], ["{TileRow}", "{y}"], ["{TileCol}", "{x}"]]));
            h.push({
                tileSize: m,
                tileSystem: _,
                spatialReference: {
                    resolutions: f,
                    projection: y
                },
                urlTemplate: p,
                info: {
                    layerName: g,
                    TileMatrixSet: c,
                    style: d,
                    tileSize: m,
                    tileSystem: _,
                    resolutions: f,
                    projection: y,
                    urlTemplate: p
                }
            })
        }
        return h
    }
    ta.registerMode("linestring", m({
        action: ["click", "mousemove", "dblclick"]
    }, w)),
        ta.registerMode("freeHandLinestring", m({
            action: ["mousedown", "mousemove", "mouseup"]
        }, w)),
        ta.registerMode("arccurve", {
            action: ["click", "mousemove", "dblclick"],
            create: function(e, t) {
                var i = t.map(function(t) {
                    return e.unproject(t)
                })
                    , i = new _s(i);
                return i._setPrjCoordinates(t),
                    i
            },
            update: w.update,
            generate: function(t) {
                return t
            }
        }),
        ta.registerMode("quadbeziercurve", {
            action: ["click", "mousemove", "dblclick"],
            create: function(e, t) {
                var i = t.map(function(t) {
                    return e.unproject(t)
                })
                    , i = new Ps(i);
                return i._setPrjCoordinates(t),
                    i
            },
            update: w.update,
            generate: function(t) {
                return t
            }
        }),
        ta.registerMode("cubicbeziercurve", {
            action: ["click", "mousemove", "dblclick"],
            create: function(e, t) {
                var i = t.map(function(t) {
                    return e.unproject(t)
                })
                    , i = new xs(i);
                return i._setPrjCoordinates(t),
                    i
            },
            update: w.update,
            generate: function(t) {
                return t
            }
        }),
        ta.registerMode("boxZoom", {
            action: ["mousedown", "mousemove", "mouseup"],
            create: function(t, e) {
                e = e[0];
                t = t.unproject(e),
                    t = new Ao(t);
                return t._firstClick = e,
                    t
            },
            update: function(t, e, i, n) {
                var r = i.getMap()
                    , o = r._prjToContainerPoint(i._firstClick)
                    , n = n.containerPoint
                    , r = (e = r._containerPointToPrj(new M(Math.min(o.x, n.x),Math.min(o.y, n.y))),
                    t.unproject(e));
                i.setCoordinates(r)._setPrjCoordinates(e),
                    i.updateSymbol({
                        markerWidth: Math.abs(o.x - n.x),
                        markerHeight: Math.abs(o.y - n.y)
                    })
            },
            generate: function(t) {
                return t
            }
        }),
        br.loadArcgis = function(t, i, e) {
            return void 0 === e && (e = {
                jsonp: !0
            }),
                b(t) && "{" !== t.substring(0, 1) ? _i.getJSON(t, function(t, e) {
                    t ? i(t) : (t = Ba(e),
                        i(null, t))
                }, e) : (e = Ba(t = b(t) ? rt(t) : t),
                    i(null, e)),
                this
        }
        ,
        br.loadWMTS = function(i, n, r) {
            return void 0 === r && (r = {
                jsonp: !0
            }),
            b(i) && _i.get(i, function(t, e) {
                t ? n(t) : (t = Ua(e, i, r),
                    n(null, t))
            }, r),
                this
        }
    ;
    s(Ya, Ja = Si(_e)),
        (w = Ya.prototype).addTo = function(t) {
            return this._owner = t,
                this._switchEvents("on"),
            this.onAdd && this.onAdd(),
                this.fire("add"),
                this
        }
        ,
        w.getMap = function() {
            return this._owner ? this._owner.getBaseLayer ? this._owner : this._owner.getMap() : null
        }
        ,
        w.show = function(t) {
            var e = this.getMap();
            if (!e)
                return this;
            this._mapEventsOn || this._switchMapEvents("on"),
                t = t || this._coordinate || this._owner.getCenter();
            var i = this.isVisible()
                , n = (this.fire("showstart"),
                this._getUIContainer())
                , t = (this._coordinate = t,
                this._removePrevDOM(),
                this.__uiDOM = this.buildOn(e));
            if (t.eventsPropagation = this.options.eventsPropagation,
                !t)
                return this.fire("showend"),
                    this;
            this._measureSize(t),
            this._singleton() && (e[this._uiDomKey()] = t),
                this._setPosition(),
                t.style[Ye] = null,
                n.appendChild(t);
            e = this._getAnimation(),
            i && (e.ok = !1),
            e.ok && (e.fade && (t.style.opacity = 0),
            e.scale && (this.getTransformOrigin && (n = this.getTransformOrigin(),
                t.style[qe] = n),
                t.style[Je] = this._toCSSTranslate(this._pos) + " scale(0)")),
                t.style.display = "",
            this.options.eventsToStop && _(t, this.options.eventsToStop, ii),
            this.options.autoPan && this._autoPan(),
                i = e.transition;
            return e.ok && i && (t.offsetHeight,
            i && (t.style[Ye] = i),
            e.fade && (t.style.opacity = 1),
            e.scale && (t.style[Je] = this._toCSSTranslate(this._pos) + " scale(1)")),
                this.fire("showend"),
                this
        }
        ,
        w.hide = function() {
            var t = this;
            if (!this.getDOM() || !this.getMap())
                return this;
            var e = this._getAnimation()
                , i = this.getDOM();
            return this.options.animationOnHide || (e.ok = !1),
                e.ok ? (i.offsetHeight,
                    i.style[Ye] = e.transition,
                    setTimeout(function() {
                        i.style.display = "none",
                            t.fire("hide")
                    }, this.options.animationDuration)) : (i.style.display = "none",
                    this.fire("hide")),
            e.fade && (i.style.opacity = 0),
            e.scale && (i.style[Je] = this._toCSSTranslate(this._pos) + " scale(0)"),
                this
        }
        ,
        w.isVisible = function() {
            var t = this.getDOM();
            return this.getMap() && t && t.parentNode && "none" !== t.style.display
        }
        ,
        w.remove = function() {
            return delete this._mapEventsOn,
            this._owner && (this.hide(),
                this._switchEvents("off"),
            this.onRemove && this.onRemove(),
            !this._singleton() && this.__uiDOM && this._removePrevDOM(),
                delete this._owner,
                this.fire("remove")),
                this
        }
        ,
        w.getSize = function() {
            return this._size ? this._size.copy() : null
        }
        ,
        w.getOwner = function() {
            return this._owner
        }
        ,
        w.getDOM = function() {
            return this.__uiDOM
        }
        ,
        w.getPosition = function() {
            if (!this.getMap())
                return null;
            var t, e = this._getViewPoint()._round();
            return this.getOffset && (t = this.getOffset()._round()) && e._add(t),
                e
        }
        ,
        w._getAnimation = function() {
            for (var t = {
                fade: !1,
                scale: !1
            }, e = this.options.animation ? this.options.animation.split(",") : [], i = 0; i < e.length; i++) {
                var n = De(e[i]);
                "fade" === n ? t.fade = !0 : "scale" === n && (t.scale = !0)
            }
            var r = null;
            return t.fade && (r = "opacity " + this.options.animationDuration + "ms"),
            t.scale && (r = r ? r + "," : "",
                r += Je + " " + this.options.animationDuration + "ms"),
                t.transition = r,
                t.ok = null !== r,
                t
        }
        ,
        w._getViewPoint = function() {
            var t, e = 0;
            return this._owner && this._owner.getAltitude && (0 < (t = this._owner.getAltitude()) && (e = this._meterToPoint(this._coordinate, t))),
                this.getMap().coordToViewPoint(this._coordinate, void 0, e)._add(this.options.dx, this.options.dy)
        }
        ,
        w._meterToPoint = function(t, e) {
            return this.getMap().distanceToPoint(e, 0, void 0, t).x * ht(e)
        }
        ,
        w._autoPan = function() {
            var t, e, i, n, r, o, s = this.getMap(), a = this.getDOM();
            s.isMoving() || (i = this._pos,
                t = (e = s.getSize()).width,
                e = e.height,
                i = s.viewPointToContainerPoint(i),
                n = parseInt(a.clientWidth),
                a = parseInt(a.clientHeight),
                i.x < (o = r = 0) ? r = -(i.x - n / 2) : i.x + n - 35 > t && (r = t - (i.x + 3 * n / 2)),
                i.y - a < 0 ? o = 50 - (i.y - a) : i.y > e && (o = e - i.y - a - 30),
            0 === o && 0 === r || s.panBy(new R(r,o), {
                duration: this.options.autoPanDuration
            }))
        }
        ,
        w._measureSize = function(t) {
            var e = this._getUIContainer()
                , i = (t.style.position = "absolute",
                t.style.left = "-99999px",
                t.style.bottom ? "bottom" : "top");
            return t.style[i] = "-99999px",
                t.style.display = "",
                e.appendChild(t),
                this._size = new Le(t.clientWidth,t.clientHeight),
                t.style.display = "none",
                t.style.left = "0px",
                t.style[i] = "0px",
                this._size
        }
        ,
        w._removePrevDOM = function() {
            this.onDomRemove && this.onDomRemove();
            var t, e, i = this.options.eventsToStop;
            this._singleton() ? ((t = this.getMap())[e = this._uiDomKey()] && (i && mi(t[e], i, ii),
                Ke(t[e]),
                delete t[e]),
                delete this.__uiDOM) : this.__uiDOM && (i && mi(this.__uiDOM, i, ii),
                Ke(this.__uiDOM),
                delete this.__uiDOM)
        }
        ,
        w._uiDomKey = function() {
            return "__ui_" + this._getClassName()
        }
        ,
        w._singleton = function() {
            return this.options.single
        }
        ,
        w._getUIContainer = function() {
            return this.getMap()._panels.ui
        }
        ,
        w._getClassName = function() {
            return "UIComponent"
        }
        ,
        w._switchMapEvents = function(t) {
            var e = this.getMap();
            if (e) {
                this._mapEventsOn = "on" === t;
                var i = this._getDefaultEvents();
                if (this.getEvents && m(i, this.getEvents()),
                    i)
                    for (var n in i)
                        i.hasOwnProperty(n) && e[t](n, i[n], this)
            }
        }
        ,
        w._switchEvents = function(t) {
            this._switchMapEvents(t);
            var e = this._getOwnerEvents();
            if (this._owner)
                for (var i in e)
                    e.hasOwnProperty(i) && this._owner[t](i, e[i], this)
        }
        ,
        w._getDefaultEvents = function() {
            return {
                "zooming rotate pitch": this.onEvent,
                zoomend: this.onZoomEnd,
                moving: this.onMoving,
                resize: this.onResize
            }
        }
        ,
        w._getOwnerEvents = function() {
            var t = {};
            return this._owner && this._owner instanceof y && (t.positionchange = this.onGeometryPositionChange),
            this.getOwnerEvents && m(t, this.getOwnerEvents()),
                t
        }
        ,
        w.onGeometryPositionChange = function(t) {
            this._owner && this.isVisible() && this.show(t.target.getCenter())
        }
        ,
        w.onMoving = function() {
            this.isVisible() && this.getMap().isTransforming() && this._updatePosition()
        }
        ,
        w.onEvent = function() {
            this.isVisible() && this._updatePosition()
        }
        ,
        w.onZoomEnd = function() {
            this.isVisible() && this._setPosition()
        }
        ,
        w.onResize = function() {
            this.isVisible() && this._setPosition()
        }
        ,
        w._updatePosition = function() {
            this.getMap()._getRenderer().callInNextFrame(this._setPosition.bind(this))
        }
        ,
        w._setPosition = function() {
            var t, e = this.getDOM();
            e && (e.style[Ye] = null,
                t = this.getPosition(),
                this._pos = t,
                e.style[Je] = this._toCSSTranslate(t) + " scale(1)")
        }
        ,
        w._toCSSTranslate = function(t) {
            return t ? c.any3d ? (e = (i = this.getMap()) ? i.getBearing() : 0,
                i = i ? i.getPitch() : 0,
                n = "",
            this.options.pitchWithMap && i && (n += " rotateX(" + Math.round(i) + "deg)"),
            this.options.rotateWithMap && e && (n += " rotateZ(" + Math.round(-e) + "deg)"),
            "translate3d(" + t.x + "px," + t.y + "px, 0px)" + n) : "translate(" + t.x + "px," + t.y + "px)" : "";
            var e, i, n
        }
        ,
        Ya.isSupport = function(t) {
            return !!(t && p(t.on) && p(t.off) && p(t.getCenter))
        }
    ;
    var Ja, qa = Ya;
    function Ya(t) {
        return Ja.call(this, t) || this
    }
    qa.mergeOptions({
        eventsPropagation: !1,
        eventsToStop: null,
        dx: 0,
        dy: 0,
        autoPan: !1,
        autoPanDuration: 600,
        single: !0,
        animation: "scale",
        animationOnHide: !0,
        animationDuration: 500,
        pitchWithMap: !1,
        rotateWithMap: !1
    });
    var Xa, Ka = "mousedown mouseup mouseenter mouseover mouseout mousemove click dblclick contextmenu keypress touchstart touchmove touchend", Qa = (s($a, Xa = Oi(qa)),
        (w = $a.prototype)._getClassName = function() {
            return "UIMarker"
        }
        ,
        w.setCoordinates = function(t) {
            return this._markerCoord = t,
                this.fire("positionchange"),
            this.isVisible() && (this._coordinate = this._markerCoord,
                this._setPosition()),
                this
        }
        ,
        w.getCoordinates = function() {
            return this._markerCoord
        }
        ,
        w.getCenter = function() {
            return this.getCoordinates()
        }
        ,
        w.getAltitude = function() {
            return this.options.altitude || 0
        }
        ,
        w.setContent = function(t) {
            var e = this.options.content;
            return this.options.content = t,
                this.fire("contentchange", {
                    old: e,
                    new: t
                }),
            this.isVisible() && this.show(),
                this
        }
        ,
        w.getContent = function() {
            return this.options.content
        }
        ,
        w.onAdd = function() {
            this.show()
        }
        ,
        w.show = function() {
            return Xa.prototype.show.call(this, this._markerCoord)
        }
        ,
        w.flash = function(t, e, i, n) {
            return bt.call(this, t, e, i, n)
        }
        ,
        w.buildOn = function() {
            var t;
            return b(this.options.content) ? (t = f("div")).innerHTML = this.options.content : t = this.options.content,
            this.options.containerClass && (t.className = this.options.containerClass),
                this._registerDOMEvents(t),
                t
        }
        ,
        w.getOffset = function() {
            var t = this.getSize();
            return new R(-t.width / 2,-t.height / 2)
        }
        ,
        w.getTransformOrigin = function() {
            return "center center"
        }
        ,
        w.onDomRemove = function() {
            var t = this.getDOM();
            this._removeDOMEvents(t)
        }
        ,
        w.isDragging = function() {
            return !!this.draggable && this.draggable.isDragging()
        }
        ,
        w._registerDOMEvents = function(t) {
            _(t, Ka, this._onDomEvents, this)
        }
        ,
        w._onDomEvents = function(t) {
            var e = this.getMap()._parseEvent(t, t.type);
            this.fire(t.type, e)
        }
        ,
        w._removeDOMEvents = function(t) {
            mi(t, Ka, this._onDomEvents, this)
        }
        ,
        w._getConnectPoints = function() {
            var t = this.getMap()
                , e = t.coordToContainerPoint(this.getCoordinates())
                , i = this.getSize()
                , n = i.width
                , i = i.height;
            return [t.containerPointToCoordinate(e.add(-n / 2, 0)), t.containerPointToCoordinate(e.add(n / 2, 0)), t.containerPointToCoordinate(e.add(0, i / 2)), t.containerPointToCoordinate(e.add(0, -i / 2))]
        }
        ,
        w._getViewPoint = function() {
            var t, e = 0;
            return this._owner && 0 < (t = this.getAltitude()) && (e = this._meterToPoint(this._coordinate, t)),
                this.getMap().coordToViewPoint(this._coordinate, void 0, e)._add(this.options.dx, this.options.dy)
        }
        ,
        $a);
    function $a(t, e) {
        e = Xa.call(this, e) || this;
        return e._markerCoord = new M(t),
            e
    }
    Qa.mergeOptions({
        containerClass: null,
        eventsPropagation: !0,
        draggable: !1,
        single: !1,
        content: null,
        altitude: 0
    });
    var th, eh = c.touch ? "touchstart mousedown" : "mousedown", w = (s(ih, th = ki),
        (w = ih.prototype).addHooks = function() {
            this.target.on(eh, this._startDrag, this)
        }
        ,
        w.removeHooks = function() {
            this.target.off(eh, this._startDrag, this)
        }
        ,
        w._startDrag = function(t) {
            var e = t.domEvent;
            e.touches && 1 < e.touches.length || 2 === e.button || this.isDragging() || (this.target.on("click", this._endDrag, this),
                this._lastCoord = t.coordinate,
                this._lastPoint = t.containerPoint,
                this._prepareDragHandler(),
                this._dragHandler.onMouseDown(t.domEvent),
                this.target.fire("dragstart", t))
        }
        ,
        w._prepareDragHandler = function() {
            this._dragHandler = new Zi(this.target.getDOM(),{
                cancelOn: this._cancelOn.bind(this),
                ignoreMouseleave: !0
            }),
                this._dragHandler.on("mousedown", this._onMouseDown, this),
                this._dragHandler.on("dragging", this._dragging, this),
                this._dragHandler.on("mouseup", this._endDrag, this),
                this._dragHandler.enable()
        }
        ,
        w._cancelOn = function(t) {
            t = (t.srcElement || t.target).tagName.toLowerCase();
            return "button" === t || "input" === t || "select" === t || "option" === t || "textarea" === t
        }
        ,
        w._onMouseDown = function(t) {
            ii(t.domEvent)
        }
        ,
        w._dragging = function(t) {
            var e, i, n, r = this.target, t = r.getMap()._parseEvent(t.domEvent), o = t.domEvent;
            o.touches && 1 < o.touches.length || (this._isDragging ? (o = t.coordinate,
                e = t.containerPoint,
            this._lastCoord || (this._lastCoord = o),
            this._lastPoint || (this._lastPoint = e),
                i = o.sub(this._lastCoord),
                n = e.sub(this._lastPoint),
                this._lastCoord = o,
                this._lastPoint = e,
                this.target.setCoordinates(this.target.getCoordinates().add(i)),
                t.coordOffset = i,
                t.pointOffset = n,
                r.fire("dragging", t)) : this._isDragging = !0)
        }
        ,
        w._endDrag = function(t) {
            var e = this.target
                , i = e.getMap();
            this._dragHandler && (e.off("click", this._endDrag, this),
                this._dragHandler.disable(),
                delete this._dragHandler),
                delete this._lastCoord,
                delete this._lastPoint,
                this._isDragging = !1,
            i && (i = i._parseEvent(t.domEvent),
                e.fire("dragend", i))
        }
        ,
        w.isDragging = function() {
            return !!this._isDragging
        }
        ,
        ih);
    function ih(t) {
        return th.call(this, t) || this
    }
    Qa.addInitHook("addHandler", "draggable", w);
    s(oh, nh = qa),
        (w = oh.prototype)._getClassName = function() {
            return "InfoWindow"
        }
        ,
        w.addTo = function(t) {
            return t instanceof y && (t.getInfoWindow() && t.getInfoWindow() !== this && t.removeInfoWindow(),
                t._infoWindow = this),
                nh.prototype.addTo.call(this, t)
        }
        ,
        w.setContent = function(t) {
            var e = this.options.content;
            return this.options.content = t,
                this.fire("contentchange", {
                    old: e,
                    new: t
                }),
            this.isVisible() && this.show(this._coordinate),
                this
        }
        ,
        w.setContentAndCoord = function(t, e) {
            var i = this.options.content;
            return this.options.content = t,
                this.fire("contentchange", {
                    old: i,
                    new: t
                }),
                this.show(e),
                this
        }
        ,
        w.getContent = function() {
            return this.options.content
        }
        ,
        w.setTitle = function(t) {
            var e = t;
            return this.options.title = t,
                this.fire("contentchange", {
                    old: e,
                    new: t
                }),
            this.isVisible() && this.show(this._coordinate),
                this
        }
        ,
        w.getTitle = function() {
            return this.options.title
        }
        ,
        w.buildOn = function() {
            if (this.options.custom)
                return b(this.options.content) ? ((t = f("div")).innerHTML = this.options.content,
                    t) : this.options.content;
            var t = f("div")
                , e = (this.options.containerClass && (t.className = this.options.containerClass),
                t.style.width = this._getWindowWidth() + "px",
                t.style.bottom = "0px",
                '<em class="maptalks-ico"></em>')
                , e = (this.options.title && (e += "<h2>" + this.options.title + "</h2>"),
                t.innerHTML = e += '<a href="javascript:void(0);" class="maptalks-close"></a><div class="maptalks-msgContent"></div>',
                t.querySelector(".maptalks-msgContent"));
            return b(this.options.content) ? e.innerHTML = this.options.content : e.appendChild(this.options.content),
                this._onCloseBtnClick = this.hide.bind(this),
                Qe(t.querySelector(".maptalks-close"), "click touchend", this._onCloseBtnClick),
                t
        }
        ,
        w.getTransformOrigin = function() {
            return this.getSize().width / 2 + "px bottom"
        }
        ,
        w.getOffset = function() {
            var t, e, i = this.getSize(), n = new R(-i.width / 2,0), i = (this.options.custom ? n._sub(0, i.height) : n._sub(4, 12),
                this.getOwner());
            if (i instanceof Ao || i instanceof Bo) {
                if (i instanceof Ao)
                    t = i._getPainter(),
                        e = i.getSize();
                else {
                    i = i.getGeometries();
                    if (!i || !i.length)
                        return n;
                    t = i[0]._getPainter(),
                        e = i[0].getSize()
                }
                t ? (i = t.getFixedExtent(),
                    n._add(i.xmax - e.width / 2, i.ymin)) : n._add(0, -e.height)
            }
            return n
        }
        ,
        w.show = function(t) {
            return this.getMap() && this.getMap().options.enableInfoWindow ? nh.prototype.show.call(this, t) : this
        }
        ,
        w.getEvents = function() {
            if (!this.options.autoCloseOn)
                return null;
            var t = {};
            return t[this.options.autoCloseOn] = this.hide,
                t
        }
        ,
        w.getOwnerEvents = function() {
            var t = this.getOwner();
            if (!this.options.autoOpenOn || !t)
                return null;
            t = {};
            return t[this.options.autoOpenOn] = this._onAutoOpen,
                t
        }
        ,
        w.onRemove = function() {
            this.onDomRemove()
        }
        ,
        w.onDomRemove = function() {
            this._onCloseBtnClick && ($e(this.getDOM().childNodes[2], "click touchend", this._onCloseBtnClick),
                delete this._onCloseBtnClick)
        }
        ,
        w._onAutoOpen = function(t) {
            var e = this
                , i = this.getOwner();
            setTimeout(function() {
                i instanceof Ao || i instanceof qa ? e.show(i.getCoordinates()) : i instanceof Bo ? e.show(i.findClosest(t.coordinate)) : ((i instanceof Io || i instanceof Yo) && 8 <= e.getMap().getScale() && (t.coordinate = e._rectifyMouseCoordinte(i, t.coordinate)),
                    e.show(t.coordinate))
            }, 1)
        }
        ,
        w._rectifyMouseCoordinte = function(t, e) {
            var i = this;
            return t instanceof Io ? this._rectifyLineStringMouseCoordinate(t, e).coordinate : t instanceof Yo ? t.getGeometries().map(function(t) {
                return i._rectifyLineStringMouseCoordinate(t, e)
            }).sort(function(t, e) {
                return t.dis - e.dis
            })[0].coordinate : e
        }
        ,
        w._rectifyLineStringMouseCoordinate = function(t, e) {
            for (var i = this, n = t.getCoordinates().map(function(t) {
                return i.getMap().coordToContainerPoint(t)
            }), r = this.getMap().coordToContainerPoint(e), o = 1 / 0, s = -1, a = 0, h = n.length; a < h; a++) {
                var l = n[a]
                    , l = r.distanceTo(l);
                l < o && (o = l,
                    s = a)
            }
            for (var u = [], c = (0 === s ? u.push(n[0], n[1]) : s === n.length - 1 ? u.push(n[s - 1], n[s]) : u.push(n[s - 1], n[s], n[s + 1]),
                []), t = this.getMap().getSize(), d = t.width, g = t.height, p = 0, f = u.length - 1; p < f; p++) {
                var m = u[p]
                    , _ = u[p + 1];
                if (m.x === _.x)
                    for (var y = Math.max(0, Math.min(m.y, _.y)), v = Math.min(g, Math.max(m.y, _.y)), x = y; x <= v; x++)
                        c.push(new R(m.x,x));
                else
                    for (var w = (_.y - m.y) / (_.x - m.x), y = Math.max(0, Math.min(m.x, _.x)), C = Math.min(d, Math.max(m.x, _.x)), P = y; P <= C; P++) {
                        var b = w * (P - m.x) + m.y;
                        c.push(new R(P,b))
                    }
            }
            for (var M = 1 / 0, S = -1, T = 0, E = c.length; T < E; T++) {
                var k = c[T]
                    , k = r.distanceTo(k);
                k < M && (M = k,
                    S = T)
            }
            return {
                dis: M,
                coordinate: S < 0 ? e : this.getMap().containerPointToCoord(c[S])
            }
        }
        ,
        w._getWindowWidth = function() {
            return this.options.width || 300
        }
    ;
    var nh, rh = oh;
    function oh() {
        return nh.apply(this, arguments) || this
    }
    rh.mergeOptions({
        containerClass: "maptalks-msgBox",
        autoPan: !0,
        autoCloseOn: null,
        autoOpenOn: "click",
        width: 300,
        minHeight: 120,
        custom: !1,
        title: null,
        content: null
    });
    s(ah, sh = qa),
        (w = ah.prototype)._getClassName = function() {
            return "ToolTip"
        }
        ,
        w.addTo = function(t) {
            if (ah.isSupport(t))
                return t.on("mousemove", this.onMouseMove, this),
                    t.on("mouseout", this.onMouseOut, this),
                    sh.prototype.addTo.call(this, t);
            throw new Error("Invalid geometry or UIMarker the tooltip is added to.")
        }
        ,
        w.setStyle = function(t) {
            return this.options.containerClass = t,
                this
        }
        ,
        w.getStyle = function() {
            return this.options.containerClass
        }
        ,
        w.getContent = function() {
            return this._content
        }
        ,
        w.buildOn = function() {
            var t = f("div")
                , e = this.options || {}
                , i = (e.height && (t.style.height = e.height + "px"),
            e.width && (t.style.width = e.width + "px"),
            e.containerClass || e.cssName);
            return !i && e.height && (t.style.lineHeight = e.height + "px"),
                t.innerHTML = '<div class="' + i + '">' + this._content + "</div>",
                t
        }
        ,
        w.onMouseOut = function() {
            clearTimeout(this._timeout),
            this.isVisible() && this._removePrevDOM()
        }
        ,
        w.onMouseMove = function(t) {
            var e, i = this, n = (clearTimeout(this._timeout),
                this.getMap());
            n && (e = n.locateByPoint(t.coordinate, -5, 25),
                0 === this.options.showTimeout ? this.show(e) : this._timeout = setTimeout(function() {
                    n && i.show(e)
                }, this.options.showTimeout))
        }
        ,
        w.onRemove = function() {
            clearTimeout(this._timeout),
            this._owner && (this._owner.off("mouseover", this.onMouseOver, this),
                this._owner.off("mouseout", this.onMouseOut, this))
        }
        ,
        w._getViewPoint = function() {
            return this.getMap().coordToViewPoint(this._coordinate, void 0, 0)._add(this.options.dx, this.options.dy)
        }
    ;
    var sh, w = ah;
    function ah(t, e) {
        return (e = sh.call(this, e = void 0 === e ? {} : e) || this)._content = t,
            e
    }
    w.mergeOptions({
        width: 0,
        height: 0,
        animation: "fade",
        containerClass: "maptalks-tooltip",
        showTimeout: 400
    });
    s(uh, hh = qa),
        (C = uh.prototype)._getClassName = function() {
            return "Menu"
        }
        ,
        C.addTo = function(t) {
            return t._menu && t._menu !== this && t.removeMenu(),
                t._menu = this,
                qa.prototype.addTo.apply(this, arguments)
        }
        ,
        C.setItems = function(t) {
            return this.options.items = t,
                this
        }
        ,
        C.getItems = function() {
            return this.options.items || []
        }
        ,
        C.buildOn = function() {
            var t, e;
            return this.options.custom ? b(this.options.items) ? ((t = f("div")).innerHTML = this.options.items,
                t) : this.options.items : (t = f("div"),
            this.options.containerClass && li(t, this.options.containerClass),
                t.style.width = this._getMenuWidth() + "px",
                e = this._createMenuItemDom(),
                t.appendChild(e),
                _(t, "contextmenu", ei),
                t)
        }
        ,
        C.getOffset = function() {
            if (!this.getMap())
                return null;
            var t = this.getMap().getSize()
                , e = this.getMap().viewPointToContainerPoint(this._getViewPoint())
                , i = this.getSize()
                , n = 0
                , r = 0;
            return e.x + i.width > t.width && (n = -i.width),
            e.y + i.height > t.height && (r = -i.height),
                new R(n,r)
        }
        ,
        C.getTransformOrigin = function() {
            var t = this.getOffset()._multi(-1);
            return t.x + "px " + t.y + "px"
        }
        ,
        C.getEvents = function() {
            return {
                "_zoomstart _zoomend _movestart _dblclick _click": this._removePrevDOM
            }
        }
        ,
        C._createMenuItemDom = function() {
            var i = this
                , n = this.getMap()
                , t = f("ul")
                , e = (li(t, "maptalks-menu-items"),
                this.getItems());
            for (var r, o, s, a = 0, h = e.length; a < h; a++)
                "-" === (s = e[a]) || "_" === s ? li(r = f("li"), "maptalks-menu-splitter") : (r = f("li"),
                p(o = s.item) && (o = o({
                    owner: this._owner,
                    index: a
                })),
                    r.innerHTML = o,
                    r._callback = s.click,
                    _(r, "click", function(e) {
                        return function(t) {
                            t = n._parseEvent(t, "click");
                            t.target = i,
                                t.owner = i._owner,
                                t.index = e,
                            !1 !== this._callback(t) && i.hide()
                        }
                    }(a))),
                    t.appendChild(r);
            var l = this.options.maxHeight || 0;
            return 0 < l && ai(t, "max-height: " + l + "px; overflow-y: auto;"),
                t
        }
        ,
        C._getMenuWidth = function() {
            return this.options.width || 160
        }
    ;
    var hh, lh = uh;
    function uh(t) {
        return hh.call(this, t) || this
    }
    lh.mergeOptions({
        containerClass: "maptalks-menu",
        animation: null,
        animationDelay: 10,
        animationOnHide: !1,
        autoPan: !1,
        width: 160,
        maxHeight: 0,
        custom: !1,
        items: []
    });
    var ch, C = {
        setMenu: function(t) {
            return this._menuOptions = t,
                this._menu ? this._menu.setOptions(t) : this.on("contextmenu", this._defaultOpenMenu, this),
                this
        },
        openMenu: function(t) {
            var e = this instanceof h ? this : this.getMap();
            return t = t || this.getCenter(),
                this._menu ? this._menu.show(t) : this._menuOptions && e && (this._bindMenu(this._menuOptions),
                    this._menu.show(t)),
                this
        },
        setMenuItems: function(t) {
            return this._menuOptions || (this._menuOptions = {}),
            Array.isArray(t) && (this._menuOptions.custom = !1),
                this._menuOptions.items = t,
                this.setMenu(this._menuOptions),
                this
        },
        getMenuItems: function() {
            return this._menu ? this._menu.getItems() : this._menuOptions && this._menuOptions.items || []
        },
        closeMenu: function() {
            return this._menu && this._menu.hide(),
                this
        },
        removeMenu: function() {
            return this.off("contextmenu", this._defaultOpenMenu, this),
                this._unbindMenu(),
                delete this._menuOptions,
                this
        },
        _bindMenu: function(t) {
            return this._menu = new lh(t),
                this._menu.addTo(this),
                this
        },
        _unbindMenu: function() {
            return this._menu && (this.closeMenu(),
                this._menu.remove(),
                delete this._menu),
                this
        },
        _defaultOpenMenu: function(t) {
            return 1 < this.listens("contextmenu") || (this.openMenu(t.coordinate),
                !1)
        }
    }, w = (h.include(C),
        y.include(C),
        Object.freeze({
            UIComponent: qa,
            UIMarker: Qa,
            InfoWindow: rh,
            ToolTip: w,
            Menuable: C,
            Menu: lh
        })), dh = (s(gh, ch = Si(_e)),
        (C = gh.prototype).addTo = function(t) {
            if (this.remove(),
                !t.options.control)
                return this;
            t = (this._map = t)._panels.control;
            return this.__ctrlContainer = f("div"),
                ai(this.__ctrlContainer, "position:absolute;overflow:visible;"),
                this.update(),
                t.appendChild(this.__ctrlContainer),
            this.onAdd && this.onAdd(),
                this.fire("add", {
                    dom: t
                }),
                this
        }
        ,
        C.update = function() {
            return this.__ctrlContainer.innerHTML = "",
                this._controlDom = this.buildOn(this.getMap()),
            this._controlDom && (this._updatePosition(),
                this.__ctrlContainer.appendChild(this._controlDom)),
                this
        }
        ,
        C.getMap = function() {
            return this._map
        }
        ,
        C.getPosition = function() {
            return m({}, this._parse(this.options.position))
        }
        ,
        C.setPosition = function(t) {
            return b(t) ? this.options.position = t : this.options.position = m({}, t),
                this._updatePosition(),
                this
        }
        ,
        C.getContainerPoint = function() {
            var t, e, i = this.getPosition(), n = this.getMap().getSize();
            return V(i.left) ? V(i.right) || (t = n.width - parseInt(i.right)) : t = parseInt(i.left),
                V(i.top) ? V(i.bottom) || (e = n.height - parseInt(i.bottom)) : e = parseInt(i.top),
                new R(t,e)
        }
        ,
        C.getContainer = function() {
            return this.__ctrlContainer
        }
        ,
        C.getDOM = function() {
            return this._controlDom
        }
        ,
        C.show = function() {
            return this.__ctrlContainer.style.display = "",
                this
        }
        ,
        C.hide = function() {
            return this.__ctrlContainer.style.display = "none",
                this
        }
        ,
        C.isVisible = function() {
            return this.__ctrlContainer && "" === this.__ctrlContainer.style.display
        }
        ,
        C.remove = function() {
            return this._map && (Ke(this.__ctrlContainer),
            this.onRemove && this.onRemove(),
                delete this._map,
                delete this.__ctrlContainer,
                delete this._controlDom,
                this.fire("remove")),
                this
        }
        ,
        C._parse = function(t) {
            var e = t;
            return e = b(t) ? gh.positions[e] : e
        }
        ,
        C._updatePosition = function() {
            var t, e = this.getPosition();
            for (t in e = e || {
                top: 20,
                left: 20
            })
                e.hasOwnProperty(t) && (e[t] = parseInt(e[t]),
                    this.__ctrlContainer.style[t] = e[t] + "px");
            this.fire("positionchange", {
                position: m({}, e)
            })
        }
        ,
        gh);
    function gh(t) {
        return t && t.position && !b(t.position) && (t.position = m({}, t.position)),
        ch.call(this, t) || this
    }
    dh.positions = {
        "top-left": {
            top: 20,
            left: 20
        },
        "top-right": {
            top: 20,
            right: 20
        },
        "bottom-left": {
            bottom: 20,
            left: 20
        },
        "bottom-right": {
            bottom: 20,
            right: 20
        }
    },
        h.mergeOptions({
            control: !0
        }),
        h.include({
            addControl: function(t) {
                return this._containerDOM.getContext || t.addTo(this),
                    this
            },
            removeControl: function(t) {
                return t && t.getMap() === this && t.remove(),
                    this
            }
        });
    var ph, fh = "addlayer removelayer setbaselayer baselayerremove", mh = (s(_h, ph = dh),
        (C = _h.prototype).buildOn = function() {
            return this._attributionContainer = f("div"),
                this._attributionContainer.className = "maptalks-attribution",
                this._update(),
                this._attributionContainer
        }
        ,
        C.onAdd = function() {
            this.getMap().on(fh, this._update, this)
        }
        ,
        C.onRemove = function() {
            this.getMap().off(fh, this._update, this)
        }
        ,
        C._update = function() {
            var t = this.getMap();
            t && (t = t._getLayers(function(t) {
                return t.options.attribution
            }).reverse().map(function(t) {
                return t.options.attribution
            }),
                t = this.options.content + (0 < t.length ? " - " + t.join(", ") : ""),
                this._attributionContainer.innerHTML = '<span style="padding:0px 4px">' + t + "</span>")
        }
        ,
        _h);
    function _h() {
        return ph.apply(this, arguments) || this
    }
    mh.mergeOptions({
        position: {
            bottom: 0,
            left: 0
        },
        content: '<a href="http://maptalks.org" target="_blank">maptalks</a>'
    }),
        h.mergeOptions({
            attribution: !0
        }),
        h.addOnLoadHook(function() {
            var t = this.options.attribution || this.options.attributionControl;
            t && (this.attributionControl = new mh(t),
                this.addControl(this.attributionControl))
        });
    s(xh, yh = dh),
        (C = xh.prototype).buildOn = function() {
            var t = this.container = f("div", this.options.containerClass)
                , e = this.panel = f("div", "panel")
                , i = this.button = f("button");
            return t.appendChild(i),
                t.appendChild(e),
                t
        }
        ,
        C.onAdd = function() {
            _(this.button, "mouseover", this._show, this),
                _(this.panel, "mouseleave", this._hide, this),
                _(this.getMap(), "click", this._hide, this)
        }
        ,
        C.onRemove = function() {
            this.panel && (mi(this.button, "mouseover", this._show, this),
                mi(this.panel, "mouseleave", this._hide, this),
                mi(this.getMap(), "click", this._hide, this),
                Ke(this.panel),
                Ke(this.button),
                delete this.panel,
                delete this.button,
                delete this.container)
        }
        ,
        C._show = function() {
            hi(this.container, "shown") || (li(this.container, "shown"),
                this._createPanel())
        }
        ,
        C._hide = function(t) {
            this.panel.contains(t.toElement || t.relatedTarget) || ui(this.container, this.options.containerClass)
        }
        ,
        C._createPanel = function() {
            this.panel.innerHTML = "";
            var t = f("ul");
            this.panel.appendChild(t),
                this._renderLayers(this.getMap(), t)
        }
        ,
        C._renderLayers = function(t, e) {
            var i = t.getBaseLayer()
                , n = t.getLayers()
                , r = n.length;
            if (i) {
                var o = i.layers || [i]
                    , s = f("li", "group")
                    , a = f("ul")
                    , t = f("label");
                t.innerHTML = this.options.baseTitle,
                    s.appendChild(t);
                for (var h = 0, l = o.length; h < l; h++) {
                    var u = o[h];
                    this._isExcluded(u) && (a.appendChild(this._renderLayer(o[h], !0)),
                        s.appendChild(a),
                        e.appendChild(s))
                }
            }
            if (r) {
                var i = f("li", "group")
                    , c = f("ul")
                    , t = f("label");
                t.innerHTML = this.options.overlayTitle,
                    i.appendChild(t);
                for (var d = 0; d < r; d++) {
                    var g = n[d];
                    this._isExcluded(g) && c.appendChild(this._renderLayer(g))
                }
                i.appendChild(c),
                    e.appendChild(i)
            }
        }
        ,
        C._isExcluded = function(t) {
            var t = t.getId()
                , e = this.options.excludeLayers;
            return !(e.length && 0 <= e.indexOf(t))
        }
        ,
        C._renderLayer = function(s, t) {
            var a = this
                , e = f("li", "layer")
                , i = f("label")
                , n = f("input")
                , h = this.getMap()
                , r = s.options.visible
                , o = (s.options.visible = !0,
                s.isVisible());
            return s.options.visible = r,
                e.className = "layer",
                t ? (n.type = "radio",
                    n.name = "base") : n.type = "checkbox",
                n.checked = r && o,
            o || n.setAttribute("disabled", "disabled"),
                n.onchange = function(t) {
                    if ("radio" === t.target.type) {
                        var e = h.getBaseLayer()
                            , i = e.layers;
                        if (i)
                            for (var n = 0, r = i.length; n < r; n++) {
                                var o = i[n];
                                o[o === s ? "show" : "hide"]()
                            }
                        else
                            e.isVisible() || e.show();
                        h._fireEvent("setbaselayer")
                    } else
                        s[t.target.checked ? "show" : "hide"]();
                    a.fire("layerchange", {
                        target: s
                    })
                }
                ,
                e.appendChild(n),
                i.innerHTML = s.getId(),
                e.appendChild(i),
                e
        }
    ;
    var yh, vh = xh;
    function xh() {
        return yh.apply(this, arguments) || this
    }
    vh.mergeOptions({
        position: "top-right",
        baseTitle: "Base Layers",
        overlayTitle: "Layers",
        excludeLayers: [],
        containerClass: "maptalks-layer-switcher"
    }),
        h.mergeOptions({
            layerSwitcherControl: !1
        }),
        h.addOnLoadHook(function() {
            this.options.layerSwitcherControl && (this.layerSwitcherControl = new vh(this.options.layerSwitcherControl),
                this.addControl(this.layerSwitcherControl))
        });
    s(Ph, wh = dh),
        (C = Ph.prototype).buildOn = function() {
            var t = this.options.size
                , e = (this.options.maximize || (t = [0, 0]),
                f("div"))
                , i = this.mapContainer = f("div")
                , t = (i.style.width = t[0] + "px",
                i.style.height = t[1] + "px",
                i.className = this.options.containerClass,
                this.button = f("div"));
            return t.className = this.options.buttonClass,
                e.appendChild(i),
                e.appendChild(t),
                e
        }
        ,
        C.onAdd = function() {
            this.options.maximize && this._createOverview(),
                this.getMap().on("resize moving zooming rotate dragrotating viewchange", this._update, this).on("setbaselayer", this._updateBaseLayer, this).on("spatialreferencechange", this._updateSpatialReference, this),
                _(this.button, "click", this._onButtonClick, this),
                this._updateButtonText()
        }
        ,
        C.onRemove = function() {
            this.getMap().off("resize moving zooming rotate dragrotating viewchange", this._update, this).off("setbaselayer", this._updateBaseLayer, this).off("spatialreferencechange", this._updateSpatialReference, this),
            this._overview && (this._overview.remove(),
                delete this._overview,
                delete this._perspective),
                mi(this.button, "click", this._onButtonClick, this)
        }
        ,
        C.maxmize = function() {
            var t = this.options.size
                , e = this.mapContainer;
            return e.style.width = t[0] + "px",
                e.style.height = t[1] + "px",
                this._createOverview(),
                this
        }
        ,
        C.minimize = function() {
            this._overview && this._overview.remove(),
                delete this._overview,
                delete this._perspective;
            var t = this.mapContainer;
            return t.style.width = "0px",
                t.style.height = "0px",
                this
        }
        ,
        C.getOverviewMap = function() {
            return this._overview
        }
        ,
        C._onButtonClick = function() {
            this._overview ? this.minimize() : this.maxmize(),
                this._updateButtonText()
        }
        ,
        C._updateButtonText = function() {
            this._overview ? this.button.innerHTML = "-" : this.button.innerHTML = "+"
        }
        ,
        C._createOverview = function() {
            var t = this.getMap()
                , e = this.mapContainer
                , i = t.config();
            m(i, {
                center: t.getCenter(),
                zoom: this._getOverviewZoom(),
                zoomAnimationDuration: 150,
                pitch: 0,
                bearing: 0,
                scrollWheelZoom: !1,
                checkSize: !1,
                doubleClickZoom: !1,
                touchZoom: !1,
                control: !1,
                draggable: !1,
                maxExtent: null
            }),
                this._overview = new h(e,i),
                this._updateBaseLayer(),
                this._perspective = new S(this._getPerspectiveCoords(),{
                    draggable: !0,
                    cursor: "move",
                    symbol: this.options.symbol
                }).on("dragend", this._onDragEnd, this),
                new Us("perspective_layer",this._perspective).addTo(this._overview),
                this.fire("load")
        }
        ,
        C._getOverviewZoom = function() {
            var t = this.getMap()
                , e = t.getZoom()
                , i = t.getMinZoom()
                , t = this.options.level;
            if (0 < t) {
                for (var n = t; 0 < n; n--)
                    if (i <= e - n)
                        return e - n
            } else
                for (var r = t; r < 0; r++)
                    if (i <= e - r)
                        return e - r;
            return e
        }
        ,
        C._onDragEnd = function() {
            var t = this._perspective.getCenter();
            this._overview.setCenter(t),
                this.getMap().panTo(t)
        }
        ,
        C._getPerspectiveCoords = function() {
            var e = this.getMap();
            return e.getContainerExtent().toArray().map(function(t) {
                return e.containerPointToCoordinate(t)
            })
        }
        ,
        C._update = function() {
            var t;
            this._overview && (oi(this._overview._containerDOM),
                t = this._getPerspectiveCoords(),
                this._perspective.setCoordinates(t),
                this._overview.setCenterAndZoom(this.getMap().getCenter(), this._getOverviewZoom()))
        }
        ,
        C._updateSpatialReference = function() {
            var t;
            this._overview && (t = this.getMap().options.spatialReference,
                this._overview.setSpatialReference(t))
        }
        ,
        C._updateBaseLayer = function() {
            if (this._overview) {
                var t = this.getMap().getBaseLayer();
                if (t) {
                    var e = t.layers
                        , i = 0;
                    if (e)
                        for (var n = 0, r = e.length; n < r; n++)
                            if (e[n].isVisible()) {
                                i = n;
                                break
                            }
                    var o, s = t.toJSON(), a = null, h = (e ? (a = s.layers[i].options).visible = !0 : a = s.options,
                        this._overview.setMinZoom(a.minZoom || null).setMaxZoom(a.maxZoom || null),
                        delete a.minZoom,
                        delete a.maxZoom,
                        delete s.options.canvas,
                        s.options.visible = !0,
                        s.options.renderer = "canvas",
                        kr.fromJSON(s));
                    for (o in t)
                        p(t[o]) && t.hasOwnProperty(o) && t[o] !== t.constructor.prototype[o] && (h[o] = t[o]);
                    this._overview.setBaseLayer(h)
                } else
                    this._overview.setBaseLayer(null)
            }
        }
    ;
    var wh, Ch = Ph;
    function Ph() {
        return wh.apply(this, arguments) || this
    }
    Ch.mergeOptions({
        level: 4,
        position: {
            right: 1,
            bottom: 1
        },
        size: [300, 200],
        maximize: !0,
        symbol: {
            lineWidth: 3,
            lineColor: "#1bbc9b",
            polygonFill: "#1bbc9b",
            polygonOpacity: .4
        },
        containerClass: "maptalks-overview",
        buttonClass: "maptalks-overview-button"
    }),
        h.mergeOptions({
            overviewControl: !1
        }),
        h.addOnLoadHook(function() {
            this.options.overviewControl && (this.overviewControl = new Ch(this.options.overviewControl),
                this.addControl(this.overviewControl))
        });
    s(Mh, bh = dh),
        (C = Mh.prototype).buildOn = function() {
            var t, e;
            return this.options.custom ? b(this.options.content) ? (t = f("div")).innerHTML = this.options.content : t = this.options.content : (t = f("div", "maptalks-panel"),
            this.options.closeButton && ((e = f("a", "maptalks-close")).href = "javascript:;",
                e.onclick = function() {
                    t.style.display = "none"
                }
                ,
                t.appendChild(e)),
                (e = f("div", "maptalks-panel-content")).innerHTML = this.options.content,
                t.appendChild(e)),
                this.draggable = new Zi(t,{
                    cancelOn: this._cancelOn.bind(this),
                    ignoreMouseleave: !0
                }),
                this.draggable.on("dragstart", this._onDragStart, this).on("dragging", this._onDragging, this).on("dragend", this._onDragEnd, this),
            this.options.draggable && this.draggable.enable(),
                t
        }
        ,
        C.update = function() {
            return this.draggable && (this.draggable.disable(),
                delete this.draggable),
                dh.prototype.update.call(this)
        }
        ,
        C.setContent = function(t) {
            var e = this.options.content;
            return this.options.content = t,
                this.fire("contentchange", {
                    old: e,
                    new: t
                }),
            this.isVisible() && this.update(),
                this
        }
        ,
        C.getContent = function() {
            return this.options.content
        }
        ,
        C._cancelOn = function(t) {
            t = (t.srcElement || t.target).tagName.toLowerCase();
            return "button" === t || "input" === t || "select" === t || "option" === t || "textarea" === t
        }
        ,
        C._onDragStart = function(t) {
            this._startPos = t.mousePos,
                this._startPosition = m({}, this.getPosition()),
                this.fire("dragstart", t)
        }
        ,
        C._onDragging = function(t) {
            var e = t.mousePos.sub(this._startPos)
                , i = this._startPosition
                , n = this.getPosition();
            V(n.top) || (n.top = parseInt(i.top) + e.y),
            V(n.bottom) || (n.bottom = parseInt(i.bottom) - e.y),
            V(n.left) || (n.left = parseInt(i.left) + e.x),
            V(n.right) || (n.right = parseInt(i.right) - e.x),
                this.setPosition(n),
                this.fire("dragging", t)
        }
        ,
        C._onDragEnd = function(t) {
            delete this._startPos,
                delete this._startPosition,
                this.fire("dragend", t)
        }
        ,
        C._getConnectPoints = function() {
            var t = this.getMap()
                , e = this.getContainerPoint()
                , i = this.getDOM()
                , n = parseInt(i.clientWidth)
                , i = parseInt(i.clientHeight);
            return [t.containerPointToCoordinate(e.add(n / 2, 0)), t.containerPointToCoordinate(e.add(n, i / 2)), t.containerPointToCoordinate(e.add(n / 2, i)), t.containerPointToCoordinate(e.add(0, i / 2))]
        }
    ;
    var bh, C = Mh;
    function Mh() {
        return bh.apply(this, arguments) || this
    }
    C.mergeOptions({
        position: "top-right",
        draggable: !0,
        custom: !1,
        content: "",
        closeButton: !0
    });
    s(Eh, Sh = dh),
        (T = Eh.prototype).buildOn = function(t) {
            return this._map = t,
                this._scaleContainer = f("div", this.options.containerClass),
                this._addScales(),
                t.on("zoomend", this._update, this),
            this._map._loaded && this._update(),
                this._scaleContainer
        }
        ,
        T.onRemove = function() {
            this.getMap().off("zoomend", this._update, this)
        }
        ,
        T._addScales = function() {
            var t = "border: 2px solid #000000;border-top: none;line-height: 1.1;padding: 0px;color: #000000;font-size: 11px;text-align:center;white-space: nowrap;overflow: hidden;-moz-box-sizing: content-box;box-sizing: content-box;background: #fff; background: rgba(255, 255, 255, 0);";
            this.options.metric && (this._mScale = Xe("div", this.options.containerClass ? null : t, this._scaleContainer)),
            this.options.imperial && (this._iScale = Xe("div", this.options.containerClass ? null : t, this._scaleContainer))
        }
        ,
        T._update = function() {
            var t = this._map.pixelToDistance(this.options.maxWidth, 0);
            this._updateScales(t)
        }
        ,
        T._updateScales = function(t) {
            this.options.metric && t && this._updateMetric(t),
            this.options.imperial && t && this._updateImperial(t)
        }
        ,
        T._updateMetric = function(t) {
            var e = this._getRoundNum(t);
            this._updateScale(this._mScale, e < 1e3 ? e + " m" : e / 1e3 + " km", e / t)
        }
        ,
        T._updateImperial = function(t) {
            var e, i, t = 3.2808399 * t;
            5280 < t ? (i = this._getRoundNum(e = t / 5280),
                this._updateScale(this._iScale, i + " mile", i / e)) : (i = this._getRoundNum(t),
                this._updateScale(this._iScale, i + " feet", i / t))
        }
        ,
        T._updateScale = function(t, e, i) {
            t.style.width = Math.round(this.options.maxWidth * i) + "px",
                t.innerHTML = e
        }
        ,
        T._getRoundNum = function(t) {
            var e = Math.pow(10, (Math.floor(t) + "").length - 1)
                , t = t / e;
            return e * (t = 10 <= t ? 10 : 5 <= t ? 5 : 3 <= t ? 3 : 2 <= t ? 2 : 1)
        }
    ;
    var Sh, Th = Eh;
    function Eh() {
        return Sh.apply(this, arguments) || this
    }
    Th.mergeOptions({
        position: "bottom-left",
        maxWidth: 100,
        metric: !0,
        imperial: !1,
        containerClass: null
    }),
        h.mergeOptions({
            scaleControl: !1
        }),
        h.addOnLoadHook(function() {
            this.options.scaleControl && (this.scaleControl = new Th(this.options.scaleControl),
                this.addControl(this.scaleControl))
        });
    s(Rh, kh = dh),
        (T = Rh.prototype).buildOn = function(t) {
            this._map = t;
            var t = f("div")
                , e = f("ul", "maptalks-toolbar-hx")
                , s = (t.appendChild(e),
                this.options.vertical ? li(t, "maptalks-toolbar-vertical") : li(t, "maptalks-toolbar-horizonal"),
                this);
            var i = this.options.items;
            if (L(i))
                for (var n = 0, r = i.length; n < r; n++) {
                    var o, a = i[n], h = f("li");
                    28 !== this.options.height && (h.style.lineHeight = this.options.height + "px"),
                        h.style.height = this.options.height + "px",
                        h.style.cursor = "pointer",
                        gi(a.item) ? (h.style.textAlign = "center",
                            o = pi("div", a.item),
                            h.innerHTML = '<div style="margin-top:' + (this.options.height - o.height) / 2 + 'px;">' + a.item + "</div>") : h.innerHTML = a.item,
                    a.click && _(h, "click", function(e, i, n, r) {
                        var o = s._getItems()[i];
                        return function(t) {
                            return ii(t),
                                e({
                                    target: o,
                                    index: i,
                                    childIndex: n,
                                    dom: r
                                })
                        }
                    }(a.click, n, null, h)),
                    L(a.children) && (o = this._createDropMenu(n),
                        h.appendChild(o),
                        h._menu = o,
                        _(h, "mouseover", function() {
                            this._menu.style.display = ""
                        }),
                        _(h, "mouseout", function() {
                            this._menu.style.display = "none"
                        })),
                        e.appendChild(h)
                }
            return t
        }
        ,
        T._createDropMenu = function(t) {
            var o = this;
            for (var e = f("div", "maptalks-dropMenu"), i = this._getItems(), n = i.length, r = f("ul"), s = i[t].children, a = (t === n - 1 && s && (e.style.cssText = "right: 0px;",
                r.style.cssText = "right: 0px;position: absolute;",
            this.options.reverseMenu && (r.style.bottom = 0)),
                e.appendChild(f("em", "maptalks-ico")),
                0), h = 0, l = s.length; h < l; h++) {
                var u = Ge(s[h].item, "12px");
                u.width > a && (a = u.width)
            }
            for (var c = 0, d = s.length; c < d; c++) {
                var g = s[c]
                    , p = f("li");
                p.innerHTML = '<a href="javascript:;">' + g.item + "</a>",
                    p.style.cursor = "pointer",
                    p.style.width = a + 24 + "px",
                    _(p.childNodes[0], "click", function(e, i, n) {
                        var r = o._getItems()[i].children[n];
                        return function(t) {
                            return ii(t),
                                e({
                                    target: r,
                                    index: i,
                                    childIndex: n
                                })
                        }
                    }(g.click, t, c)),
                    r.appendChild(p)
            }
            return this.options.vertical ? (i = a < 95 ? 95 : a,
                this.options.reverseMenu ? e.style.right = -(i + 20) + "px" : e.style.left = -(i + 20) + "px") : this.options.reverseMenu ? e.style.bottom = "28px" : e.style.top = "28px",
                e.appendChild(r),
                e.style.display = "none",
                e
        }
        ,
        T._getItems = function() {
            return this.options.items || []
        }
    ;
    var kh, T = Rh;
    function Rh() {
        return kh.apply(this, arguments) || this
    }
    T.mergeOptions({
        height: 28,
        vertical: !1,
        position: "top-right",
        reverseMenu: !1,
        items: {}
    });
    s(Oh, Ah = dh),
        (Dh = Oh.prototype).buildOn = function(t) {
            var e, i, n = this.options, r = f("div", "maptalks-zoom"), o = (n.zoomLevel && (o = f("span", "maptalks-zoom-zoomlevel"),
                r.appendChild(o),
                this._levelDOM = o),
                f("div", "maptalks-zoom-slider")), s = f("a", "maptalks-zoom-zoomin"), s = (s.href = "javascript:;",
                s.innerHTML = "+",
                o.appendChild(s),
                this._zoomInButton = s,
            n.slider && (s = f("div", "maptalks-zoom-slider-box"),
                n = f("div", "maptalks-zoom-slider-ruler"),
                e = f("span", "maptalks-zoom-slider-reading"),
                i = f("span", "maptalks-zoom-slider-dot"),
                n.appendChild(e),
                s.appendChild(n),
                s.appendChild(i),
                o.appendChild(s),
                this._sliderBox = s,
                this._sliderRuler = n,
                this._sliderReading = e,
                this._sliderDot = i),
                f("a", "maptalks-zoom-zoomout"));
            return s.href = "javascript:;",
                s.innerHTML = "-",
                o.appendChild(s),
                this._zoomOutButton = s,
                r.appendChild(o),
                t.on("_zoomend _zooming _zoomstart _spatialreferencechange", this._update, this),
                this._update(),
                this._registerDomEvents(),
                r
        }
        ,
        Dh.onRemove = function() {
            this.getMap().off("_zoomend _zooming _zoomstart _spatialreferencechange", this._update, this),
            this._zoomInButton && mi(this._zoomInButton, "click", this._onZoomInClick, this),
            this._zoomOutButton && mi(this._zoomOutButton, "click", this._onZoomOutClick, this),
            this._sliderRuler && (mi(this._sliderRuler, "click", this._onClickRuler, this),
                this.dotDragger.disable(),
                delete this.dotDragger)
        }
        ,
        Dh._update = function() {
            var t, e = this.getMap();
            this._sliderBox && (t = 10 * (e.getMaxZoom() - e.getMinZoom()),
                this._sliderBox.style.height = 16 + t + "px",
                this._sliderRuler.style.height = 8 + t + "px",
                this._sliderRuler.style.cursor = "pointer",
                t = 10 * (e.getMaxZoom() - e.getZoom()),
                this._sliderReading.style.height = 10 * (e.getZoom() - e.getMinZoom() + 1) + "px",
                this._sliderDot.style.top = t + "px"),
                this._updateText()
        }
        ,
        Dh._updateText = function() {
            var t;
            this._levelDOM && (N(t = this.getMap().getZoom()) || (t = Math.floor(10 * t) / 10),
                this._levelDOM.innerHTML = t)
        }
        ,
        Dh._registerDomEvents = function() {
            this._zoomInButton && _(this._zoomInButton, "click", this._onZoomInClick, this),
            this._zoomOutButton && _(this._zoomOutButton, "click", this._onZoomOutClick, this),
            this._sliderRuler && (_(this._sliderRuler, "click", this._onClickRuler, this),
                this.dotDragger = new Zi(this._sliderDot,{
                    ignoreMouseleave: !0
                }),
                this.dotDragger.on("dragstart", this._onDotDragstart, this).on("dragging dragend", this._onDotDrag, this).enable())
        }
        ,
        Dh._onZoomInClick = function(t) {
            ei(t),
                this.getMap().zoomIn()
        }
        ,
        Dh._onZoomOutClick = function(t) {
            ei(t),
                this.getMap().zoomOut()
        }
        ,
        Dh._onClickRuler = function(t) {
            ei(t);
            var e = this.getMap()
                , t = si(t, this._sliderRuler).y
                , i = e.getMaxZoom()
                , i = Math.floor(i - t / 10);
            e.setZoom(i)
        }
        ,
        Dh._onDotDragstart = function(t) {
            ei(t.domEvent);
            var t = this.getMap()
                , e = t.getSize().toPoint()._multi(.5);
            t.onZoomStart(t.getZoom(), e)
        }
        ,
        Dh._onDotDrag = function(t) {
            ei(t.domEvent);
            var e = this.getMap()
                , i = e.getSize().toPoint()._multi(.5)
                , n = si(t.domEvent, this._sliderRuler)
                , r = e.getMaxZoom()
                , o = e.getMinZoom()
                , n = n.y
                , s = r - n / 10;
            r < s ? (s = r,
                n = 0) : s < o && (n = 10 * (r - (s = o))),
                "dragging" === t.type ? e.onZooming(s, i, 1) : "dragend" === t.type && (this.options.seamless ? e.onZoomEnd(s, i) : e.onZoomEnd(Math.round(s), i)),
                this._sliderDot.style.top = n + "px",
                this._sliderReading.style.height = 10 * (e.getZoom() - o + 1) + "px",
                this._updateText()
        }
    ;
    var Ah, Lh = Oh;
    function Oh() {
        return Ah.apply(this, arguments) || this
    }
    Lh.mergeOptions({
        position: "top-left",
        slider: !0,
        zoomLevel: !0,
        seamless: !1
    }),
        h.mergeOptions({
            zoomControl: !1
        }),
        h.addOnLoadHook(function() {
            this.options.zoomControl && (this.zoomControl = new Lh(this.options.zoomControl),
                this.addControl(this.zoomControl))
        });
    var Dh = Object.freeze({
        Control: dh,
        Attribution: mh,
        LayerSwitcher: vh,
        Overview: Ch,
        Panel: C,
        Scale: Th,
        Toolbar: T,
        Zoom: Lh
    })
        , Ih = (jh.getDefault = function(t) {
        return "baidu" === t.code.toLowerCase() ? "baidu" : t.code.toLowerCase() === "EPSG:4326".toLowerCase() ? "tms-global-geodetic" : "identity" === t.code.toLowerCase() ? [1, -1, 0, 0] : "web-mercator"
    }
        ,
        jh);
    function jh(t, e, i, n) {
        Array.isArray(t) ? (this.scale = {
            x: t[0],
            y: t[1]
        },
            this.origin = {
                x: t[2],
                y: t[3]
            }) : (this.scale = {
            x: t,
            y: e
        },
            this.origin = {
                x: i,
                y: n
            })
    }
    var C = 6378137 * Math.PI
        , zh = (m(Ih, {
        "web-mercator": new Ih([1, -1, -C, C]),
        "tms-global-mercator": new Ih([1, 1, -C, -C]),
        "tms-global-geodetic": new Ih([1, 1, -180, -90]),
        baidu: new Ih([1, 1, 0, 0])
    }),
        (T = Zh.prototype).prepareTileInfo = function(t, e) {
            if (b(t) ? t = Ih[t.toLowerCase()] : Array.isArray(t) && (t = new Ih(t)),
                !t)
                throw new Error("Invalid TileSystem");
            this.tileSystem = t;
            var i = e.right > e.left ? 1 : -1
                , e = e.top > e.bottom ? -1 : 1
                , n = t.origin.x
                , t = t.origin.y;
            this.transformation = new on([i, e, n, t])
        }
        ,
        T._getTileNum = function(t, e) {
            var i = this.tileSystem
                , n = this.tileSize
                , r = Math.floor(1e-7 * i.scale.x + t.x / (n.width * e))
                , t = Math.ceil(1e-7 * i.scale.y + t.y / (n.height * e));
            return {
                x: i.scale.x * r,
                y: i.scale.y * t
            }
        }
        ,
        T.getTileIndex = function(t, e, i) {
            var n = this.tileSystem
                , t = this.transformation.transform(t, 1)
                , t = this._getTileNum(t, e);
            return n.scale.x < 0 && --t.x,
            0 < n.scale.y && --t.y,
                this.getNeighorTileIndex(t.x, t.y, 0, 0, e, i)
        }
        ,
        T.getNeighorTileIndex = function(t, e, i, n, r, o) {
            var s = this.tileSystem
                , t = t + s.scale.x * i
                , i = e - s.scale.y * n
                , e = !1
                , s = t
                , n = i
                , r = this._getTileFullIndex(r);
            return o && (!0 !== o && "x" !== o || (r.xmax === r.xmin ? t = r.xmin : t < r.xmin ? (t = r.xmax - (r.xmin - t) % (r.xmax - r.xmin)) === r.xmax && (t = r.xmin) : t >= r.xmax && (t = r.xmin + (t - r.xmin) % (r.xmax - r.xmin))),
            !0 !== o && "y" !== o || (r.ymax === r.ymin ? i = r.ymin : i >= r.ymax ? i = r.ymin + (i - r.ymin) % (r.ymax - r.ymin) : i < r.ymin && (i = r.ymax - (r.ymin - i) % (r.ymax - r.ymin)) === r.ymax && (i = r.ymin))),
                {
                    x: t,
                    y: i,
                    idx: s,
                    idy: n,
                    out: e = t < r.xmin || t > r.xmax || i > r.ymax || i < r.ymin ? !0 : e
                }
        }
        ,
        T._getTileFullIndex = function(t) {
            if (this._tileFullIndex || (this._tileFullIndex = {}),
                this._tileFullIndex[t])
                return this._tileFullIndex[t];
            var e = this.fullExtent
                , i = this.transformation
                , n = this._getTileNum(i.transform(new M(e.left,e.top), 1), t)
                , i = this._getTileNum(i.transform(new M(e.right,e.bottom), 1), t)
                , e = this.tileSystem;
            return e.scale.x < 0 && (--n.x,
                --i.x),
            0 < e.scale.y && (--n.y,
                --i.y),
                this._tileFullIndex[t] = new g(n,i),
                this._tileFullIndex[t]
        }
        ,
        T.getTilePrjNW = function(t, e, i) {
            var n = this.tileSystem
                , r = this.tileSize
                , e = n.origin.y + this._yScale * n.scale.y * (e + (1 === n.scale.y ? 1 : 0)) * i * r.height
                , t = n.origin.x + this._xScale * n.scale.x * (t + (1 === n.scale.x ? 0 : 1)) * i * r.width;
            return new M(t,e)
        }
        ,
        T.getTilePointNW = function(t, e, i) {
            var i = this._glRes / i
                , n = this.tileSystem
                , r = this.tileSize
                , e = this._pointOrigin.y * i + this._yScale * n.scale.y * (e + (1 === n.scale.y ? 1 : 0)) * r.height
                , i = this._pointOrigin.x * i + this._xScale * n.scale.x * (t + (1 === n.scale.x ? 0 : 1)) * r.width;
            return new R(i,e)
        }
        ,
        T.getTilePrjSE = function(t, e, i) {
            var n = this.tileSystem
                , r = this.tileSize
                , e = n.origin.y + this._yScale * n.scale.y * (e + (1 === n.scale.y ? 0 : 1)) * i * r.height
                , t = n.origin.x + this._xScale * n.scale.x * (t + (1 === n.scale.x ? 1 : 0)) * i * r.width;
            return new M(t,e)
        }
        ,
        T.getTilePointSE = function(t, e, i) {
            var i = this._glRes / i
                , n = this.tileSystem
                , r = this.tileSize
                , e = this._pointOrigin.y * i + this._yScale * n.scale.y * (e + (1 === n.scale.y ? 0 : 1)) * r.height
                , i = this._pointOrigin.x * i + this._xScale * n.scale.x * (t + (1 === n.scale.x ? 1 : 0)) * r.width;
            return new R(i,e)
        }
        ,
        T.getTilePrjExtent = function(t, e, i) {
            var n = this.getTilePrjNW(t, e, i)
                , t = this.getTilePrjSE(t, e, i);
            return new g(n,t)
        }
        ,
        Zh);
    function Zh(t, e, i, n) {
        this.map = t,
            this.tileSize = n,
            this.fullExtent = i,
            this.prepareTileInfo(e, i),
            this._xScale = i.right >= i.left ? 1 : -1,
            this._yScale = i.top >= i.bottom ? 1 : -1,
            this._pointOrigin = t._prjToPoint(new R(this.tileSystem.origin), t.getGLZoom()),
            this._glRes = t.getResolution(t.getGLZoom())
    }
    for (var Hh = [], Gh = 0; Gh < 6; Gh++)
        Hh[Gh] = [];
    var Fh = [];
    function Nh(t, e, i) {
        var n, r, o, s, a, h, l, u, c, d, g, p, f, m, _;
        n = (t = t)[0],
            r = t[1],
            o = t[2],
            s = t[3],
            a = t[4],
            h = t[5],
            l = t[6],
            u = t[7],
            c = t[8],
            d = t[9],
            g = t[10],
            p = t[11],
            f = t[12],
            m = t[13],
            _ = t[14],
            t = t[15],
            Bh(Hh[0], s - n, u - a, p - c, t - f),
            Bh(Hh[1], s + n, u + a, p + c, t + f),
            Bh(Hh[2], s + r, u + h, p + d, t + m),
            Bh(Hh[3], s - r, u - h, p - d, t - m),
            Bh(Hh[4], s - o, u - l, p - g, t - _),
            Bh(Hh[5], s + o, u + l, p + g, t + _);
        for (var y = 0; y < 6; y++)
            if (!i || "0" !== i.charAt(y)) {
                var v = Hh[y];
                if (Fh[0] = (0 < v[0] ? e[1] : e[0])[0],
                    Fh[1] = (0 < v[1] ? e[1] : e[0])[1],
                    Fh[2] = (0 < v[2] ? e[1] : e[0])[2],
                v[0] * Fh[0] + v[1] * Fh[1] + v[2] * Fh[2] + v[3] < 0)
                    return !1
            }
        return !0
    }
    var Wh = 1 / 6;
    function Bh(t, e, i, n, r) {
        t[0] = e * Wh,
            t[1] = i * Wh,
            t[2] = n * Wh,
            t[3] = r * Wh
    }
    var Vh = "undefined" != typeof Set
        , Uh = ((C = Jh.prototype).add = function(t) {
        Vh ? this._table.add(t) : this._table[t] = !0
    }
        ,
        C.has = function(t) {
            return Vh ? this._table.has(t) : this._table[t]
        }
        ,
        C.reset = function() {
            Vh ? this._table.clear() : this._table = {}
        }
        ,
        Jh);
    function Jh() {
        this._table = Vh ? new Set : {}
    }
    var qh, T = {
        urlTemplate: null,
        subdomains: null,
        repeatWorld: !0,
        background: !0,
        backgroundZoomDiff: 6,
        loadingLimitOnInteracting: 3,
        tileRetryCount: 0,
        placeholder: !1,
        crossOrigin: null,
        tileSize: [256, 256],
        offset: [0, 0],
        tileSystem: null,
        fadeAnimation: !$,
        debug: !1,
        spatialReference: null,
        maxCacheSize: 256,
        renderer: c.webgl ? "gl" : "canvas",
        clipByPitch: !0,
        maxAvailableZoom: null,
        cascadeTiles: !0,
        zoomOffset: 0
    }, Yh = /\{ *([\w_]+) *\}/g, Xh = new R(0,0), Kh = new R(0,0), Qh = new R(0,0), $h = new R(0,0), tl = new R(0,0), el = new R(0,0), il = new R(0,0), nl = new R(0,0), rl = [[0, 0, 0], [0, 0, 0]], ol = [], C = (s(sl, qh = kr),
        sl.fromJSON = function(t) {
            return t && "TileLayer" === t.type ? new sl(t.id,t.options) : null
        }
        ,
        (C = sl.prototype).getTileSize = function() {
            var t = this.options.tileSize;
            return P(t) && (t = [t, t]),
                new Le(t)
        }
        ,
        C.getTiles = function(t, e) {
            var i = this.getMap()
                , n = i.getPitch()
                , e = e && e.getRenderer()
                , r = i.getContainerExtent()
                , o = []
                , s = 0
                , a = this.getMinZoom()
                , h = i.options.cascadePitches[0]
                , l = i.options.cascadePitches[1]
                , u = Math.floor(i._getVisualHeight(l))
                , c = V(t) ? this._getTileZoom(i.getZoom()) : t;
            if (this._visitedTiles = new Uh,
                this._coordCache = {},
            !V(t) || !this.options.cascadeTiles || n <= h || !V(a) && c <= a)
                return t = n <= l ? r : new U(0,i.height - u,i.width,i.height),
                (t = this._getTiles(c, t, 2, e)) && (s += t.tiles.length,
                    o.push(t)),
                    {
                        tileGrids: o,
                        count: s
                    };
            var d, g, t = Math.floor(i._getVisualHeight(h)), h = new U(0,i.height - t,i.width,i.height), t = this._getTiles(c, h, 0, e), t = (s += t ? t.tiles.length : 0,
                o.push(t),
                h.ymin), h = i.getSpatialReference().getZoomDirection(), p = h;
            return l < n && (c - p <= a && (p = 0),
                l = new U(0,i.height - u,i.width,t),
                s += (d = this._getTiles(c - p, l, 1, e)) ? d.tiles.length : 0,
                t = l.ymin,
                p += 4 * h),
            a <= c - p && (n = new U(0,r.ymin,i.width,t),
                s += (g = this._getTiles(c - p, n, 2, e)) ? g.tiles.length : 0,
                o.push(g)),
            d && g && (o[1] = g,
                o[2] = d),
                {
                    tileGrids: o,
                    count: s
                }
        }
        ,
        C.getTileUrl = function(t, e, i) {
            var n, r = this.options.urlTemplate, o = "";
            if (!this.options.subdomains || L(n = this.options.subdomains) && (o = n[n = (n = (t + e) % n.length) < 0 ? 0 : n]),
                p(r))
                return r(t, e, i, o);
            var s = {
                x: t,
                y: e,
                z: i,
                s: o
            };
            return r.replace(Yh, function(t, e) {
                e = s[e];
                if (void 0 === e)
                    throw new Error("No value provided for variable " + t);
                return e = "function" == typeof e ? e(s) : e
            })
        }
        ,
        C.clear = function() {
            return this._renderer && this._renderer.clear(),
                this.fire("clear"),
                this
        }
        ,
        C.toJSON = function() {
            return {
                type: this.getJSONType(),
                id: this.getId(),
                options: this.config()
            }
        }
        ,
        C.getSpatialReference = function() {
            var t = this.getMap();
            return !t || this.options.spatialReference && !br.equals(this.options.spatialReference, t.options.spatialReference) ? (this._sr = this._sr || new br(this.options.spatialReference),
            void 0 === this._srMinZoom && (this._srMinZoom = this._sr.getMinZoom(),
                this._srMaxZoom = this._sr.getMaxZoom()),
                this._sr) : t.getSpatialReference()
        }
        ,
        C.getMinZoom = function() {
            return this.getSpatialReference() !== this.getMap().getSpatialReference() ? Math.max(qh.prototype.getMinZoom.call(this), this._srMinZoom) : qh.prototype.getMinZoom.call(this)
        }
        ,
        C.getMaxZoom = function() {
            return this.getSpatialReference() !== this.getMap().getSpatialReference() ? Math.min(qh.prototype.getMaxZoom.call(this), this._srMaxZoom) : qh.prototype.getMaxZoom.call(this)
        }
        ,
        C._getTileZoom = function(t) {
            N(t) || (t = Math.round(t));
            var e = this.options.maxAvailableZoom;
            return t = !V(e) && e < t ? e : t
        }
        ,
        C._getTiles = function(t, e, i, j) {
            var n = this
                , r = this.getMap()
                , o = t
                , s = r.projViewMatrix
                , a = (i < 2 && (0 === i && --o,
                s = 0 === i ? r.cascadeFrustumMatrix0 : 1 === i ? r.cascadeFrustumMatrix1 : r.projViewMatrix),
            o + this.options.zoomOffset)
                , h = this._getTileOffset(a)
                , l = h[0] || h[1]
                , u = {
                zoom: o,
                extent: null,
                offset: h,
                tiles: []
            };
            if (a < 0)
                return u;
            var c = this.getMinZoom()
                , d = this.getMaxZoom();
            if (!(r && this.isVisible() && r.width && r.height))
                return u;
            if (!V(c) && o < c || !V(d) && d < o)
                return u;
            var g = this._getTileConfig();
            if (!g)
                return u;
            var p = this.getSpatialReference()
                , z = r.getSpatialReference()
                , f = p.getResolution(a)
                , Z = r.getGLScale(o)
                , m = p === z && this.options.repeatWorld
                , c = e.convertTo(function(t) {
                var e;
                return 0 < t.y && t.y < r.height && (e = (0 === t.x ? 0 : 1) + t.y,
                n._coordCache[e] || (n._coordCache[e] = r._containerPointToPoint(t)),
                    n._coordCache[e]),
                    r._containerPointToPoint(t, void 0, Xh)
            })
                , d = (c._add(h),
                this._getMask2DExtent());
            if (d) {
                d = d.intersection(c);
                if (!d)
                    return u;
                e = d.convertTo(function(t) {
                    return r._pointToContainerPoint(t, void 0, 0, Xh)
                })
            }
            u = r._containerPointToPrj(e.getCenter(), Kh),
                d = r._prjToPoint(u, void 0, Qh),
                d = l ? this._project(r._pointToPrj(d._add(h), void 0, Qh), Qh) : this._project(u, Qh);
            $h.x = c.xmin,
                $h.y = c.ymax,
                tl.x = c.xmax,
                tl.y = c.ymin;
            for (var _, u = this._project(r._pointToPrj($h, void 0, $h), $h), c = this._project(r._pointToPrj(tl, void 0, tl), tl), y = g.getTileIndex(d, f, m), d = g.getTileIndex(u, f, m), u = g.getTileIndex(c, f, m), c = Math.ceil(Math.abs(y.idy - d.idy)), H = Math.ceil(Math.abs(y.idx - d.idx)), G = Math.ceil(Math.abs(y.idy - u.idy)), v = Math.ceil(Math.abs(y.idx - u.idx)), F = (c + G + 1) * (H + v + 1), N = this.getTileSize(), x = this.getRenderer() || j, W = this._getTileConfig().tileSystem.scale, w = [], B = new U, C = -c; C <= G; C++)
                for (var P = -H, b = -1 / 0, M = !1; b <= P && P <= v; ) {
                    var S, T, E, k, R, A, L, O, D = g.getNeighorTileIndex(y.idx, y.idy, P, C, f, m), I = (b === -1 / 0 ? P++ : P--,
                        this._getTileId(D.idx, D.idy, o));
                    D.out || this._visitedTiles && this._visitedTiles.has(I) || (T = void 0,
                        k = void (T = (S = (S = x && x.isTileCachedOrLoading(I)) && S.info) ? (E = S.point0,
                            S.point.set(E.x, E.y)) : this._hasOwnSR ? (E = g.getTilePrjNW(D.x, D.y, f),
                            r._prjToPoint(this._unproject(E, tl), o)) : g.getTilePointNW(D.x, D.y, f)),
                        R = void 0,
                        R = p === z ? (k = N.width,
                            N.height) : (L = void 0,
                            L = this._hasOwnSR ? (A = g.getTilePrjSE(D.x, D.y, f),
                                r._prjToPoint(this._unproject(A, tl), o, tl)) : g.getTilePointSE(D.x, D.y, f),
                            k = Math.ceil(Math.abs(L.x - T.x)),
                            Math.ceil(Math.abs(L.y - T.y))),
                        A = W.x * (D.idx - D.x) * k,
                        L = W.y * (D.idy - D.y) * R,
                    (A || L) && T._add(A, L),
                    l && T._sub(h),
                        O = S && S.extent2d || new U(T.x,T.y,T.x + k,T.y - R),
                    (F <= 4 || M || this._isTileInExtent(s, O, Z)) && (this._visitedTiles && 0 === i && this._visitedTiles.add(I),
                        0 === i ? this._splitTiles(s, w, x, D, o + 1, O, h, A, L) : (S = S || {
                            point0: T.add(h)._sub(A, L),
                            point: T,
                            z: o,
                            x: D.x,
                            y: D.y,
                            extent2d: O,
                            mask: i,
                            size: [k, R],
                            id: I,
                            dupKey: I,
                            layer: this.getId(),
                            url: this.getTileUrl(D.x, D.y, a)
                        },
                        l && (O.set(T.x, T.y, T.x + k, T.y - R),
                            S.point = T._add(h),
                            O._add(h)),
                            w.push(S)),
                        B._combine(O),
                        b === -1 / 0 ? (b = P,
                            P = v) : M = M || !0))
                }
            return w.length && (_ = r._containerPointToPoint(e.getCenter(), o, Xh)._add(h),
                w.sort(function(t, e) {
                    return t.point.distanceTo(_) - e.point.distanceTo(_)
                })),
                {
                    offset: h,
                    zoom: t,
                    extent: B,
                    tiles: w
                }
        }
        ,
        C._splitTiles = function(t, e, i, n, r, o, s, a, h) {
            var l = this._getTileConfig().tileSystem.scale.y
                , u = this.getMap().getGLScale(r)
                , c = el.set(2 * o.xmin, l < 0 ? 2 * o.ymax : 2 * o.ymin)
                , l = il.set(o.xmin, l < 0 ? o.ymax : o.ymin)._add(s)._sub(a, h)._multi(2)
                , a = o.getWidth()
                , h = o.getHeight()
                , o = 2 * n.idx
                , d = 2 * n.idy
                , g = 2 * n.x
                , n = 2 * n.y
                , p = this._checkAndAddTile(t, i, o, d, g, n, r, 0, 0, a, h, c, l, s, u);
            p && e.push(p),
            (p = this._checkAndAddTile(t, i, o, d, g, n, r, 0, 1, a, h, c, l, s, u)) && e.push(p),
            (p = this._checkAndAddTile(t, i, o, d, g, n, r, 1, 0, a, h, c, l, s, u)) && e.push(p),
            (p = this._checkAndAddTile(t, i, o, d, g, n, r, 1, 1, a, h, c, l, s, u)) && e.push(p)
        }
        ,
        C._checkAndAddTile = function(t, e, i, n, r, o, s, a, h, l, u, c, d, g, p) {
            i = this._getTileId(i + a, n + h, s);
            if (this._visitedTiles && this._visitedTiles.has(i))
                return null;
            n = this._getTileConfig().tileSystem.scale.y,
                c = new U(c.x + a * l,c.y + n * h * u,c.x + (a + 1) * l,c.y + n * (h + 1) * u);
            if (!this._isSplittedTileInExtent(t, c, p))
                return null;
            t = g[0] || g[1],
                p = (p = e && e.isTileCachedOrLoading(i)) ? p.info : {
                    point0: d.add(a * l, Math.max(n * h * u, n * (h + 1) * u)),
                    point: new R(c.xmin,c.ymax),
                    z: s,
                    x: r + a,
                    y: o + h,
                    extent2d: c,
                    size: [l, u],
                    id: i,
                    dupKey: i,
                    layer: this.getId(),
                    url: this.getTileUrl(r + a, o + h, s + this.options.zoomOffset)
                };
            return t && (p.extent2d = c,
                p.extent2d._add(g),
                p.point.set(c.xmin, c.ymax)._add(g)),
                p
        }
        ,
        C._getTileOffset = function(t) {
            var e = this.getMap()
                , e = e._getResolution() / e._getResolution(t)
                , t = this.options.offset;
            return (t = p(t) ? t(this) : t)[0] *= e,
                t[1] *= e,
                t
        }
        ,
        C._getTileId = function(t, e, i, n) {
            return (n || this.getId()) + "_" + e + "_" + t + "_" + i
        }
        ,
        C._project = function(t, e) {
            var i;
            return this._hasOwnSR ? (i = this.getMap().getProjection(),
                this.getSpatialReference().getProjection().project(i.unproject(t, e), e)) : t
        }
        ,
        C._unproject = function(t, e) {
            var i, n;
            return this._hasOwnSR ? (i = this.getMap(),
                n = this.getSpatialReference(),
                i = i.getProjection(),
                n = n.getProjection(),
                i.project(n.unproject(t, e), e)) : t
        }
        ,
        C._initTileConfig = function() {
            var t = this.getMap()
                , e = this.getTileSize()
                , i = this.getSpatialReference()
                , n = i.getProjection()
                , r = i.getFullExtent();
            this._defaultTileConfig = new zh(t,Ih.getDefault(n),r,e),
            this.options.tileSystem && (this._tileConfig = new zh(t,this.options.tileSystem,r,e)),
            t && !this._tileConfig && t.getSpatialReference() === i && t.getBaseLayer() && t.getBaseLayer() !== this && t.getBaseLayer()._getTileConfig && (n = t.getBaseLayer()._getTileConfig(),
                this._tileConfig = new zh(t,n.tileSystem,n.fullExtent,e)),
                this._hasOwnSR = i !== t.getSpatialReference()
        }
        ,
        C._getTileConfig = function() {
            return this._defaultTileConfig || this._initTileConfig(),
            this._tileConfig || this._defaultTileConfig
        }
        ,
        C._bindMap = function(t) {
            t = t.getBaseLayer();
            return t !== this || t.options.hasOwnProperty("forceRenderOnMoving") || this.config({
                forceRenderOnMoving: !0
            }),
                qh.prototype._bindMap.apply(this, arguments)
        }
        ,
        C._isTileInExtent = function(t, e, i) {
            var n, r, o, s, a, h, l = this.getMap();
            return s = t !== l.projViewMatrix ? (n = e.getCenter(nl)._multi(i),
                pa(ol, n.x, n.y, 0),
                r = n = ol,
                o = l.projViewMatrix,
                s = r[0],
                a = r[1],
                r = r[2],
                h = o[3] * s + o[7] * a + o[11] * r + o[15],
                n[0] = (o[0] * s + o[4] * a + o[8] * r + o[12]) / (h = h || 1),
                n[1] = (o[1] * s + o[5] * a + o[9] * r + o[13]) / h,
                n[2] = (o[2] * s + o[6] * a + o[10] * r + o[14]) / h,
                n[1] < 0 ? l.projViewMatrix : t) : l.projViewMatrix,
                rl[0][0] = e.xmin * i,
                rl[0][1] = e.ymin * i,
                rl[1][0] = e.xmax * i,
                rl[1][1] = e.ymax * i,
                Nh(s, rl)
        }
        ,
        C._isSplittedTileInExtent = function(t, e, i) {
            var n = this.getMap();
            return rl[0][0] = e.xmin * i,
                rl[0][1] = e.ymin * i,
                rl[1][0] = e.xmax * i,
                rl[1][1] = e.ymax * i,
                Nh(n.projViewMatrix, rl)
        }
        ,
        C.getEvents = function() {
            return {
                spatialreferencechange: this._onSpatialReferenceChange
            }
        }
        ,
        C._onSpatialReferenceChange = function() {
            delete this._tileConfig,
                delete this._defaultTileConfig,
                delete this._sr;
            var t = this.getRenderer();
            t && t.clear()
        }
        ,
        sl);
    function sl() {
        return qh.apply(this, arguments) || this
    }
    C.registerJSONType("TileLayer"),
        C.mergeOptions(T);
    s(hl, al = C),
        hl.fromJSON = function(t) {
            if (!t || "GroupTileLayer" !== t.type)
                return null;
            var e = t.layers.map(function(t) {
                return kr.fromJSON(t)
            });
            return new hl(t.id,e,t.options)
        }
        ,
        (T = hl.prototype).getLayers = function() {
            return this.layers
        }
        ,
        T.toJSON = function() {
            return {
                type: this.getJSONType(),
                id: this.getId(),
                layers: this.layers.map(function(t) {
                    return t.toJSON()
                }),
                options: this.config()
            }
        }
        ,
        T.getTiles = function(t) {
            for (var e = this.layers, i = [], n = 0, r = 0, o = e.length; r < o; r++) {
                var s = e[r];
                s.options.visible && ((s = s.getTiles(t, this)) && 0 !== s.count && (n += s.count,
                    ot(i, s.tileGrids)))
            }
            return {
                count: n,
                tileGrids: i
            }
        }
        ,
        T.onAdd = function() {
            var e = this
                , i = this.getMap();
            this.layers.forEach(function(t) {
                (e.layerMap[t.getId()] = t).getChildLayer && e._groupChildren.push(t),
                    t._bindMap(i),
                    t.on("show hide", e._onLayerShowHide, e)
            }),
                al.prototype.onAdd.call(this)
        }
        ,
        T.onRemove = function() {
            var e = this;
            this.layers.forEach(function(t) {
                t._doRemove(),
                    t.off("show hide", e._onLayerShowHide, e)
            }),
                this.layerMap = {},
                this._groupChildren = [],
                al.prototype.onRemove.call(this)
        }
        ,
        T.getChildLayer = function(t) {
            var e = this.layerMap[t];
            if (e)
                return e;
            for (var i = 0; i < this._groupChildren.length; i++) {
                var n = this._groupChildren[i].getChildLayer(t);
                if (n)
                    return n
            }
            return null
        }
        ,
        T._onLayerShowHide = function() {
            var t = this.getRenderer();
            t && t.setToRedraw()
        }
        ,
        T.isVisible = function() {
            if (!al.prototype.isVisible.call(this))
                return !1;
            for (var t = this.layers, e = 0, i = t.length; e < i; e++)
                if (t[e].isVisible())
                    return !0;
            return !1
        }
        ,
        T._checkChildren = function() {
            var e = this
                , i = {};
            this.layers.forEach(function(t) {
                t = t.getId();
                if (i[t])
                    throw new Error("Duplicate child layer id (" + t + ") in the GroupTileLayer (" + e.getId() + ")");
                i[t] = 1
            })
        }
    ;
    var al, T = hl;
    function hl(t, e, i) {
        t = al.call(this, t, i) || this;
        return t.layers = e || [],
            t._checkChildren(),
            t.layerMap = {},
            t._groupChildren = [],
            t
    }
    T.registerJSONType("GroupTileLayer");
    var ll, ul = {
        crs: null,
        uppercase: !1,
        detectRetina: !1
    }, cl = {
        service: "WMS",
        request: "GetMap",
        layers: "",
        styles: "",
        format: "image/jpeg",
        transparent: !1,
        version: "1.1.1"
    }, dl = (s(gl, ll = C),
        (dl = gl.prototype).onAdd = function() {
            var t = this.getMap().getDevicePixelRatio()
                , t = ul.detectRetina ? t : 1
                , t = (this.wmsParams.width *= t,
                this.wmsParams.height *= t,
            this.options.crs || this.getMap().getProjection().code)
                , e = 1.3 <= this._wmsVersion ? "crs" : "srs";
            this.wmsParams[e] = t,
                ll.prototype.onAdd.call(this)
        }
        ,
        dl.getTileUrl = function(t, e, i) {
            var n = this.getSpatialReference().getResolution(i)
                , n = this._getTileConfig().getTilePrjExtent(t, e, n)
                , r = n.getMax()
                , n = n.getMin()
                , n = (1.3 <= this._wmsVersion && "EPSG:4326" === this.wmsParams.crs ? [n.y, n.x, r.y, r.x] : [n.x, n.y, r.x, r.y]).join(",")
                , r = ll.prototype.getTileUrl.call(this, t, e, i);
            return r + function(t, e, i) {
                var n, r = [];
                for (n in t)
                    r.push(encodeURIComponent(i ? n.toUpperCase() : n) + "=" + encodeURIComponent(t[n]));
                return (e && -1 !== e.indexOf("?") ? "&" : "?") + r.join("&")
            }(this.wmsParams, r, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + n
        }
        ,
        dl.toJSON = function() {
            return {
                type: "WMSTileLayer",
                id: this.getId(),
                options: this.config()
            }
        }
        ,
        gl.fromJSON = function(t) {
            return t && "WMSTileLayer" === t.type ? new gl(t.id,t.options) : null
        }
        ,
        gl);
    function gl(t, e) {
        var i, n = ll.call(this, t) || this, r = m({}, cl);
        for (i in e)
            i in n.options || (r[i] = e[i]);
        n.setOptions(e),
            n.setZIndex(e.zIndex);
        t = n.getTileSize();
        return r.width = t.width,
            r.height = t.height,
            n.wmsParams = r,
            n._wmsVersion = parseFloat(r.version),
            n
    }
    dl.registerJSONType("WMSTileLayer"),
        dl.mergeOptions(ul);
    s(ml, pl = C),
        (fl = ml.prototype).drawTile = function() {}
        ,
        fl.toJSON = function() {
            return {
                type: "CanvasTileLayer",
                id: this.getId(),
                options: this.config()
            }
        }
        ,
        ml.fromJSON = function(t) {
            return t && "CanvasTileLayer" === t.type ? new ml(t.id,t.options) : null
        }
    ;
    var pl, fl = ml;
    function ml(t, e) {
        t = pl.call(this, t, e) || this;
        return t.options.hasOwnProperty("forceRenderOnMoving") || (t.options.forceRenderOnMoving = !1),
            t
    }
    function _l(t, e, i) {
        e = t.createShader(e);
        if (t.shaderSource(e, i),
            t.compileShader(e),
            t.getShaderParameter(e, t.COMPILE_STATUS))
            return e;
        throw i = t.getShaderInfoLog(e),
            t.deleteShader(e),
            new Error("Failed to compile shader: " + i)
    }
    fl.registerJSONType("CanvasTileLayer");
    function yl(t) {
        var e, h, l;
        function i() {
            return e.apply(this, arguments) || this
        }
        return s(i, e = t),
            (t = i.prototype).drawGLImage = function(t, e, i, n, r, o, s, a) {
                this.gl.program !== this.program && this.useProgram(this.program);
                var h = this.gl
                    , e = (this.loadTexture(t),
                    Pl[0] = e || 0,
                    Pl[1] = i || 0,
                    da(bl))
                    , i = (ha(e, e, Pl),
                    la(e, e, [o, o, 1]),
                    ua(e, this.getMap().projViewMatrix, e),
                    h.uniformMatrix4fv(this.program.u_matrix, !1, e),
                    h.uniform1f(this.program.u_opacity, s),
                    h.uniform1f(this.program.u_debug_line, 0),
                    t.glBuffer);
                !i || i.width === n && i.height === r || (this.saveImageBuffer(i),
                    delete t.glBuffer),
                    t.glBuffer ? h.bindBuffer(h.ARRAY_BUFFER, i) : t.glBuffer = this.bufferTileData(0, 0, n, r),
                    Cl[0] = "a_position",
                    Cl[1] = 2,
                    Cl[2] = t.glBuffer.type,
                    this.enableVertexAttrib(Cl),
                    h.drawArrays(h.TRIANGLE_STRIP, 0, 4),
                a && this.drawDebug(e, Cl, 0, 0, n, r, a)
            }
            ,
            t.drawDebug = function(t, e, i, n, r, o, s) {
                var a = this.gl
                    , t = (a.bindBuffer(a.ARRAY_BUFFER, this._debugBuffer),
                    this.enableVertexAttrib(["a_position", 2, "FLOAT"]),
                    a.bufferData(a.ARRAY_BUFFER, new Float32Array([i, n, i + r, n, i + r, n - o, i, n - o, i, n]), a.DYNAMIC_DRAW),
                    a.uniformMatrix4fv(this.program.u_matrix, !1, t),
                    a.uniform1f(this.program.u_debug_line, 1),
                    a.drawArrays(a.LINE_STRIP, 0, 5),
                    this._debugInfoCanvas)
                    , h = (t || (l = 1 < this.getMap().getDevicePixelRatio() ? 2 : 1,
                    (t = this._debugInfoCanvas = document.createElement("canvas")).width = 256 * l,
                    t.height = 32 * l,
                    (h = t.getContext("2d")).font = "20px monospace",
                    h.scale(l, l)),
                    t.getContext("2d"))
                    , l = (h.clearRect(0, 0, t.width, t.height),
                    this.layer.options.debugOutline)
                    , h = (O.fillText(h, s, Ml, l),
                    this.loadTexture(t),
                    a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, t),
                    i)
                    , s = i + (r = 256)
                    , l = n - (o = 32);
                a.bufferData(a.ARRAY_BUFFER, this.set8(h, n, h, l, s, n, s, l), a.DYNAMIC_DRAW),
                    a.uniform1f(this.program.u_debug_line, 0),
                    a.drawArrays(a.TRIANGLE_STRIP, 0, 4)
            }
            ,
            t.bufferTileData = function(t, e, i, n, r) {
                var o = t
                    , t = t + i
                    , s = e
                    , e = e - n
                    , o = N(o) && N(t) && N(s) && N(e) ? this.set8Int(o, s, o, e, t, s, t, e) : this.set8(o, s, o, e, t, s, t, e)
                    , s = this.loadImageBuffer(o, r);
                return s.width = i,
                    s.height = n,
                    s.type = o instanceof Int16Array ? "SHORT" : "FLOAT",
                    s
            }
            ,
            t.drawTinImage = function(t, e, i, n, r) {
                var o = this.gl;
                this.loadTexture(t),
                    o.uniformMatrix4fv(this.program.u_matrix, !1, this.getMap().projViewMatrix),
                    o.uniform1f(this.program.u_opacity, r),
                    o.bindBuffer(o.ARRAY_BUFFER, this.posBuffer),
                    this.enableVertexAttrib(["a_position", 3]),
                    o.bufferData(o.ARRAY_BUFFER, new Float32Array(e), o.DYNAMIC_DRAW),
                    o.bindBuffer(o.ARRAY_BUFFER, this.texBuffer),
                    this.enableVertexAttrib(["a_texCoord", 2]),
                    o.bufferData(o.ARRAY_BUFFER, new Float32Array(i), o.DYNAMIC_DRAW),
                    o.bufferData(o.ELEMENT_ARRAY_BUFFER, new Uint16Array(n), o.DYNAMIC_DRAW),
                    o.drawElements(o.TRIANGLES, n.length, o.UNSIGNED_SHORT, 0)
            }
            ,
            t.createCanvas2 = function() {
                this.canvas2 = O.createCanvas(this.canvas.width, this.canvas.height)
            }
            ,
            t.createGLContext = function() {
                this.canvas.gl && this.canvas.gl.wrap ? this.gl = this.canvas.gl.wrap() : this.gl = function(t, e) {
                    for (var i = {
                        alpha: !0,
                        stencil: !0,
                        preserveDrawingBuffer: !0,
                        antialias: !1
                    }, n = ["webgl", "experimental-webgl"], r = null, o = 0; o < n.length; ++o) {
                        try {
                            r = t.getContext(n[o], e || i)
                        } catch (t) {}
                        if (r)
                            break
                    }
                    return r
                }(this.canvas2 || this.canvas, this.layer.options.glOptions);
                var t = this.gl;
                t.clearColor(0, 0, 0, 0),
                    t.disable(t.DEPTH_TEST),
                    t.enable(t.STENCIL_TEST),
                    t.enable(t.BLEND),
                    t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA),
                    this.program = this.createProgram(xl, this.layer.options.fragmentShader || wl, ["u_matrix", "u_image", "u_opacity", "u_debug_line"]),
                    this._debugBuffer = this.createBuffer(),
                    this.useProgram(this.program),
                    this.texBuffer = this.createBuffer(),
                    t.bindBuffer(t.ARRAY_BUFFER, this.texBuffer),
                    this.enableVertexAttrib(["a_texCoord", 2, "UNSIGNED_BYTE"]),
                    t.bufferData(t.ARRAY_BUFFER, new Uint8Array([0, 0, 0, 1, 1, 0, 1, 1]), t.STATIC_DRAW),
                    this.enableSampler("u_image"),
                    t.activeTexture(t.TEXTURE0),
                    t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0)
            }
            ,
            t.resizeGLCanvas = function() {
                this.gl && this.gl.viewport(0, 0, this.canvas.width, this.canvas.height),
                !this.canvas2 || this.canvas2.width === this.canvas.width && this.canvas2.height === this.canvas.height || (this.canvas2.width = this.canvas.width,
                    this.canvas2.height = this.canvas.height)
            }
            ,
            t.clearGLCanvas = function() {
                this.gl && this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT)
            }
            ,
            t.disposeImage = function(t) {
                t && (t.texture && this.saveTexture(t.texture),
                t.glBuffer && this.saveImageBuffer(t.glBuffer),
                    delete t.texture,
                    delete t.glBuffer)
            }
            ,
            t._createTexture = function(t) {
                var e = this.gl
                    , i = this.getTexture() || e.createTexture();
                return e.bindTexture(e.TEXTURE_2D, i),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                    e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t),
                N(lt(t.width)) && N(lt(t.width)) && e.generateMipmap(e.TEXTURE_2D),
                    i
            }
            ,
            t.getTexture = function() {
                this._textures || (this._textures = []);
                var t = this._textures;
                return t && 0 < t.length ? t.pop() : null
            }
            ,
            t.saveTexture = function(t) {
                this._textures.push(t)
            }
            ,
            t.loadTexture = function(t) {
                var e = this.gl
                    , i = t.texture;
                return i || (i = this._createTexture(t),
                    t.texture = i),
                    e.bindTexture(e.TEXTURE_2D, i),
                    i
            }
            ,
            t.getImageBuffer = function() {
                this._imageBuffers || (this._imageBuffers = []);
                var t = this._imageBuffers;
                return t && 0 < t.length ? t.pop() : null
            }
            ,
            t.saveImageBuffer = function(t) {
                this._imageBuffers.push(t)
            }
            ,
            t.loadImageBuffer = function(t, e) {
                var i = this.gl
                    , e = e || this.createImageBuffer();
                return i.bindBuffer(i.ARRAY_BUFFER, e),
                    i.bufferData(i.ARRAY_BUFFER, t, i.STATIC_DRAW),
                    e
            }
            ,
            t.createImageBuffer = function() {
                return this.getImageBuffer() || this.createBuffer()
            }
            ,
            t.removeGLCanvas = function() {
                var t, e = this.gl;
                e && (this._debugBuffer && (e.deleteBuffer(this._debugBuffer),
                    delete this._debugBuffer),
                this._buffers && (this._buffers.forEach(function(t) {
                    e.deleteBuffer(t)
                }),
                    delete this._buffers),
                this._textures && (this._textures.forEach(function(t) {
                    return e.deleteTexture(t)
                }),
                    delete this._textures),
                this._debugInfoCanvas && ((t = this._debugInfoCanvas.texture) && e.deleteTexture(t),
                    delete this._debugInfoCanvas.texture,
                    delete this._debugInfoCanvas),
                    t = e.program,
                    e.deleteShader(t.fragmentShader),
                    e.deleteShader(t.vertexShader),
                    e.deleteProgram(t),
                    delete this.gl,
                    delete this.canvas2)
            }
            ,
            t.createBuffer = function() {
                var t = this.gl.createBuffer();
                if (t)
                    return this._buffers || (this._buffers = []),
                        this._buffers.push(t),
                        t;
                throw new Error("Failed to create the buffer object")
            }
            ,
            t.enableVertexAttrib = function(t) {
                var e = this.gl
                    , i = this.gl.program
                    , n = t;
                if (Array.isArray(n[0])) {
                    for (var r = Float32Array.BYTES_PER_ELEMENT, o = 0, s = 0; s < n.length; s++)
                        o += n[s][1] || 0;
                    for (var a = 0, h = 0; h < n.length; h++) {
                        var l = e.getAttribLocation(i, n[h][0]);
                        if (l < 0)
                            throw new Error("Failed to get the storage location of " + n[h][0]);
                        e.vertexAttribPointer(l, n[h][1], e[n[h][2] || "FLOAT"], !1, r * o, r * a),
                            a += n[h][1] || 0,
                            e.enableVertexAttribArray(l)
                    }
                } else {
                    t = e.getAttribLocation(i, n[0]);
                    e.vertexAttribPointer(t, n[1], e[n[2] || "FLOAT"], !1, 0, 0),
                        e.enableVertexAttribArray(t)
                }
            }
            ,
            t.createProgram = function(t, e, i) {
                var t = function(t, e, i) {
                    if (e = _l(t, t.VERTEX_SHADER, e),
                        i = _l(t, t.FRAGMENT_SHADER, i),
                    !e || !i)
                        return null;
                    var n = t.createProgram();
                    return n ? (t.attachShader(n, e),
                        t.attachShader(n, i),
                        t.linkProgram(n),
                        {
                            program: n,
                            vertexShader: e,
                            fragmentShader: i
                        }) : null
                }(this.gl, t, e)
                    , e = t.program
                    , n = t.vertexShader
                    , t = t.fragmentShader;
                return e.vertexShader = n,
                    e.fragmentShader = t,
                    this._initUniforms(e, i),
                    e
            }
            ,
            t.useProgram = function(t) {
                var e = this.gl;
                return e.useProgram(t),
                    e.program = t,
                    this
            }
            ,
            t.enableSampler = function(t, e) {
                var i = this.gl
                    , t = this._getUniform(i.program, t);
                return i.uniform1i(t, e = e || 0),
                    t
            }
            ,
            t._initUniforms = function(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i]
                        , r = e[i]
                        , o = n.indexOf("[");
                    0 <= o && (n = n.substring(0, o),
                    $ || (r = r.substring(0, o))),
                        t[n] = this._getUniform(t, r)
                }
            }
            ,
            t._getUniform = function(t, e) {
                t = this.gl.getUniformLocation(t, e);
                if (t)
                    return t;
                throw new Error("Failed to get the storage location of " + e)
            }
            ,
            m((t = i).prototype, {
                set8: (l = c.ie9 ? null : new Float32Array(8),
                        function(t, e, i, n, r, o, s, a) {
                            return l[0] = t,
                                l[1] = e,
                                l[2] = i,
                                l[3] = n,
                                l[4] = r,
                                l[5] = o,
                                l[6] = s,
                                l[7] = a,
                                l
                        }
                ),
                set8Int: (h = c.ie9 ? null : new Int16Array(8),
                        function(t, e, i, n, r, o, s, a) {
                            return h[0] = t,
                                h[1] = e,
                                h[2] = i,
                                h[3] = n,
                                h[4] = r,
                                h[5] = o,
                                h[6] = s,
                                h[7] = a,
                                h
                        }
                )
            }),
            t
    }
    var vl, xl = "\n        attribute vec2 a_position;\n\n        attribute vec2 a_texCoord;\n\n        uniform mat4 u_matrix;\n\n        varying vec2 v_texCoord;\n\n        void main() {\n            gl_Position = u_matrix * vec4(a_position, 0., 1.);\n\n            v_texCoord = a_texCoord;\n        }\n    ", wl = "\n        precision mediump float;\n\n        uniform sampler2D u_image;\n\n        uniform float u_opacity;\n        uniform float u_debug_line;\n\n        varying vec2 v_texCoord;\n\n        void main() {\n            if (u_debug_line == 1.) {\n                gl_FragColor = vec4(0., 1., 0., 1.);\n            } else {\n                gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n            }\n        }\n    ", Cl = [0, 0], Pl = [0, 0, 0], bl = new Array(16), Ml = new R(20,20), Sl = {
        renderer: c.webgl ? "gl" : "canvas",
        crossOrigin: null
    }, Tl = new R(0,0), El = (s(kl, vl = kr),
        (El = kl.prototype).onAdd = function() {
            this._prepareImages(this._images)
        }
        ,
        El.setImages = function(t) {
            return this._images = t,
                this._prepareImages(t),
                this
        }
        ,
        El.getImages = function() {
            return this._images
        }
        ,
        El._prepareImages = function(t) {
            t = t || [],
            Array.isArray(t) || (t = [t]);
            var i = this.getMap()
                , t = (this._imageData = t.map(function(t) {
                var e = new g(t.extent);
                return m({}, t, {
                    extent: e,
                    extent2d: e.convertTo(function(t) {
                        return i.coordToPoint(t, i.getGLZoom())
                    })
                })
            }),
                this._images = t,
                this.getRenderer());
            t && t.refreshImages()
        }
        ,
        kl);
    function kl(t, e, i) {
        return !e || Array.isArray(e) || e.url || (i = e,
            e = null),
            (t = vl.call(this, t, i) || this)._images = e,
            t
    }
    El.mergeOptions(Sl);
    var Rl, Al = [], Sl = (s(Ll, Rl = vn),
        (Sl = Ll.prototype).isDrawable = function() {
            return !this.getMap().getPitch() || (console && console.warn("ImageLayer with canvas renderer can't be pitched, use gl renderer ('renderer' : 'gl') instead."),
                !1)
        }
        ,
        Sl.checkResources = function() {
            var i = this;
            if (this._imageLoaded)
                return Al;
            var n, r, t = this.layer._imageData.map(function(t) {
                return [t.url, null, null]
            });
            return this.resources && (n = [],
                r = new Cn,
                t.forEach(function(t) {
                    var e;
                    i.resources.isResourceLoaded(t) ? (e = i.resources.getImage(t),
                        r.addResource(t, e)) : n.push(t)
                }),
                this.resources.forEach(function(t, e) {
                    r.isResourceLoaded(t) || i.retireImage(e.image)
                }),
                this.resources = r,
                t = n),
                this._imageLoaded = !0,
                t
        }
        ,
        Sl.retireImage = function() {}
        ,
        Sl.refreshImages = function() {
            this._imageLoaded = !1,
                this.setToRedraw()
        }
        ,
        Sl.needToRedraw = function() {
            var t = this.getMap();
            return !(t.isZooming() && !t.getPitch()) && Rl.prototype.needToRedraw.call(this)
        }
        ,
        Sl.draw = function() {
            this.isDrawable() && (this.prepareCanvas(),
                this._painted = !1,
                this._drawImages(),
                this.completeRender())
        }
        ,
        Sl._drawImages = function() {
            var t = this.layer._imageData
                , e = this.getMap()
                , i = e._get2DExtent(e.getGLZoom());
            if (t && t.length)
                for (var n = 0; n < t.length; n++) {
                    var r = t[n].extent2d
                        , o = this.resources && this.resources.getImage(t[n].url);
                    o && i.intersects(r) && (this._painted = !0,
                        this._drawImage(o, r, t[n].opacity || 1))
                }
        }
        ,
        Sl._drawImage = function(t, e, i) {
            var n = 0
                , r = this.context
                , i = (i < 1 && (n = r.globalAlpha,
                r.globalAlpha = i),
                this.getMap())
                , o = Tl.set(e.xmin, e.ymax)
                , o = i._pointToContainerPoint(o, i.getGLZoom())
                , s = o.x
                , o = o.y
                , a = i.getBearing()
                , i = (a && (r.save(),
                r.translate(s, o),
            a && r.rotate(-a * Math.PI / 180),
                s = o = 0),
                i.getGLScale());
            r.drawImage(t, s, o, e.getWidth() / i, e.getHeight() / i),
            a && r.restore(),
            n && (r.globalAlpha = n)
        }
        ,
        Sl.drawOnInteracting = function() {
            this.draw()
        }
        ,
        Ll);
    function Ll() {
        return Rl.apply(this, arguments) || this
    }
    s(Il, Ol = yl(Sl)),
        (Dl = Il.prototype).isDrawable = function() {
            return !0
        }
        ,
        Dl._drawImage = function(t, e, i) {
            this.drawGLImage(t, e.xmin, e.ymax, e.getWidth(), e.getHeight(), 1, i)
        }
        ,
        Dl.createContext = function() {
            this.createGLContext()
        }
        ,
        Dl.resizeCanvas = function(t) {
            this.canvas && (Ol.prototype.resizeCanvas.call(this, t),
                this.resizeGLCanvas())
        }
        ,
        Dl.clearCanvas = function() {
            this.canvas && (Ol.prototype.clearCanvas.call(this),
                this.clearGLCanvas())
        }
        ,
        Dl.retireImage = function(t) {
            this.disposeImage(t)
        }
        ,
        Dl.onRemove = function() {
            this.removeGLCanvas(),
                Ol.prototype.onRemove.call(this)
        }
    ;
    var Ol, Dl = Il;
    function Il() {
        return Ol.apply(this, arguments) || this
    }
    El.registerRenderer("canvas", Sl),
        El.registerRenderer("gl", Dl);
    s(Zl, jl = vn),
        (zl = Zl.prototype).getPrepareParams = function() {
            return []
        }
        ,
        zl.getDrawParams = function() {
            return []
        }
        ,
        zl.onCanvasCreate = function() {
            this.canvas && this.layer.options.doubleBuffer && (this.buffer = O.createCanvas(this.canvas.width, this.canvas.height, this.getMap().CanvasClass))
        }
        ,
        zl.needToRedraw = function() {
            return !!this.layer.options.animation || !(this.getMap().isInteracting() && !this.layer.drawOnInteracting) && jl.prototype.needToRedraw.call(this)
        }
        ,
        zl.draw = function() {
            this.prepareCanvas(),
                this.prepareDrawContext(),
                this._drawLayer()
        }
        ,
        zl.drawOnInteracting = function() {
            this._drawLayerOnInteracting()
        }
        ,
        zl.getCanvasImage = function() {
            var t, e, i, n = jl.prototype.getCanvasImage.call(this);
            return n && n.image && this.layer.options.doubleBuffer && (t = n.image,
            this.buffer.width === t.width && this.buffer.height === t.height || (this.buffer.width = t.width,
                this.buffer.height = t.height),
                e = this.buffer.getContext("2d"),
            void 0 !== (i = this.layer.doubleBuffer(e, this.context)) && !i || (O.image(e, t, 0, 0),
                n.image = this.buffer)),
                n
        }
        ,
        zl.remove = function() {
            return delete this._drawContext,
                jl.prototype.remove.call(this)
        }
        ,
        zl.onZoomStart = function(t) {
            this.layer.onZoomStart(t),
                jl.prototype.onZoomStart.call(this, t)
        }
        ,
        zl.onZooming = function(t) {
            this.layer.onZooming(t),
                jl.prototype.onZooming.call(this, t)
        }
        ,
        zl.onZoomEnd = function(t) {
            this.layer.onZoomEnd(t),
                jl.prototype.onZoomEnd.call(this, t)
        }
        ,
        zl.onMoveStart = function(t) {
            this.layer.onMoveStart(t),
                jl.prototype.onMoveStart.call(this, t)
        }
        ,
        zl.onMoving = function(t) {
            this.layer.onMoving(t),
                jl.prototype.onMoving.call(this, t)
        }
        ,
        zl.onMoveEnd = function(t) {
            this.layer.onMoveEnd(t),
                jl.prototype.onMoveEnd.call(this, t)
        }
        ,
        zl.onResize = function(t) {
            this.layer.onResize(t),
                jl.prototype.onResize.call(this, t)
        }
        ,
        zl.prepareDrawContext = function() {
            var t;
            this._predrawed || (t = Hl(this.getPrepareParams()),
                this._drawContext = this.layer.prepareToDraw.apply(this.layer, [this.context].concat(t)),
            this._drawContext || (this._drawContext = []),
            Array.isArray(this._drawContext) || (this._drawContext = [this._drawContext]),
                this._predrawed = !0)
        }
        ,
        zl._prepareDrawParams = function() {
            if (!this.getMap())
                return null;
            var t = this.getViewExtent();
            if (t.maskExtent && !t.extent.intersects(t.maskExtent))
                return this.completeRender(),
                    null;
            var t = [this.context, t]
                , e = Hl(this.getDrawParams());
            return t.push.apply(t, e),
                t.push.apply(t, this._drawContext),
                t
        }
        ,
        zl._drawLayer = function() {
            var t = this._prepareDrawParams();
            t && (this.layer.draw.apply(this.layer, t),
                this.completeRender())
        }
        ,
        zl._drawLayerOnInteracting = function() {
            var t;
            !this.layer.drawOnInteracting || (t = this._prepareDrawParams()) && (this.layer.drawOnInteracting.apply(this.layer, t),
                this.completeRender())
        }
    ;
    var jl, zl = Zl;
    function Zl() {
        return jl.apply(this, arguments) || this
    }
    function Hl(t) {
        return t = t || [],
            t = Array.isArray(t) ? t : [t]
    }
    s(Nl, Gl = kr),
        (Fl = Nl.prototype).isCanvasRender = function() {
            return !0
        }
        ,
        Fl.prepareToDraw = function() {}
        ,
        Fl.draw = function() {}
        ,
        Fl.redraw = function() {
            return this._getRenderer() && this._getRenderer().setToRedraw(),
                this
        }
        ,
        Fl.play = function() {
            return this.config("animation", !0),
                this
        }
        ,
        Fl.pause = function() {
            return this.config("animation", !1),
                this
        }
        ,
        Fl.isPlaying = function() {
            return this.options.animation
        }
        ,
        Fl.clearCanvas = function() {
            return this._getRenderer() && this._getRenderer().clearCanvas(),
                this
        }
        ,
        Fl.requestMapToRender = function() {
            return this._getRenderer() && this._getRenderer().requestMapToRender(),
                this
        }
        ,
        Fl.completeRender = function() {
            return this._getRenderer() && this._getRenderer().completeRender(),
                this
        }
        ,
        Fl.onCanvasCreate = function() {
            return this
        }
        ,
        Fl.onZoomStart = function() {}
        ,
        Fl.onZooming = function() {}
        ,
        Fl.onZoomEnd = function() {}
        ,
        Fl.onMoveStart = function() {}
        ,
        Fl.onMoving = function() {}
        ,
        Fl.onMoveEnd = function() {}
        ,
        Fl.onResize = function() {}
        ,
        Fl.doubleBuffer = function(t) {
            return t.clearRect(0, 0, t.canvas.width, t.canvas.height),
                this
        }
    ;
    var Gl, Fl = Nl;
    function Nl() {
        return Gl.apply(this, arguments) || this
    }
    Fl.mergeOptions({
        doubleBuffer: !1,
        animation: !1
    }),
        Fl.registerRenderer("canvas", zl);
    var Wl, Bl, Vl = new R(0,0), Ul = (s(Jl, Wl = Fl),
        (Ul = Jl.prototype).getParticles = function() {}
        ,
        Ul.draw = function(t, e) {
            var i = this.getParticles(F());
            if (i && 0 !== i.length) {
                for (var n = this.getMap(), r = e.extent, o = (r = (r = e.maskExtent ? e.extent.intersection(e.maskExtent) : r).convertTo(function(t) {
                    return n._pointToContainerPoint(t, void 0, 0, Vl)
                }),
                2 * Math.PI), s = 0, a = i.length; s < a; s++) {
                    var h, l, u = i[s].point;
                    r.contains(u) && (h = i[s].color || this.options.lineColor || "#fff",
                        l = i[s].r,
                    t.fillStyle !== h && (t.fillStyle = h),
                        l <= 2 ? t.fillRect(u.x - l / 2, u.y - l / 2, l, l) : (t.beginPath(),
                            t.arc(u.x, u.y, l / 2, 0, o),
                            t.fill()))
                }
                this._fillCanvas(t)
            } else
                this._getRenderer() && (this._getRenderer()._shouldClear = !0)
        }
        ,
        Ul._fillCanvas = function(t) {
            var e = t.globalCompositeOperation
                , i = (t.globalCompositeOperation = "destination-out",
            this.options.trail || 30);
            t.fillStyle = "rgba(0, 0, 0, " + 1 / i + ")",
                t.fillRect(0, 0, t.canvas.width, t.canvas.height),
                t.globalCompositeOperation = e
        }
        ,
        Jl);
    function Jl() {
        return Wl.apply(this, arguments) || this
    }
    function ql() {
        return Bl.apply(this, arguments) || this
    }
    Ul.mergeOptions({
        animation: !0
    }),
        Ul.registerRenderer("canvas", (s(ql, Bl = zl),
            (Xl = ql.prototype).draw = function() {
                this.canvas && this.layer.options.animation && !this._shouldClear || (this.prepareCanvas(),
                    this._shouldClear = !1),
                    this.prepareDrawContext(),
                    this._drawLayer()
            }
            ,
            Xl.drawOnInteracting = function() {
                this.draw(),
                    this._shouldClear = !1
            }
            ,
            Xl.onSkipDrawOnInteracting = function() {
                this._shouldClear = !0
            }
            ,
            ql));
    s(Kl, Yl = vn),
        (Xl = Kl.prototype).checkResources = function() {
            var t = this._geosToCheck;
            if (!L(t = this._resourceChecked || t ? t : this.layer._geoList))
                return [];
            for (var e = [], i = {}, n = t.length - 1; 0 <= n; n--) {
                var r = t[n]._getExternalResources();
                if (r.length)
                    if (this.resources)
                        for (var o = 0; o < r.length; o++) {
                            var s = r[o][0];
                            this.resources.isResourceLoaded(r[o]) || i[s] || (e.push(r[o]),
                                i[s] = 1)
                        }
                    else
                        e.push.apply(e, r)
            }
            return this._resourceChecked = !0,
                delete this._geosToCheck,
                e
        }
        ,
        Xl.render = function() {
            return this.layer._sortGeometries(),
                Yl.prototype.render.apply(this, arguments)
        }
        ,
        Xl._addGeoToCheckRes = function(t) {
            t && (Array.isArray(t) || (t = [t]),
            this._geosToCheck || (this._geosToCheck = []),
                ot(this._geosToCheck, t))
        }
        ,
        Xl.onGeometryAdd = function(t) {
            this._addGeoToCheckRes(t),
                Ql(this)
        }
        ,
        Xl.onGeometryRemove = function() {
            Ql(this)
        }
        ,
        Xl.onGeometrySymbolChange = function(t) {
            this._addGeoToCheckRes(t.target),
                Ql(this)
        }
        ,
        Xl.onGeometryShapeChange = function() {
            Ql(this)
        }
        ,
        Xl.onGeometryPositionChange = function() {
            Ql(this)
        }
        ,
        Xl.onGeometryZIndexChange = function() {
            Ql(this)
        }
        ,
        Xl.onGeometryShow = function() {
            Ql(this)
        }
        ,
        Xl.onGeometryHide = function() {
            Ql(this)
        }
        ,
        Xl.onGeometryPropertiesChange = function() {
            Ql(this)
        }
    ;
    var Yl, Xl = Kl;
    function Kl() {
        return Yl.apply(this, arguments) || this
    }
    function Ql(t) {
        t.layer.options.drawImmediate && t.render(),
            t.setToRedraw()
    }
    var $l, tu = new U, eu = (s(iu, $l = Xl),
        (eu = iu.prototype).checkResources = function() {
            var r = this
                , o = $l.prototype.checkResources.apply(this, arguments)
                , t = this.layer.getStyle();
            return t && (t = Array.isArray(t) ? t : [t]).forEach(function(t) {
                for (var e = Qt(t.symbol, !0), i = 0, n = e.length; i < n; i++)
                    r.resources.isResourceLoaded(e[i]) || o.push(e[i])
            }),
                o
        }
        ,
        eu.needToRedraw = function() {
            var t = this.getMap();
            return !(!t.isInteracting() || !this.layer.options.enableAltitude) || !(t.isZooming() && !t.isRotating() && !t.getPitch() && !this._hasPoint && this.layer.constructor === Us) && $l.prototype.needToRedraw.call(this)
        }
        ,
        eu.draw = function() {
            if (this.getMap()) {
                if (!this.layer.isVisible() || this.layer.isEmpty())
                    return this.clearCanvas(),
                        void this.completeRender();
                this.prepareCanvas(),
                    this.drawGeos(),
                    this.completeRender()
            }
        }
        ,
        eu.isBlank = function() {
            return !!this.context && !this.context.canvas._drawn
        }
        ,
        eu.drawOnInteracting = function() {
            if (this._geosToDraw) {
                this._updateDisplayExtent();
                var t = this.getMap()
                    , e = this.layer.getCount()
                    , i = this.getMap().getResolution();
                (t.isZooming() && t.options.seamlessZoom && void 0 !== this._drawnRes && i > 1.5 * this._drawnRes && this._geosToDraw.length < e || t.isMoving() || t.isInteracting()) && (this.prepareToDraw(),
                    this.forEachGeo(this.checkGeo, this),
                    this._drawnRes = i);
                for (var n = 0, r = this._geosToDraw.length; n < r; n++) {
                    var o = this._geosToDraw[n];
                    o.isVisible() && o._paint(this._displayExtent)
                }
            }
        }
        ,
        eu.show = function() {
            this.layer.forEach(function(t) {
                t._repaint()
            }),
                $l.prototype.show.apply(this, arguments)
        }
        ,
        eu.forEachGeo = function(t, e) {
            this.layer.forEach(t, e)
        }
        ,
        eu.drawGeos = function() {
            this._drawnRes = this.getMap().getResolution(),
                this._updateDisplayExtent(),
                this.prepareToDraw(),
                this.forEachGeo(this.checkGeo, this);
            for (var t = 0, e = this._geosToDraw.length; t < e; t++)
                this._geosToDraw[t]._paint()
        }
        ,
        eu.prepareToDraw = function() {
            this._hasPoint = !1,
                this._geosToDraw = []
        }
        ,
        eu.checkGeo = function(t) {
            var e, i;
            t && t.isVisible() && t.getMap() && t.getLayer() && t.getLayer().isCanvasRender() && ((i = (e = t._getPainter()).get2DExtent(this.resources, tu)) && i.intersects(this._displayExtent) && (e.hasPoint() && (this._hasPoint = !0),
                this._geosToDraw.push(t)))
        }
        ,
        eu.onZoomEnd = function() {
            delete this.canvasExtent2D,
                $l.prototype.onZoomEnd.apply(this, arguments)
        }
        ,
        eu.onRemove = function() {
            this.forEachGeo(function(t) {
                t.onHide()
            }),
                delete this._geosToDraw
        }
        ,
        eu.onGeometryPropertiesChange = function(t) {
            t && this.layer._styleGeometry(t.target),
                $l.prototype.onGeometryPropertiesChange.call(this, t)
        }
        ,
        eu._updateDisplayExtent = function() {
            var t = this.canvasExtent2D;
            if (this._maskExtent) {
                if (!this._maskExtent.intersects(t))
                    return void this.completeRender();
                t = t.intersection(this._maskExtent)
            }
            this._displayExtent = t
        }
        ,
        eu.identify = function(t, e) {
            void 0 === e && (e = {});
            var i = this._geosToDraw;
            return i ? this.layer._hitGeos(i, t, e) : []
        }
        ,
        iu);
    function iu() {
        return $l.apply(this, arguments) || this
    }
    Us.registerRenderer("canvas", eu);
    s(ou, nu = Us),
        ou.fromJSON = function(t) {
            if (!t || "ClusterLayer" !== t.type)
                return null;
            for (var e = new ou(t.id,t.options), i = t.geometries, n = [], r = 0; r < i.length; r++) {
                var o = y.fromJSON(i[r]);
                o && n.push(o)
            }
            return e.addGeometry(n),
                e
        }
        ,
        (ru = ou.prototype).addMarker = function(t) {
            return this.addGeometry(t)
        }
        ,
        ru.addGeometry = function(t) {
            for (var e = 0, i = t.length; e <= i; e++)
                if (!t[e]instanceof Ao)
                    throw new Error("Only a point(Marker) can be added into a ClusterLayer");
            return nu.prototype.addGeometry.apply(this, arguments)
        }
        ,
        ru.onConfig = function(t) {
            return nu.prototype.onConfig.call(this, t),
            (t.maxClusterRadius || t.symbol || t.drawClusterText || t.textSymbol || t.maxClusterZoom) && (t = this._getRenderer()) && t.render(),
                this
        }
        ,
        ru.identify = function(t, e) {
            var i = this.getMap()
                , n = this.options.maxClusterZoom;
            return n && i && i.getZoom() > n ? e.onlyCluster ? null : nu.prototype.identify.call(this, t, e) : this._getRenderer() ? this._getRenderer().identify(t, e) : null
        }
        ,
        ru.toJSON = function() {
            var t = nu.prototype.toJSON.call(this);
            return t.type = "ClusterLayer",
                t
        }
        ,
        ru.getClusters = function() {
            var t = this._getRenderer();
            return t && t._currentClusters || []
        }
    ;
    var nu, ru = ou;
    function ou() {
        return nu.apply(this, arguments) || this
    }
    ru.mergeOptions({
        maxClusterRadius: 160,
        textSumProperty: null,
        symbol: null,
        drawClusterText: !0,
        textSymbol: null,
        animation: !0,
        animationDuration: 450,
        maxClusterZoom: null,
        noClusterWithOneMarker: !0,
        minClusterSize: 1,
        forceRenderOnZooming: !0
    }),
        ru.registerJSONType("ClusterLayer");
    var su, au = {
        textFaceName: '"microsoft yahei"',
        textSize: 16,
        textDx: 0,
        textDy: 0
    }, hu = {
        markerType: "ellipse",
        markerFill: {
            property: "count",
            type: "interval",
            stops: [[0, "rgb(135, 196, 240)"], [9, "#1bbc9b"], [99, "rgb(216, 115, 149)"]]
        },
        markerFillOpacity: .7,
        markerLineOpacity: 1,
        markerLineWidth: 3,
        markerLineColor: "#fff",
        markerWidth: {
            property: "count",
            type: "interval",
            stops: [[0, 40], [9, 60], [99, 80]]
        },
        markerHeight: {
            property: "count",
            type: "interval",
            stops: [[0, 40], [9, 60], [99, 80]]
        }
    };
    function lu(t) {
        t = su.call(this, t) || this;
        return t._animated = !0,
            t._refreshStyle(),
            t._clusterNeedRedraw = !0,
            t
    }
    ru.registerRenderer("canvas", (s(lu, su = eu),
        (E = lu.prototype).checkResources = function() {
            var t, e = this.layer.options.symbol || hu, i = su.prototype.checkResources.apply(this, arguments);
            return e !== this._symbolResourceChecked && ((t = Qt(e, !0)) && i.push.apply(i, t),
                this._symbolResourceChecked = e),
                i
        }
        ,
        E.draw = function() {
            this.canvas || this.prepareCanvas();
            var t = this.getMap().getZoom()
                , e = this.layer.options.maxClusterZoom;
            if (e && e < t)
                return delete this._currentClusters,
                    this._markersToDraw = this.layer._geoList,
                    void su.prototype.draw.apply(this, arguments);
            this._clusterNeedRedraw && (this._clearDataCache(),
                this._computeGrid(),
                this._clusterNeedRedraw = !1);
            e = this._clusterCache[t] ? this._clusterCache[t].clusters : null,
                e = this._getClustersToDraw(e);
            e.zoom = t,
                this._drawLayer(e)
        }
        ,
        E._getClustersToDraw = function(i) {
            var n, r, o, t, s = this, a = (this._markersToDraw = [],
                this.getMap()), h = Ge("9", Ve(this._textSymbol)).toPoint(), l = a.getContainerExtent(), u = [];
            for (t in i)
                (function(e) {
                        s._currentGrid = i[e],
                            i[e].count < s.layer.options.minClusterSize ? i[e].children.forEach(function(t) {
                                t._cluster = i[e],
                                    s._markersToDraw.push(t)
                            }) : (o = s._getSprite(),
                                r = o.canvas.width,
                                o = o.canvas.height,
                                n = a._prjToContainerPoint(i[e].center),
                                n = new U(n.sub(r, o),n.add(r, o)),
                            l.intersects(n) && (i[e].textSize || (t = s._getClusterText(i[e]),
                                i[e].textSize = new R(h.x * t.length,h.y)._multi(.5)),
                                u.push(i[e])));
                        var t
                    }
                )(t);
            return u
        }
        ,
        E.drawOnInteracting = function() {
            this._currentClusters && this._drawClusters(this._currentClusters, 1),
                su.prototype.drawOnInteracting.apply(this, arguments)
        }
        ,
        E.forEachGeo = function(e, i) {
            this._markersToDraw && this._markersToDraw.forEach(function(t) {
                i ? e.call(i, t) : e(t)
            })
        }
        ,
        E.onGeometryShow = function() {
            this._clusterNeedRedraw = !0,
                su.prototype.onGeometryShow.apply(this, arguments)
        }
        ,
        E.onGeometryHide = function() {
            this._clusterNeedRedraw = !0,
                su.prototype.onGeometryHide.apply(this, arguments)
        }
        ,
        E.onGeometryAdd = function() {
            this._clusterNeedRedraw = !0,
                su.prototype.onGeometryAdd.apply(this, arguments)
        }
        ,
        E.onGeometryRemove = function() {
            this._clusterNeedRedraw = !0,
                su.prototype.onGeometryRemove.apply(this, arguments)
        }
        ,
        E.onGeometryPositionChange = function() {
            this._clusterNeedRedraw = !0,
                su.prototype.onGeometryPositionChange.apply(this, arguments)
        }
        ,
        E.onRemove = function() {
            this._clearDataCache()
        }
        ,
        E.identify = function(t, e) {
            var i = this.getMap()
                , n = this.layer.options.maxClusterZoom;
            if (n && i.getZoom() > n)
                return e.onlyCluster ? null : su.prototype.identify.call(this, t, e);
            if (this._currentClusters) {
                for (var r = i.coordinateToContainerPoint(t), n = this._currentGrid, o = 0; o < this._currentClusters.length; o++) {
                    var s = this._currentClusters[o]
                        , a = i._prjToContainerPoint(s.center)
                        , h = (this._currentGrid = s,
                        this._getSprite().canvas.width);
                    if (r.distanceTo(a) <= h)
                        return {
                            center: i.getProjection().unproject(s.center.copy()),
                            children: s.children.slice(0)
                        }
                }
                this._currentGrid = n
            }
            return this._markersToDraw && !e.onlyCluster ? this.layer._hitGeos(this._markersToDraw, t, e) : null
        }
        ,
        E.onSymbolChanged = function() {
            this._refreshStyle(),
                this._computeGrid(),
                this._stopAnim(),
                this.setToRedraw()
        }
        ,
        E._refreshStyle = function() {
            function t() {
                return [e.getMap().getZoom(), e._currentGrid]
            }
            var e = this
                , i = this.layer.options.symbol || hu
                , n = this.layer.options.textSymbol || au;
            this._symbol = Ut(i, t),
                this._textSymbol = Ut(n, t)
        }
        ,
        E._drawLayer = function(e) {
            var t, i = this, n = this._currentClusters || e, r = (this._currentClusters = e,
                delete this._clusterMaskExtent,
                this.layer);
            r.options.animation && this._animated && this._inout ? (t = [0, 1],
            "in" === this._inout && (t = [1, 0]),
                this._player = Po.animate({
                    d: t
                }, {
                    speed: r.options.animationDuration,
                    easing: "inAndOut"
                }, function(t) {
                    "finished" === t.state.playState ? (i._animated = !1,
                        i._drawClusters(e, 1),
                        i._drawMarkers(),
                        i.completeRender()) : ("in" === i._inout ? i._drawClustersFrame(e, n, t.styles.d) : i._drawClustersFrame(n, e, t.styles.d),
                        i.setCanvasUpdated())
                }).play()) : (this._animated = !1,
                this._drawClusters(e, 1),
                this._drawMarkers(),
                this.completeRender())
        }
        ,
        E._drawMarkers = function() {
            su.prototype.drawGeos.call(this, this._clusterMaskExtent)
        }
        ,
        E._drawClustersFrame = function(t, e, r) {
            var o, s, a, h = this, l = (this._clusterMaskExtent = this.prepareCanvas(),
                this.getMap()), i = {};
            t && t.forEach(function(t) {
                var e = l._prjToContainerPoint(t.center);
                i[t.key] || (i[t.key] = 1,
                    h._drawCluster(e, t, 1 - r))
            }),
            0 !== r && e && (o = t.zoom,
                s = l._getResolution(o) * this.layer.options.maxClusterRadius,
                a = this._markerExtent.getMin(),
                e.forEach(function(t) {
                    var e = l._prjToContainerPoint(t.center)
                        , i = t.center
                        , n = Math.floor((i.x - a.x) / s)
                        , i = Math.floor((i.y - a.y) / s)
                        , n = h._clusterCache[o].clusterMap[n + "_" + i];
                    n && (e = (i = l._prjToContainerPoint(n.center)).add(e.sub(i)._multi(r))),
                        h._drawCluster(e, t, .5 < r ? 1 : r)
                }))
        }
        ,
        E._drawClusters = function(t, i) {
            var n, r = this;
            t && (this._clusterMaskExtent = this.prepareCanvas(),
                n = this.getMap(),
                t.forEach(function(t) {
                    var e = n._prjToContainerPoint(t.center);
                    r._drawCluster(e, t, .5 < i ? 1 : i)
                }))
        }
        ,
        E._drawCluster = function(t, e, i) {
            this._currentGrid = e;
            var n, r = this.context, o = this._getSprite(), s = r.globalAlpha;
            s * i != 0 && (r.globalAlpha = s * i,
            o && (i = t.add(o.offset)._sub(o.canvas.width / 2, o.canvas.height / 2),
                r.drawImage(o.canvas, i.x, i.y)),
            this.layer.options.drawClusterText && e.textSize && (O.prepareCanvasFont(r, this._textSymbol),
                r.textBaseline = "middle",
                o = this._textSymbol.textDx || 0,
                i = this._textSymbol.textDy || 0,
                n = this._getClusterText(e),
                O.fillText(r, n, t.sub(e.textSize.x, 0)._add(o, i))),
                r.globalAlpha = s)
        }
        ,
        E._getClusterText = function(t) {
            return (this.layer.options.textSumProperty ? t.textSumProperty : t.count) + ""
        }
        ,
        E._getSprite = function() {
            this._spriteCache || (this._spriteCache = {});
            var t = ie(this._symbol);
            return this._spriteCache[t] || (this._spriteCache[t] = new Ao([0, 0],{
                symbol: this._symbol
            })._getSprite(this.resources, this.getMap().CanvasClass)),
                this._spriteCache[t]
        }
        ,
        E._initGridSystem = function() {
            var e, i, n = [];
            this.layer.forEach(function(t) {
                t.isVisible() && (i = t._getPrjCoordinates(),
                    e = e ? e._combine(t._getPrjExtent()) : t._getPrjExtent(),
                    n.push({
                        x: i.x,
                        y: i.y,
                        id: t._getInternalId(),
                        geometry: t
                    }))
            }),
                this._markerExtent = e,
                this._markerPoints = n
        }
        ,
        E._computeGrid = function() {
            var t = this.getMap()
                , e = t.getZoom()
                , t = (this._markerExtent || this._initGridSystem(),
            this._clusterCache || (this._clusterCache = {}),
                t._getResolution(t.getMinZoom()) > t._getResolution(t.getMaxZoom()) ? e - 1 : e + 1);
            this._clusterCache[t] && this._clusterCache[t].length === this.layer.getCount() && (this._clusterCache[e] = this._clusterCache[t]),
            this._clusterCache[e] || (this._clusterCache[e] = this._computeZoomGrid(e))
        }
        ,
        E._computeZoomGrid = function(t) {
            if (!this._markerExtent)
                return null;
            for (var e, i = this.getMap(), n = i._getResolution(t) * this.layer.options.maxClusterRadius, r = i._getResolution(t - 1) ? i._getResolution(t - 1) * this.layer.options.maxClusterRadius : null, o = this._clusterCache[t - 1], s = (!o && t - 1 >= i.getMinZoom() && (this._clusterCache[t - 1] = o = this._computeZoomGrid(t - 1)),
                this._markerPoints), a = this.layer.options.textSumProperty, h = {}, l = this._markerExtent.getMin(), u = 0, c = s.length; u < c; u++) {
                var d = s[u].geometry
                    , g = 0;
                a && d.getProperties() && d.getProperties()[a] && (g = d.getProperties()[a]),
                    h[e = Math.floor((s[u].x - l.x) / n) + "_" + Math.floor((s[u].y - l.y) / n)] ? (h[e].sum._add(new M(s[u].x,s[u].y)),
                        h[e].count++,
                        h[e].center = h[e].sum.multi(1 / h[e].count),
                        h[e].children.push(d),
                        h[e].textSumProperty += g) : (h[e] = {
                        sum: new M(s[u].x,s[u].y),
                        center: new M(s[u].x,s[u].y),
                        count: 1,
                        textSumProperty: g,
                        children: [d],
                        key: e
                    },
                    r && o && (g = Math.floor((s[u].x - l.x) / r),
                        d = Math.floor((s[u].y - l.y) / r),
                        h[e].parent = o.clusterMap[g + "_" + d]))
            }
            return this._mergeClusters(h, n / 2)
        }
        ,
        E._mergeClusters = function(t, e) {
            var i, n = {};
            for (i in t)
                n[i] = t[i];
            var r, o, s, a = {}, h = {};
            for (o in t)
                if (!h[(r = t[o]).key])
                    for (var l = r.key.split("_"), u = +l[0], c = +l[1], d = -1; d <= 1; d++)
                        for (var g, p = -1; p <= 1; p++)
                            0 === d && 0 === p || (g = t[u + d + "_" + (c + p)]) && this._distanceTo(r.center, g.center) <= e && (a[r.key] || (a[r.key] = []),
                                a[r.key].push(g),
                                h[g.key] = 1);
            for (s in a) {
                var f = t[s];
                if (f) {
                    for (var m = a[s], _ = 0; _ < m.length; _++)
                        t[m[_].key] && (f.sum._add(m[_].sum),
                            f.count += m[_].count,
                            f.textSumProperty += m[_].textSumProperty,
                            f.children = f.children.concat(m[_].children),
                            n[m[_].key] = f,
                            delete t[m[_].key]);
                    f.center = f.sum.multi(1 / f.count)
                }
            }
            return {
                clusters: t,
                clusterMap: n
            }
        }
        ,
        E._distanceTo = function(t, e) {
            var i = t.x - e.x
                , t = t.y - e.y;
            return Math.sqrt(i * i + t * t)
        }
        ,
        E._stopAnim = function() {
            this._player && "finished" !== this._player.playState && this._player.finish()
        }
        ,
        E.onZoomStart = function(t) {
            this._stopAnim(),
                su.prototype.onZoomStart.call(this, t)
        }
        ,
        E.onZoomEnd = function(t) {
            this.layer.isEmpty() || !this.layer.isVisible() || (this._inout = t.from > t.to ? "in" : "out",
                this._animated = !0,
                this._computeGrid()),
                su.prototype.onZoomEnd.apply(this, arguments)
        }
        ,
        E._clearDataCache = function() {
            this._stopAnim(),
                delete this._markerExtent,
                delete this._markerPoints,
                delete this._clusterCache,
                delete this._zoomInClusters
        }
        ,
        lu));
    var uu = D + "_edit_stage_";
    function cu(t, e) {
        return {
            markerType: t,
            markerFill: "#fff",
            markerLineColor: "#000",
            markerLineWidth: 2,
            markerWidth: 10,
            markerHeight: 10,
            opacity: e
        }
    }
    var du, E = {
        fixAspectRatio: !1,
        symbol: null,
        removeVertexOn: "contextmenu",
        centerHandleSymbol: cu("ellipse", 1),
        vertexHandleSymbol: cu("square", 1),
        newVertexHandleSymbol: cu("square", .4)
    }, gu = (s(pu, du = Si(_e)),
        (k = pu.prototype).getMap = function() {
            return this._geometry.getMap()
        }
        ,
        k.prepare = function() {
            this.getMap() && (this.options.symbol && (this._originalSymbol = this._geometry.getSymbol(),
                this._geometry.setSymbol(this.options.symbol)),
                this._prepareEditStageLayer())
        }
        ,
        k._prepareEditStageLayer = function() {
            var t = this.getMap()
                , e = it++
                , i = uu + e
                , e = uu + e + "_shadow";
            this._editStageLayer = t.getLayer(i),
                this._shadowLayer = t.getLayer(e),
            this._editStageLayer || (this._editStageLayer = new Us(i),
                t.addLayer(this._editStageLayer)),
            this._shadowLayer || (this._shadowLayer = new Us(e),
                t.addLayer(this._shadowLayer))
        }
        ,
        k.start = function() {
            var t, e, i, n = this;
            this._geometry && this._geometry.getMap() && !this._geometry.editing && (t = this.getMap(),
                this.editing = !0,
                e = this._geometry,
                this._geometryDraggble = e.options.draggable,
                e.config("draggable", !1),
                this.prepare(),
                (i = e.copy()).setSymbol(e._getInternalSymbol()),
                i.copyEventListeners(e),
            e._getParent() && i.copyEventListeners(e._getParent()),
                i._setEventTarget(e),
                i.setId(null).config({
                    draggable: !1
                }),
                this._shadow = i,
                this._switchGeometryEvents("on"),
                e.hide(),
            (e instanceof Ao || e instanceof is || e instanceof hs || e instanceof os) && this._createOrRefreshOutline(),
                this._shadowLayer.bringToFront().addGeometry(i),
                this._editStageLayer.bringToFront(),
                this._addListener([t, "zoomstart", function() {
                    n._editStageLayer.hide()
                }
                ]),
                this._addListener([t, "zoomend", function() {
                    n._editStageLayer.show()
                }
                ]),
                e instanceof Ao ? (i.config("draggable", !0),
                    i.on("dragend", this._onMarkerDragEnd, this)) : this._createCenterHandle(),
                e instanceof Ao ? this.createMarkerEditor() : e instanceof is ? this.createCircleEditor() : e instanceof hs || e instanceof os ? this.createEllipseOrRectEditor() : e instanceof cs || (e instanceof S || e instanceof Io) && this.createPolygonEditor())
        }
        ,
        k.stop = function() {
            delete this._history,
                delete this._historyPointer,
                delete this._editOutline,
                this._switchGeometryEvents("off"),
            this.getMap() && (delete this._shadow,
                this._geometry.config("draggable", this._geometryDraggble),
                delete this._geometryDraggble,
                this._geometry.show(),
                this._editStageLayer.remove(),
                this._shadowLayer.remove(),
                this._clearAllListeners(),
                this._refreshHooks = [],
            this.options.symbol && (this._geometry.setSymbol(this._originalSymbol),
                delete this._originalSymbol),
                this.editing = !1)
        }
        ,
        k.isEditing = function() {
            return !V(this.editing) && this.editing
        }
        ,
        k._getGeometryEvents = function() {
            return {
                symbolchange: this._onGeoSymbolChange,
                "positionchange shapechange": this._exeAndReset
            }
        }
        ,
        k._switchGeometryEvents = function(t) {
            if (this._geometry) {
                var e, i = this._getGeometryEvents();
                for (e in i)
                    this._geometry[t](e, i[e], this)
            }
        }
        ,
        k._onGeoSymbolChange = function(t) {
            this._shadow && this._shadow.setSymbol(t.target._getInternalSymbol())
        }
        ,
        k._onMarkerDragEnd = function() {
            this._update("setCoordinates", this._shadow.getCoordinates().toArray()),
                this._refresh()
        }
        ,
        k._createOrRefreshOutline = function() {
            var t = this._geometry
                , e = this._editOutline;
            return e ? (e.remove(),
                this._editOutline = e = t.getOutline(),
                this._editStageLayer.addGeometry(e)) : (e = t.getOutline(),
                this._editStageLayer.addGeometry(e),
                this._editOutline = e,
                this._addRefreshHook(this._createOrRefreshOutline)),
                e
        }
        ,
        k._createCenterHandle = function() {
            var i, e = this, t = this._shadow.getCenter(), n = this.options.centerHandleSymbol, r = this.createHandle(t, {
                symbol: n,
                cursor: "move",
                onDown: function() {
                    var t = ne((i = e._shadow.copy())._getInternalSymbol(), .5);
                    i.setSymbol(t).addTo(e._editStageLayer)
                },
                onMove: function(t, e) {
                    e = e.coordOffset;
                    i.translate(e)
                },
                onUp: function() {
                    e._update("setCoordinates", M.toNumberArrays(i.getCoordinates())),
                        i.remove(),
                        e._refresh()
                }
            });
            this._addRefreshHook(function() {
                var t = e._shadow.getCenter();
                r.setCoordinates(t)
            })
        }
        ,
        k._createHandleInstance = function(t, e) {
            var i = e.symbol;
            return new Ao(t,{
                draggable: !0,
                dragShadow: !1,
                dragOnAxis: e.axis,
                cursor: e.cursor,
                symbol: i
            })
        }
        ,
        k.createHandle = function(t, i) {
            i = i || {};
            var n = this.getMap()
                , r = this._createHandleInstance(t, i)
                , o = this;
            function e(t) {
                return i.onDown && (this._geometry.fire("handledragstart"),
                    i.onDown.call(o, t.viewPoint, t)),
                    !1
            }
            function s(t) {
                o._hideContext();
                var e = n._prjToViewPoint(r._getPrjCoordinates());
                return i.onMove && (this._geometry.fire("handledragging"),
                    i.onMove.call(o, e, t)),
                    !1
            }
            function a(t) {
                return i.onUp && (this._geometry.fire("handledragend"),
                    i.onUp.call(o, t)),
                    !1
            }
            return r.on("dragstart", e, this),
                r.on("dragging", s, this),
                r.on("dragend", a, this),
                r.on("removestart", function t() {
                    r.config("draggable", !1),
                        r.off("dragstart", e, o),
                        r.off("dragging", s, o),
                        r.off("dragend", a, o),
                        r.off("removestart", t, o),
                        delete r["maptalks--editor-refresh-fn"]
                }, this),
            i.onRefresh && (r["maptalks--editor-refresh-fn"] = i.onRefresh),
                this._editStageLayer.addGeometry(r),
                r
        }
        ,
        k._createResizeHandles = function(o, s, a) {
            var h = this
                , l = ["nw-resize", "n-resize", "ne-resize", "w-resize", "e-resize", "sw-resize", "s-resize", "se-resize"]
                , u = [null, "y", null, "x", "x", null, "y", null]
                , c = this._geometry;
            o = o || [];
            function t() {
                for (var t = c._getPainter().get2DExtent(), r = [new R((t = t).xmin,t.ymax), new R((t.xmax + t.xmin) / 2,t.ymax), new R(t.xmax,t.ymax), new R(t.xmin,(t.ymax + t.ymin) / 2), new R(t.xmax,(t.ymax + t.ymin) / 2), new R(t.xmin,t.ymin), new R((t.xmax + t.xmin) / 2,t.ymin), new R(t.xmax,t.ymin)], e = 0; e < r.length; e++)
                    !function(e) {
                        if (Array.isArray(o) && o.some(function(t) {
                            return t === e
                        }))
                            return;
                        var t, i, n = f.pointToCoordinate(r[e]);
                        g.length < r.length - o.length ? ((t = h.createHandle(n, {
                            symbol: m,
                            cursor: l[e],
                            axis: u[e],
                            onMove: (i = e,
                                    function(t) {
                                        d._updating = !0,
                                            s(t, i),
                                            c.fire("resizing")
                                    }
                            ),
                            onUp: function() {
                                d._updating = !1,
                                    a(),
                                    h._refresh()
                            }
                        })).setId(e),
                            p[e] = g.length,
                            g.push(t)) : g[p[e]].setCoordinates(n)
                    }(e)
            }
            var d = this
                , g = []
                , p = {}
                , f = this.getMap()
                , m = this.options.vertexHandleSymbol;
            return t(),
                this._addRefreshHook(t),
                g
        }
        ,
        k.createMarkerEditor = function() {
            var o, s, a, t, h, l, u = this, c = this._geometry, d = this._shadow, g = this.getMap();
            function e() {
                var t = [["setCoordinates", d.getCoordinates().toArray()]];
                return d instanceof Rs ? (t.push(["setWidth", d.getWidth()]),
                    t.push(["setHeight", d.getHeight()])) : t.push(["setSymbol", d.getSymbol()]),
                    t
            }
            d._canEdit() ? (this._history || this._recordHistory(e()),
                t = d._getInternalSymbol(),
                o = new R(0,0),
            P(t.markerDx) && (o.x = t.markerDx),
            P(t.markerDy) && (o.y = t.markerDy),
                s = null,
                Zn.test(t) ? "pin" !== t.markerType && "pie" !== t.markerType && "bar" !== t.markerType || (s = [5, 6, 7]) : (Bn.test(t) || ir.test(t)) && (s = [5, 6, 7]),
                a = [2, 1, 2, 0, 0, 2, 1, 2],
            this.options.fixAspectRatio && (t = d.getSize(),
                h = t.width / t.height),
                l = this._createResizeHandles(null, function(t, e) {
                    s && 0 <= s.indexOf(e) && (i = g.viewPointToCoordinate(t.sub(o)),
                        n = d.getCoordinates(),
                        i.x = n.x,
                        d.setCoordinates(i),
                        u._updateCoordFromShadow(!0),
                        n = l[l.length - 1 - e],
                        t = g.coordToViewPoint(n.getCoordinates()));
                    var i = g._pointToViewPoint(d._getCenter2DPoint()).add(o)
                        , n = d._getInternalSymbol()
                        , r = t.sub(i)
                        , t = (s && t.y > i.y && (r.y = 0),
                        s ? 1 : 2)
                        , i = 2 * Math.abs(r.x)
                        , r = Math.abs(r.y) * t
                        , t = (h && (r = (i = Math.max(i, r * h)) / h),
                        a[e]);
                    d instanceof Rs ? (!h && 0 !== t && 2 !== t || (d.setWidth(i),
                        c.setWidth(i)),
                    !h && 1 !== t && 2 !== t || (d.setHeight(r),
                        c.setHeight(r))) : (!h && 0 !== t && 2 !== t || (n.markerWidth = i),
                    !h && 1 !== t && 2 !== t || (n.markerHeight = r),
                        d.setSymbol(n),
                        c.setSymbol(n))
                }, function() {
                    u._update(e())
                }),
                this._addListener([g, "zoomend", function() {
                    this._refresh()
                }
                ])) : console && console.warn("A marker can't be resized with symbol:", d.getSymbol())
        }
        ,
        k.createCircleEditor = function() {
            var t = this
                , n = this._geometry
                , r = this._shadow
                , o = this.getMap();
            this._history || this._recordHistory([["setCoordinates", r.getCoordinates().toArray()], ["setRadius", r.getRadius()]]),
                this._createResizeHandles(null, function(t) {
                    var e = n.getCenter()
                        , t = o.viewPointToCoordinate(t)
                        , i = new Io([[e.x, e.y], [t.x, e.y]])
                        , e = new Io([[e.x, e.y], [e.x, t.y]])
                        , t = Math.max(o.computeGeometryLength(i), o.computeGeometryLength(e));
                    r.setRadius(t),
                        n.setRadius(t)
                }, function() {
                    t._update("setRadius", r.getRadius())
                })
        }
        ,
        k.createEllipseOrRectEditor = function() {
            var f, m = this, _ = [2, 1, 2, 0, 0, 2, 1, 2], y = this._geometry, v = this._shadow, x = (this._history || this._recordHistory(t()),
                this.getMap()), w = this._geometry instanceof hs, C = (this.options.fixAspectRatio && (f = y.getWidth() / y.getHeight()),
                this._createResizeHandles(null, function(t, e) {
                    var i, n, r, o, s, a, h, l, u, c, d = w ? 1 : 2, g = t, p = _[e];
                    w ? (h = C[7 - e],
                        i = x.coordToViewPoint(h.getCoordinates()),
                        r = (n = g.sub(i)).abs(),
                        o = x.pixelToDistance(r.x, 0),
                        s = x.pixelToDistance(0, r.y),
                        c = y.getSize(),
                        a = C[0].getCoordinates(),
                        t = x.viewPointToCoordinate(t),
                        h = h.getCoordinates(),
                        l = new Io([[h.x, h.y], [t.x, h.y]]),
                        u = new Io([[h.x, h.y], [h.x, t.y]]),
                        o = x.computeGeometryLength(l),
                        s = x.computeGeometryLength(u),
                        0 === p ? (f && (r.y = r.x / f,
                            c.height = Math.abs(r.y),
                            s = o / f),
                            g.y = i.y - c.height / 2,
                            t.y = a.y,
                            t.x = 4 === e ? Math.min(t.x, a.x) : Math.min(t.x, h.x)) : (1 === p ? (f && (r.x = r.y * f,
                            c.width = Math.abs(r.x),
                            o = s * f),
                            g.x = i.x - c.width / 2,
                            t.x = a.x) : (f && (s * f < o ? (s = o / f,
                            g.y = i.y + r.x * ht(n.y) / f) : (o = s * f,
                            g.x = i.x + r.y * ht(n.x) * f)),
                            t.x = Math.min(t.x, h.x)),
                            t.y = Math.max(t.y, h.y)),
                        v.setCoordinates(t),
                        m._updateCoordFromShadow(!0)) : (l = y.getCenter(),
                        u = x.viewPointToCoordinate(g),
                        e = new Io([[l.x, l.y], [u.x, l.y]]),
                        c = new Io([[l.x, l.y], [l.x, u.y]]),
                        o = x.computeGeometryLength(e),
                        s = x.computeGeometryLength(c),
                    f && (s = (o = Math.max(o, s * f)) / f)),
                    !f && 0 !== p && 2 !== p || (v.setWidth(o * d),
                        y.setWidth(o * d)),
                    !f && 1 !== p && 2 !== p || (v.setHeight(s * d),
                        y.setHeight(s * d))
                }, function() {
                    m._update(t())
                }));
            function t() {
                return [["setCoordinates", v.getCoordinates().toArray()], ["setWidth", v.getWidth()], ["setHeight", v.getHeight()]]
            }
        }
        ,
        k.createPolygonEditor = function() {
            var r = this.getMap()
                , s = this._shadow
                , a = this
                , h = r.getProjection()
                , n = (this._history || this._recordHistory("setCoordinates", M.toNumberArrays(s.getCoordinates())),
                s instanceof S ? 3 : 2)
                , o = "maptalks--editor-refresh-fn"
                , l = "maptalks--editor-vertex-index"
                , u = {
                0: []
            }
                , c = {
                0: []
            };
            function d(t) {
                return void 0 === t && (t = 0),
                    s instanceof S ? (t = s.getCoordinates()[t] || []).slice(0, t.length - 1) : s.getCoordinates()
            }
            function g(t) {
                return 0 === (t = void 0 === t ? 0 : t) ? s._getPrjCoordinates() : s._getPrjHoles()[t - 1]
            }
            function p() {
                for (var t in u) {
                    for (var e = u[t].length - 1; 0 <= e; e--)
                        u[t][e][l] = e;
                    for (var i = c[t].length - 1; 0 <= i; i--)
                        c[t][i][l] = i
                }
                a._updateCoordFromShadow()
            }
            function f(t) {
                var t = t.target
                    , e = t[l]
                    , t = P(t._ringIndex) ? t._ringIndex : 0
                    , i = g(t);
                i.length <= n || (i.splice(e, 1),
                    0 < t ? s._prjHoles[t - 1] = i : s._setPrjCoordinates(i),
                    s._updateCache(),
                    u[t].splice(e, 1)[0].remove(),
                e < c[t].length && c[t].splice(e, 1)[0].remove(),
                    i = 0 === e ? c[t].length - 1 : e - 1,
                    c[t].splice(i, 1)[0].remove(),
                    c[t].splice(i, 0, y.call(a, i, t)),
                    p(),
                    a._refresh())
            }
            function m(t, e, i) {
                var n = g(i = void 0 === i ? 0 : i)
                    , t = r._viewPointToPrj(t)
                    , n = n[e];
                n.x = t.x,
                    n.y = t.y,
                    s._updateCache(),
                    s.onShapeChanged(),
                    a._updateCoordFromShadow(!0),
                    n = 0 === e ? c[i].length - 1 : e - 1,
                c[i][e] && c[i][e][o](),
                c[i][n] && c[i][n][o]()
            }
            function _(t, e) {
                var i = d(e = void 0 === e ? 0 : e)[t]
                    , n = a.createHandle(i, {
                    symbol: a.options.vertexHandleSymbol,
                    cursor: "pointer",
                    axis: null,
                    onMove: function(t) {
                        m(t, n[l], e)
                    },
                    onRefresh: function() {
                        i = d(e)[n[l]],
                            n.setCoordinates(i)
                    },
                    onUp: function() {
                        a._refresh(),
                            a._updateCoordFromShadow()
                    },
                    onDown: function(t, e) {
                        e && e.domEvent && e.domEvent.button
                    }
                });
                return n[l] = t,
                    n._ringIndex = e,
                    n.on(a.options.removeVertexOn, f),
                    n
            }
            function y(t, r) {
                var i = d(r = void 0 === r ? 0 : r)
                    , e = t + 1 >= i.length ? i[0] : i[t + 1]
                    , e = i[t].add(e).multi(.5)
                    , o = a.createHandle(e, {
                    symbol: a.options.newVertexHandleSymbol,
                    cursor: "pointer",
                    axis: null,
                    onDown: function(t, e) {
                        var i, n;
                        e && e.domEvent && 2 === e.domEvent.button || (e = g(r),
                            i = o[l],
                            n = h.project(o.getCoordinates()),
                            e.splice(i + 1, 0, n),
                            0 < r ? s._prjHoles[r - 1] = e : s._setPrjCoordinates(e),
                            s._updateCache(),
                            delete (n = o.getSymbol()).opacity,
                            o.setSymbol(n),
                            c[r].splice(i, 0, y.call(a, i, r), y.call(a, i + 1, r)))
                    },
                    onMove: function(t) {
                        m(t, o[l] + 1, r)
                    },
                    onUp: function(t) {
                        t && t.domEvent && 2 === t.domEvent.button || (t = o[l],
                            st(o, c[r]),
                            o.remove(),
                            u[r].splice(t + 1, 0, _.call(a, t + 1, r)),
                            p(),
                            a._updateCoordFromShadow(),
                            a._refresh())
                    },
                    onRefresh: function() {
                        i = d(r);
                        var t = o[l]
                            , e = t === i.length - 1 ? 0 : t + 1
                            , t = i[t].add(i[e]).multi(.5);
                        o.setCoordinates(t)
                    }
                });
                return o[l] = t,
                    o
            }
            if (s instanceof S)
                for (var t = s.getHoles().length + 1, e = 0; e < t; e++) {
                    u[e] = [],
                        c[e] = [];
                    for (var i = d(e), v = 0, x = i.length; v < x; v++)
                        u[e].push(_.call(this, v, e)),
                        v < x - 1 && c[e].push(y.call(this, v, e));
                    c[e].push(y.call(this, i.length - 1, e))
                }
            else
                for (var w = 0, C = d(0).length; w < C; w++)
                    u[0].push(_.call(this, w, 0)),
                    w < C - 1 && c[0].push(y.call(this, w, 0));
            this._addRefreshHook(function() {
                for (var t in c)
                    for (var e = c[t].length - 1; 0 <= e; e--)
                        c[t][e][o](t);
                for (var i in u)
                    for (var n = u[i].length - 1; 0 <= n; n--)
                        u[i][n][o](i)
            })
        }
        ,
        k._refresh = function() {
            if (this._refreshHooks)
                for (var t = this._refreshHooks.length - 1; 0 <= t; t--)
                    this._refreshHooks[t].call(this)
        }
        ,
        k._hideContext = function() {
            this._geometry && (this._geometry.closeMenu(),
                this._geometry.closeInfoWindow())
        }
        ,
        k._addListener = function(t) {
            this._eventListeners || (this._eventListeners = []),
                this._eventListeners.push(t),
                t[0].on(t[1], t[2], this)
        }
        ,
        k._clearAllListeners = function() {
            if (this._eventListeners && 0 < this._eventListeners.length) {
                for (var t = this._eventListeners.length - 1; 0 <= t; t--) {
                    var e = this._eventListeners[t];
                    e[0].off(e[1], e[2], this)
                }
                this._eventListeners = []
            }
        }
        ,
        k._addRefreshHook = function(t) {
            t && (this._refreshHooks || (this._refreshHooks = []),
                this._refreshHooks.push(t))
        }
        ,
        k._update = function(t) {
            for (var e = arguments.length, i = new Array(1 < e ? e - 1 : 0), n = 1; n < e; n++)
                i[n - 1] = arguments[n];
            this._exeHistory([t, i]),
                this._recordHistory.apply(this, [t].concat(i))
        }
        ,
        k._updateCoordFromShadow = function(t) {
            var e, i, n;
            this._shadow && (e = this._shadow.getCoordinates(),
                i = this._geometry,
                n = this._updating,
                this._updating = !0,
                i.setCoordinates(e),
            t || this._recordHistory("setCoordinates", M.toNumberArrays(i.getCoordinates())),
                this._updating = n)
        }
        ,
        k._recordHistory = function(t) {
            this._history || (this._history = [],
                this._historyPointer = 0);
            for (var e = arguments.length, i = new Array(1 < e ? e - 1 : 0), n = 1; n < e; n++)
                i[n - 1] = arguments[n];
            if (this._history.length) {
                var r = this._history[this._history.length - 1];
                if (r[0] === t && JSON.stringify(r[1]) === JSON.stringify(i))
                    return
            }
            this._historyPointer < this._history.length - 1 && this._history.splice(this._historyPointer + 1),
                this._history.push([t, i]),
                this._historyPointer = this._history.length - 1,
                this._geometry.fire("editrecord")
        }
        ,
        k.cancel = function() {
            if (!this._history || 0 === this._historyPointer)
                return this;
            this._historyPointer = 0;
            var t = this._history[0];
            return this._exeAndReset(t),
                this
        }
        ,
        k.undo = function() {
            if (!this._history || 0 === this._historyPointer)
                return this;
            var t = this._history[--this._historyPointer];
            return this._exeAndReset(t),
                this
        }
        ,
        k.redo = function() {
            if (!this._history || this._historyPointer === this._history.length - 1)
                return this;
            var t = this._history[++this._historyPointer];
            return this._exeAndReset(t),
                this
        }
        ,
        k._exeAndReset = function(t) {
            var e;
            this._updating || (this._exeHistory(t),
                t = this._history,
                e = this._historyPointer,
                this.stop(),
                this._history = t,
                this._historyPointer = e,
                this.start())
        }
        ,
        k._exeHistory = function(t) {
            var e, i, n = this;
            Array.isArray(t) && (e = this._updating,
                this._updating = !0,
                i = this._geometry,
                Array.isArray(t[0]) ? t[0].forEach(function(t) {
                    var e = t[0]
                        , t = t.slice(1);
                    n._shadow[e].apply(n._shadow, t),
                        i[e].apply(i, t)
                }) : (this._shadow[t[0]].apply(this._shadow, t[1]),
                    i[t[0]].apply(i, t[1])),
                this._updating = e)
        }
        ,
        pu);
    function pu(t, e) {
        e = du.call(this, e) || this;
        return e._geometry = t,
            e._geometry ? e : Ee(e)
    }
    gu.mergeOptions(E);
    u.include({
        startEditText: function() {
            return this.getMap() && (this.hide(),
                this.endEditText(),
                this._prepareEditor(),
                this._fireEvent("edittextstart")),
                this
        },
        endEditText: function() {
            var t;
            return this._textEditor && (t = (t = this._textEditor.innerHTML).replace(/<p>/gi, "").replace(/<\/p>/gi, "<br/>"),
                this._textEditor.innerHTML = t,
                t = this._textEditor.innerText.replace(/[\r\n]+$/gi, ""),
                this.setContent(t),
                mi(this._textEditor, "mousedown dblclick", ii),
                this.getMap().off("mousedown", this.endEditText, this),
                this._editUIMarker.remove(),
                delete this._editUIMarker,
                this._textEditor.onkeyup = null,
                delete this._textEditor,
                this.show(),
                this._fireEvent("edittextend")),
                this
        },
        isEditingText: function() {
            return !!this._textEditor
        },
        getTextEditor: function() {
            return this._editUIMarker
        },
        _prepareEditor: function() {
            var t = this.getMap()
                , e = this._createEditor()
                , i = (this._textEditor = e,
                t.on("mousedown", this.endEditText, this),
                this._getEditorOffset());
            this._editUIMarker = new Qa(this.getCoordinates(),{
                animation: null,
                content: e,
                dx: i.dx,
                dy: i.dy
            }).addTo(t),
                this._setCursorToLast(this._textEditor)
        },
        _getEditorOffset: function() {
            var t = this._getInternalSymbol() || {}
                , e = 0
                , i = 0
                , n = t.textHorizontalAlignment
                , i = "middle" === n || V(n) ? (e = (t.textDx || 0) - 2,
            (t.textDy || 0) - 2) : (e = (t.markerDx || 0) - 2,
            (t.markerDy || 0) - 2);
            return {
                dx: e,
                dy: i
            }
        },
        _createEditor: function() {
            var t = this.getContent()
                , e = this.getSize()
                , i = this._getInternalSymbol() || {}
                , n = e.width
                , r = i.textFill || "#000000"
                , o = i.textSize || 12
                , e = e.height
                , s = i.markerLineColor || "#000"
                , a = i.markerFill || "#3398CC"
                , i = i.textLineSpacing || 0
                , h = f("div");
            return h.contentEditable = !0,
                h.style.cssText = "background:" + a + "; border:1px solid " + s + ";\n            color:" + r + ";font-size:" + o + "px;width:" + (n - 2) + "px;height:" + (e - 2) + "px;margin: auto;\n            line-height:" + (o + i) + "px;outline: 0; padding:0; margin:0;word-wrap: break-word;\n            overflow: hidden;-webkit-user-modify: read-write-plaintext-only;",
                h.innerText = t,
                _(h, "mousedown dblclick", ii),
                h.onkeyup = function(t) {
                    var e = h.style.height || 0;
                    13 === t.keyCode && (h.style.height = parseInt(e) + o / 2 + "px")
                }
                ,
                h
        },
        _setCursorToLast: function(t) {
            var e;
            window.getSelection ? (t.focus(),
                (e = window.getSelection()).selectAllChildren(t),
                e.collapseToEnd()) : document.selection && ((e = document.selection.createRange()).moveToElementText(t),
                e.collapse(!1),
                e.select())
        }
    }),
        y.include({
            animate: function(t, e, s) {
                var a, i, h = this, l = (this._animPlayer && this._animPlayer.finish(),
                p(e) && (s = e),
                    e = e || {},
                    this.getMap()), u = this._getProjection(), c = this.getSymbol() || {}, t = this._prepareAnimationStyles(t), d = e.focus, g = (delete this._animationStarted,
                l && (i = l._getRenderer(),
                        e.framer = function(t) {
                            i.callInNextFrame(t)
                        }
                ),
                    Po.animate(t, e, function(t) {
                        if (l && l.isRemoved())
                            g.finish();
                        else {
                            l && !h._animationStarted && d && l.onMoveStart();
                            var e, i, n = t.styles;
                            for (e in n)
                                "symbol" !== e && "translate" !== e && n.hasOwnProperty(e) && (i = "set" + e[0].toUpperCase() + e.slice(1),
                                    h[i](n[e]));
                            var r, o = n.translate, o = (o && (r = o,
                            a && (r = o.sub(a)),
                                a = o,
                                h.translate(r)),
                                n.symbol);
                            o && h.setSymbol(re(c, o)),
                            l && d && (r = u.project(h.getCenter()),
                                l._setPrjCenter(r),
                                o = l._parseEventFromCoord(u.unproject(r)),
                                "running" !== g.playState ? l.onMoveEnd(o) : l.onMoving(o)),
                                h._fireAnimateEvent(g.playState),
                            s && s(t)
                        }
                    }, this));
                return this._animPlayer = g,
                    this._animPlayer.play()
            },
            _prepareAnimationStyles: function(t) {
                var e, i = this._getInternalSymbol(), n = {};
                for (e in t)
                    if (t.hasOwnProperty(e)) {
                        var r = t[e];
                        if ("translate" !== e && "symbol" !== e) {
                            var o = this["get" + e[0].toUpperCase() + e.substring(1)]();
                            n[e] = [o, r]
                        } else if ("symbol" === e) {
                            var s = void 0;
                            if (Array.isArray(t.symbol)) {
                                if (!Array.isArray(i))
                                    throw new Error("geometry'symbol isn't a composite symbol, while the symbol in styles is.");
                                for (var s = [], a = t.symbol, h = 0; h < a.length; h++)
                                    if (a[h]) {
                                        var l, u = {};
                                        for (l in a[h])
                                            a[h].hasOwnProperty(l) && (u[l] = [i[h][l], a[h][l]]);
                                        s.push(u)
                                    } else
                                        s.push(null)
                            } else {
                                if (Array.isArray(i))
                                    throw new Error("geometry'symbol is a composite symbol, while the symbol in styles isn't.");
                                for (var c in s = {},
                                    r)
                                    r.hasOwnProperty(c) && (s[c] = [i[c], r[c]])
                            }
                            n.symbol = s
                        } else
                            "translate" === e && (n.translate = new M(r))
                    }
                return n
            },
            _fireAnimateEvent: function(t) {
                "finished" === t ? (delete this._animationStarted,
                    this._fireEvent("animateend")) : "running" === t && (this._animationStarted ? this._fireEvent("animating") : (this._fireEvent("animatestart"),
                    this._animationStarted = !0))
            }
        });
    var fu, mu = D + "_drag_stage", _u = c.touch ? "touchstart mousedown" : "mousedown", E = (s(yu, fu = ki),
        (k = yu.prototype).addHooks = function() {
            this.target.on(_u, this._startDrag, this)
        }
        ,
        k.removeHooks = function() {
            this._endDrag(),
                this.target.off(_u, this._startDrag, this),
                delete this.container
        }
        ,
        k._prepareDragHandler = function() {
            this._dragHandler = new Zi(this.container),
                this._dragHandler.on("dragging", this._dragging, this).on("mouseup", this._endDrag, this).enable()
        }
        ,
        k._prepareShadow = function() {
            var t, i, n = this, e = this.target, r = (this._prepareDragStageLayer(),
            this._shadow && this._shadow.remove(),
                this._shadow = e.copy());
            r.getGeometries ? (t = r.getGeometries(),
                i = e.getGeometries(),
                t.forEach(function(t, e) {
                    n._updateShadowSymbol(t, i[e])
                })) : this._updateShadowSymbol(r, e),
                r.setId(null),
                this._prepareShadowConnectors()
        }
        ,
        k._updateShadowSymbol = function(t, e) {
            t.setSymbol(e._getInternalSymbol()),
            e.options.dragShadow && (e = ne(t._getInternalSymbol(), .5),
                t.setSymbol(e))
        }
        ,
        k._prepareShadowConnectors = function() {
            var t = this.target
                , e = this._shadow
                , i = this._dragStageLayer._getRenderer().resources
                , n = [];
            if (zs._hasConnectors(t))
                for (var r = zs._getConnectors(t), o = 0, s = r.length; o < s; o++) {
                    var a = r[o]
                        , h = a.config()
                        , l = a._getInternalSymbol()
                        , l = (h.symbol = ne(l, .5),
                        void 0)
                        , l = a.getConnectSource() === t ? new a.constructor(e,a.getConnectTarget(),h) : new a.constructor(a.getConnectSource(),e,h);
                    n.push(l),
                    a.getLayer() && a.getLayer()._getRenderer() && i.merge(a.getLayer()._getRenderer().resources)
                }
            (this._shadowConnectors = n).push(e),
                this._dragStageLayer.bringToFront().addGeometry(n)
        }
        ,
        k._onTargetUpdated = function() {
            this._shadow && this._shadow.setSymbol(this.target._getSymbol())
        }
        ,
        k._prepareDragStageLayer = function() {
            var t = this.target.getMap()
                , e = this.target.getLayer()
                , t = (this._dragStageLayer = t.getLayer(mu),
            this._dragStageLayer || (this._dragStageLayer = new Us(mu,{
                enableAltitude: e.options.enableAltitude,
                altitudeProperty: e.options.altitudeProperty
            }),
                t.addLayer(this._dragStageLayer)),
                new Cn);
            t.merge(e._getRenderer().resources),
                this._dragStageLayer._getRenderer().resources = t
        }
        ,
        k._startDrag = function(t) {
            var e, i = this.target.getMap();
            !i || this.target._getParent() || this.isDragging() || (e = t.domEvent).touches && 1 < e.touches.length || 2 === e.button || (this.container = i._panels.mapWrapper || i._containerDOM,
                this.target.on("click", this._endDrag, this),
                this._lastCoord = this._correctCoord(t.coordinate),
                this._lastPoint = t.containerPoint,
                this._prepareDragHandler(),
                this._dragHandler.onMouseDown(t.domEvent),
                _(this.container, "mouseleave", this._endDrag, this),
                this._startParam = t,
                this._moved = !1)
        }
        ,
        k._dragging = function(t) {
            var e, i, n, r, o = this.target, t = o.getMap()._parseEvent(t.domEvent), s = t.domEvent;
            if (!(s.touches && 1 < s.touches.length)) {
                if (!this._moved)
                    return this._moved = !0,
                        o.on("symbolchange", this._onTargetUpdated, this),
                        this._isDragging = !0,
                        this._prepareShadow(),
                    o.options.dragShadow || o.hide(),
                        this._shadow._fireEvent("dragstart", t),
                        this.target._fireEvent("dragstart", this._startParam || t),
                        void delete this._startParam;
                this._shadow && (s = this._shadow.options.dragOnAxis,
                    e = this._correctCoord(t.coordinate),
                    i = t.containerPoint,
                    this._lastPoint = this._lastPoint || i,
                    this._lastCoord = this._lastCoord || e,
                    n = i.sub(this._lastPoint),
                    r = e.sub(this._lastCoord),
                    "x" === s ? n.y = r.y = 0 : "y" === s && (n.x = r.x = 0),
                    this._lastPoint = i,
                    this._lastCoord = e,
                    this._shadow.translate(r),
                o.options.dragShadow || o.translate(r),
                    t.coordOffset = r,
                    t.pointOffset = n,
                    this._shadow._fireEvent("dragging", t),
                    o._fireEvent("dragging", t))
            }
        }
        ,
        k._endDrag = function(t) {
            var e, i;
            this._dragHandler && (this._dragHandler.disable(),
                delete this._dragHandler),
            this.container && mi(this.container, "mouseleave", this._endDrag, this),
            this.target && ((e = this.target).off("click", this._endDrag, this),
                e.off("symbolchange", this._onTargetUpdated, this),
                delete this._lastCoord,
                delete this._lastPoint,
                this._isDragging = !1,
                i = e.getMap(),
            this.enabled() && i && (i = i._parseEvent(t ? t.domEvent : null),
                this._updateTargetAndRemoveShadow(i),
            this._moved && e._fireEvent("dragend", i)))
        }
        ,
        k.isDragging = function() {
            return !!this._isDragging
        }
        ,
        k._updateTargetAndRemoveShadow = function(t) {
            var i, n, e = this.target, r = e.getMap(), o = (e.options.dragShadow || e.show(),
                this._shadow);
            o && (e.options.dragShadow && (e.getGeometries ? (i = o.getGeometries(),
                n = e.getGeometries(),
                i.forEach(function(t, e) {
                    n[e].setCoordinates(i[e].getCoordinates())
                })) : e.setCoordinates(o.getCoordinates())),
                o._fireEvent("dragend", t),
                o.remove(),
                delete this._shadow),
            this._shadowConnectors && (r.getLayer(mu).removeGeometry(this._shadowConnectors),
                delete this._shadowConnectors),
            this._dragStageLayer && this._dragStageLayer.remove()
        }
        ,
        k._correctCoord = function(t) {
            var e = this.target.getMap();
            if (!e.getPitch())
                return t;
            var i = this.target._getPainter();
            if (!i.getMinAltitude())
                return t;
            i = (i.getMinAltitude() + i.getMaxAltitude()) / 2;
            return e.locateByPoint(t, 0, -i)
        }
        ,
        yu);
    function yu(t) {
        return fu.call(this, t) || this
    }
    y.mergeOptions({
        draggable: !1,
        dragShadow: !0,
        dragOnAxis: null
    }),
        y.addInitHook("addHandler", "draggable", E),
        y.include({
            isDragging: function() {
                return this._getParent() ? this._getParent().isDragging() : !!this.draggable && this.draggable.isDragging()
            }
        }),
        y.include({
            startEdit: function(t) {
                return this.getMap() && this.options.editable && (this.endEdit(),
                    this._editor = new gu(this,t),
                    this._editor.start(),
                    this.fire("editstart")),
                    this
            },
            endEdit: function() {
                return this._editor && (this._editor.stop(),
                    delete this._editor,
                    this.fire("editend")),
                    this
            },
            redoEdit: function() {
                return this.isEditing() && (this._editor.redo(),
                    this.fire("redoedit")),
                    this
            },
            undoEdit: function() {
                return this.isEditing() && (this._editor.undo(),
                    this.fire("undoedit")),
                    this
            },
            cancelEdit: function() {
                return this.isEditing() && (this._editor.cancel(),
                    this.fire("canceledit")),
                    this
            },
            isEditing: function() {
                return !!this._editor && this._editor.isEditing()
            }
        }),
        y.include({
            _onEvent: function(t, e) {
                this.getMap() && ("contextmenu" === (e = e || this._getEventTypeToFire(t)) && this.listens("contextmenu") && (ii(t),
                    ei(t)),
                    t = this._getEventParams(t),
                    this._fireEvent(e, t))
            },
            _getEventTypeToFire: function(t) {
                return t.type
            },
            _getEventParams: function(t) {
                var e = this.getMap()
                    , i = {
                    domEvent: t
                }
                    , t = t.touches && 0 < t.touches.length ? t.touches[0] : t.changedTouches && 0 < t.changedTouches.length ? t.changedTouches[0] : t;
                return t && (t = si(t, e._containerDOM),
                    i.coordinate = e.containerPointToCoordinate(t),
                    i.containerPoint = t,
                    i.viewPoint = e.containerPointToViewPoint(t),
                    i.pont2d = e._containerPointToPoint(t)),
                    i
            }
        }),
        y.include({
            setInfoWindow: function(t) {
                return this.removeInfoWindow(),
                    t instanceof rh ? (this._infoWindow = t,
                        this._infoWinOptions = m({}, this._infoWindow.options),
                        this._infoWindow.addTo(this)) : (this._infoWinOptions = m({}, t),
                        this._infoWindow ? this._infoWindow.setOptions(t) : this.getMap() && this._bindInfoWindow(this._infoWinOptions)),
                    this
            },
            getInfoWindow: function() {
                return this._infoWindow || null
            },
            openInfoWindow: function(t) {
                return this.getMap() && (t = t || this.getCenter(),
                    this._infoWindow ? this._infoWindow.show(t) : this._infoWinOptions && this.getMap() && (this._bindInfoWindow(this._infoWinOptions),
                        this._infoWindow.show(t))),
                    this
            },
            closeInfoWindow: function() {
                return this._infoWindow && this._infoWindow.hide(),
                    this
            },
            removeInfoWindow: function() {
                return this._unbindInfoWindow(),
                    delete this._infoWinOptions,
                    delete this._infoWindow,
                    this
            },
            _bindInfoWindow: function(t) {
                return this._infoWindow = new rh(t),
                    this._infoWindow.addTo(this),
                    this
            },
            _unbindInfoWindow: function() {
                return this._infoWindow && (this.closeInfoWindow(),
                    this._infoWindow.remove(),
                    delete this._infoWindow),
                    this
            }
        });
    (k = xu.prototype).reset = function() {
        for (var t in this.data)
            this.onRemove(this.data[t]);
        return this.data = {},
            this.order = [],
            this
    }
        ,
        k.clear = function() {
            this.reset(),
                delete this.onRemove
        }
        ,
        k.add = function(t, e) {
            return this.has(t) ? (this.order.splice(this.order.indexOf(t), 1),
                this.data[t] = e,
                this.order.push(t)) : (this.data[t] = e,
                this.order.push(t),
            this.order.length > this.max && ((e = this.getAndRemove(this.order[0])) && this.onRemove(e))),
                this
        }
        ,
        k.has = function(t) {
            return t in this.data
        }
        ,
        k.keys = function() {
            return this.order
        }
        ,
        k.getAndRemove = function(t) {
            if (!this.has(t))
                return null;
            var e = this.data[t];
            return delete this.data[t],
                this.order.splice(this.order.indexOf(t), 1),
                e
        }
        ,
        k.get = function(t) {
            return this.has(t) ? this.data[t] : null
        }
        ,
        k.remove = function(t) {
            if (!this.has(t))
                return this;
            var e = this.data[t];
            return delete this.data[t],
                this.onRemove(e),
                this.order.splice(this.order.indexOf(t), 1),
                this
        }
        ,
        k.setMaxSize = function(t) {
            for (this.max = t; this.order.length > this.max; ) {
                var e = this.getAndRemove(this.order[0]);
                e && this.onRemove(e)
            }
            return this
        }
    ;
    var vu = xu;
    function xu(t, e) {
        this.max = t,
            this.onRemove = e,
            this.reset()
    }
    var wu, Cu = new R(0,0), Pu = new R(0,0), bu = new R(0,0), k = (s(Mu, wu = vn),
        (E = Mu.prototype).getCurrentTileZoom = function() {
            return this._tileZoom
        }
        ,
        E.draw = function() {
            var t = this.getMap();
            if (this.isDrawable()) {
                var e = this.prepareCanvas();
                if (e && !e.intersects(this.canvasExtent2D))
                    this.completeRender();
                else {
                    var i = this.layer.getTiles().tileGrids;
                    if (i && i.length) {
                        var n = 0
                            , r = !1
                            , o = {}
                            , s = []
                            , a = []
                            , h = {}
                            , l = []
                            , u = {}
                            , c = []
                            , d = {}
                            , g = {}
                            , p = this._markTiles()
                            , f = this._getLoadLimit()
                            , m = i.length;
                        this._tileZoom = i[0].zoom,
                            this._tileOffset = i[0].offset;
                        for (var _ = 0; _ < m; _++)
                            for (var y = i[_], v = y.tiles, x = this._generatePlaceHolder(y.zoom), w = 0, C = v.length; w < C; w++) {
                                var P, b = v[w], M = b.id, S = !1;
                                this._isLoadingTile(M) ? (S = r = !0,
                                    this.tilesLoading[M].current = !0) : (P = this._getCachedTile(M)) ? (P.image && this.getTileOpacity(P.image) < 1 && (S = r = !0),
                                    s.push(P)) : (S = r = !0,
                                f && n + p[0] > f || t.isInteracting() && !t.isMoving() && !t.isRotating() || (n++,
                                    g[M + "@" + b.point.toArray().join()] = b)),
                                !S || o[M] || (o[M] = 1,
                                x && !d[M] && (b.cache = !1,
                                    c.push({
                                        image: x,
                                        info: b
                                    }),
                                    d[M] = 1),
                                    (P = this._findParentTile(b)) ? void 0 === h[S = P.info.id] && (h[S] = a.length,
                                        a.push(P)) : a.length || (M = this._findChildTiles(b)).length && M.forEach(function(t) {
                                        u[t.info.id] || (l.push(t),
                                            u[t.info.id] = 1)
                                    }))
                            }
                        a.length && (l.length = 0,
                            this._childTiles.length = 0),
                            this._drawTiles(s, a, l, c),
                            n ? this.loadTileQueue(g) : r || (t.isAnimating() || !this._parentTiles.length && !this._childTiles.length || (this._parentTiles = [],
                                this._childTiles = [],
                                this.setToRedraw()),
                                this.completeRender()),
                            this._retireTiles()
                    } else
                        this.completeRender()
                }
            }
        }
        ,
        E.isTileCachedOrLoading = function(t) {
            return this.tilesLoading[t] || this.tilesInView[t] || this.tileCache.get(t)
        }
        ,
        E._drawTiles = function(t, e, i, n) {
            var r = this
                , e = (e.length && (e.sort(function(t, e) {
                return Math.abs(e.info.z - r._tileZoom) - Math.abs(t.info.z - r._tileZoom)
            }),
                this._parentTiles = e),
            i.length && (this._childTiles = i),
                {
                    tiles: t,
                    parentTiles: this._parentTiles,
                    childTiles: this._childTiles
                })
                , i = (this.onDrawTileStart(e),
                this._parentTiles.forEach(function(t) {
                    return r._drawTileAndCache(t)
                }),
                this._childTiles.forEach(function(t) {
                    return r._drawTileOffset(t.info, t.image)
                }),
                n.forEach(function(t) {
                    return r._drawTileOffset(t.info, t.image)
                }),
                this.layer)
                , n = this.getMap();
            if (!i.options.cascadeTiles || n.getPitch() <= n.options.cascadePitches[0])
                t.forEach(function(t) {
                    return r._drawTileAndCache(t)
                });
            else {
                this.writeZoomStencil();
                for (var o = !1, s = 0, a = t.length; s < a; s++)
                    t[s].info.z !== this._tileZoom ? o ? this.resumeZoomStencilTest() : (this.startZoomStencilTest(),
                        o = !0) : o && this.pauseZoomStencilTest(),
                        this._drawTileAndCache(t[s]);
                this.endZoomStencilTest()
            }
            this.onDrawTileEnd(e)
        }
        ,
        E.writeZoomStencil = function() {}
        ,
        E.startZoomStencilTest = function() {}
        ,
        E.endZoomStencilTest = function() {}
        ,
        E.pauseZoomStencilTest = function() {}
        ,
        E.resumeZoomStencilTest = function() {}
        ,
        E.onDrawTileStart = function() {}
        ,
        E.onDrawTileEnd = function() {}
        ,
        E._drawTileOffset = function(t, e) {
            var i, n;
            e && ((i = this._tileOffset)[0] || i[1] ? (n = (n = this.getMap())._getResolution(this._tileZoom) / n._getResolution(t.z),
                i[0] *= n,
                i[1] *= n,
                t.point._sub(i),
                t.extent2d._sub(i),
                this.drawTile(t, e),
                t.point._add(i),
                t.extent2d._add(i),
                i[0] /= n,
                i[1] /= n) : this.drawTile(t, e))
        }
        ,
        E._drawTileAndCache = function(t) {
            t.current = !0,
                this.tilesInView[t.info.id] = t,
                this._drawTileOffset(t.info, t.image),
                this.tileCache.add(t.info.id, t)
        }
        ,
        E.drawOnInteracting = function() {
            this.draw()
        }
        ,
        E.needToRedraw = function() {
            var t = this.getMap();
            return t.getPitch() ? wu.prototype.needToRedraw.call(this) : !(!t.isRotating() && !t.isZooming()) || (t.isMoving() ? !!this.layer.options.forceRenderOnMoving : wu.prototype.needToRedraw.call(this))
        }
        ,
        E.hitDetect = function() {
            return !1
        }
        ,
        E._getLoadLimit = function() {
            return this.getMap().isInteracting() ? this.layer.options.loadingLimitOnInteracting : 0
        }
        ,
        E.isDrawable = function() {
            return !this.getMap().getPitch() || (console && console.warn("TileLayer with canvas renderer can't be pitched, use gl renderer ('renderer' : 'gl') instead."),
                this.clear(),
                !1)
        }
        ,
        E.clear = function() {
            this._retireTiles(!0),
                this.tileCache.reset(),
                this.tilesInView = {},
                this.tilesLoading = {},
                this._parentTiles = [],
                this._childTiles = [],
                wu.prototype.clear.call(this)
        }
        ,
        E._isLoadingTile = function(t) {
            return !!this.tilesLoading[t]
        }
        ,
        E.clipCanvas = function(t) {
            return wu.prototype.clipCanvas.call(this, t)
        }
        ,
        E._clipByPitch = function(t) {
            var e = this.getMap();
            if (e.getPitch() <= e.options.maxVisualPitch)
                return !1;
            if (!this.layer.options.clipByPitch)
                return !1;
            var i = e.getContainerExtent()
                , e = e.getDevicePixelRatio();
            return t.save(),
                t.strokeStyle = "rgba(0, 0, 0, 0)",
                t.beginPath(),
                t.rect(0, Math.ceil(i.ymin) * e, Math.ceil(i.getWidth()) * e, Math.ceil(i.getHeight()) * e),
                t.stroke(),
                t.clip(),
                !0
        }
        ,
        E.loadTileQueue = function(t) {
            for (var e in t) {
                var i;
                t.hasOwnProperty(e) && (e = t[e],
                void 0 === (i = this.loadTile(e)).loadTime && (this.tilesLoading[e.id] = {
                    image: i,
                    current: !0,
                    info: e
                }))
            }
        }
        ,
        E.loadTile = function(t) {
            var e = this.layer.getTileSize()
                , i = new Image;
            return i.width = e.width,
                i.height = e.height,
                i.onload = this.onTileLoad.bind(this, i, t),
                i.onerror = this.onTileError.bind(this, i, t),
                this.loadTileImage(i, t.url),
                i
        }
        ,
        E.loadTileImage = function(t, e) {
            var i = this.layer.options.crossOrigin;
            return V(i) || (t.crossOrigin = i),
                et(t, [e])
        }
        ,
        E.abortTileLoading = function(t) {
            t && (t.onload = Su,
                t.onerror = Su,
                t.src = wt)
        }
        ,
        E.onTileLoad = function(t, e) {
            var i, n;
            this.layer && (i = e.id,
            this.tilesInView && (this.layer.fire("tileload", n = {
                tile: e,
                tileImage: t
            }),
                (t = n.tileImage).loadTime = F(),
                delete this.tilesLoading[i],
                this._addTileToCache(e, t),
                this.setToRedraw()))
        }
        ,
        E.onTileError = function(t, e) {
            if (this.layer) {
                if (t.onerrorTick = t.onerrorTick || 0,
                this.layer.options.tileRetryCount > t.onerrorTick)
                    return t.onerrorTick++,
                        void (t.src = e.url);
                t instanceof Image && this.abortTileLoading(t, e),
                    t.loadTime = 0,
                    delete this.tilesLoading[e.id],
                    this._addTileToCache(e, t),
                    this.setToRedraw(),
                    this.layer.fire("tileerror", {
                        tile: e
                    })
            }
        }
        ,
        E.drawTile = function(t, e) {
            var i, n, r, o, s, a, h, l, u, c, d;
            e && this.getMap() && (h = t.point,
                d = t.z,
                i = t.id,
                n = this.getMap(),
                t = t.size,
                c = n.getZoom(),
                r = this.context,
                h = n._pointToContainerPoint(h, d, 0, Cu),
                o = (u = n.getBearing()) || c !== d,
                a = this.getTileOpacity(e),
                s = r.globalAlpha,
            a < 1 && (r.globalAlpha = a,
                this.setToRedraw()),
            o || h._round(),
                a = h.x,
                h = h.y,
                l = t[0],
                t = t[1],
            o && (r.save(),
                r.translate(a, h),
            u && (r.rotate(-u * Math.PI / 180),
                l += .1,
                t += .1),
            c !== d && (u = n._getResolution(d) / n._getResolution(),
                r.scale(u, u)),
                a = h = 0),
                O.image(r, e, a, h, l, t),
            this.layer.options.debug && (c = this.layer.options.debugOutline,
                r.save(),
                r.strokeStyle = c,
                r.fillStyle = c,
                r.strokeWidth = 10,
                r.font = "20px monospace",
                d = new R(a,h),
                O.rectangle(r, d, {
                    width: l,
                    height: t
                }, 1, 0),
                O.fillText(r, this.getDebugInfo(i), d._add(10, 20), c),
                O.drawCross(r, a + l / 2, h + t / 2, 2, c),
                r.restore()),
            o && r.restore(),
            r.globalAlpha !== s && (r.globalAlpha = s),
                this.setCanvasUpdated())
        }
        ,
        E.getDebugInfo = function(t) {
            var t = t.split("_")
                , e = t.length;
            return "x:" + t[e - 2] + ", y:" + t[e - 3] + ", z:" + t[e - 1]
        }
        ,
        E._findChildTiles = function(t) {
            var e = this._getLayerOfTile(t.layer);
            if (!e.options.background)
                return [];
            for (var i = this.getMap(), n = [], r = t.extent2d.getMin(), o = t.extent2d.getMax(), s = e._project(i._pointToPrj(r, t.z, Pu), Pu), a = e._project(i._pointToPrj(o, t.z, bu), bu), h = 1; h < 2; h++)
                this._findChildTilesAt(n, s, a, e, t.z + h);
            return n
        }
        ,
        E._findChildTilesAt = function(t, e, i, n, r) {
            var o = n.options.zoomOffset
                , s = n.getId()
                , a = n.getSpatialReference().getResolution(r + o);
            if (a)
                for (var h, l, e = n._getTileConfig().getTileIndex(e, a), i = n._getTileConfig().getTileIndex(i, a), a = Math.min(e.idx, i.idx), u = Math.max(e.idx, i.idx), c = Math.min(e.idy, i.idy), d = Math.max(e.idy, i.idy), g = a; g < u; g++)
                    for (var p = c; p < d; p++)
                        h = n._getTileId(g, p, r + o, s),
                        this.tileCache.has(h) && (l = this.tileCache.getAndRemove(h),
                            t.push(l),
                            this.tileCache.add(h, l))
        }
        ,
        E._findParentTile = function(t) {
            var e = this.getMap()
                , i = this._getLayerOfTile(t.layer);
            if (!i.options.background)
                return null;
            for (var n = i.getSpatialReference(), r = n.getZoomDirection(), o = i.options.zoomOffset, s = i.options.backgroundZoomDiff, a = t.extent2d.getCenter(), h = i._project(e._pointToPrj(a, t.z)), l = 1; l <= s; l++) {
                var u = t.z - r * l
                    , c = n.getResolution(u + o);
                if (c) {
                    c = i._getTileConfig().getTileIndex(h, c),
                        c = i._getTileId(c.x, c.y, u + o, t.layer);
                    if (this.tileCache.has(c))
                        return u = this.tileCache.getAndRemove(c),
                            this.tileCache.add(c, u),
                            u
                }
            }
            return null
        }
        ,
        E._getLayerOfTile = function(t) {
            return this.layer.getChildLayer ? this.layer.getChildLayer(t) : this.layer
        }
        ,
        E._getCachedTile = function(t) {
            var e, i, n, r = this.tilesInView, o = this.tileCache.getAndRemove(t);
            return o ? (r[t] = o,
            (e = this.tilesLoading) && e[t] && (e[t].current = !1,
                i = (n = e[t]).image,
                n = n.info,
                this.abortTileLoading(i, n),
                console.log("_getCachedTile"),
                delete e[t])) : o = r[t],
                o
        }
        ,
        E._addTileToCache = function(t, e) {
            this.tilesInView[t.id] = {
                image: e,
                current: !0,
                info: t
            }
        }
        ,
        E.getTileOpacity = function(t) {
            return this.layer.options.fadeAnimation && t.loadTime ? Math.min(1, (F() - t.loadTime) / (1e3 / 60 * 10)) : 1
        }
        ,
        E.onRemove = function() {
            this.clear(),
                delete this.tileCache,
                delete this._tilePlaceHolder,
                wu.prototype.onRemove.call(this)
        }
        ,
        E._markTiles = function() {
            var t = 0
                , e = 0;
            if (this.tilesLoading)
                for (var i in this.tilesLoading)
                    this.tilesLoading[i].current = !1,
                        t++;
            if (this.tilesInView)
                for (var n in this.tilesInView)
                    this.tilesInView[n].current = !1,
                        e++;
            return [t, e]
        }
        ,
        E._retireTiles = function(t) {
            for (var e in this.tilesLoading) {
                var i = this.tilesLoading[e];
                !t && i.current || (i.image && this.abortTileLoading(i.image, i.info),
                    this.deleteTile(i),
                    delete this.tilesLoading[e])
            }
            for (var n in this.tilesInView) {
                var r = this.tilesInView[n];
                r.current || (delete this.tilesInView[n],
                this.tileCache.has(n) || this.deleteTile(r))
            }
        }
        ,
        E.deleteTile = function(t) {
            t && t.image && (t.image.onload = null,
                t.image.onerror = null)
        }
        ,
        E._generatePlaceHolder = function(t) {
            var e = this.getMap()
                , i = this.layer.options.placeholder;
            if (!i || e.getPitch())
                return null;
            var n = this.layer.getTileSize()
                , t = e._getResolution(t) / e._getResolution()
                , e = this._tilePlaceHolder = this._tilePlaceHolder || O.createCanvas(1, 1);
            if (e.width = n.width * t,
                e.height = n.height * t,
                p(i))
                i(e);
            else {
                var n = e
                    , r = n.getContext("2d")
                    , o = n.width
                    , s = n.height
                    , a = o / 16
                    , h = s / 16;
                r.beginPath();
                for (var l = 0; l < 16; l++)
                    r.moveTo(0, l * h),
                        r.lineTo(o, l * h),
                        r.moveTo(l * a, 0),
                        r.lineTo(l * a, s);
                r.strokeStyle = "rgba(180, 180, 180, 0.1)",
                    r.lineWidth = 1,
                    r.stroke(),
                    r.beginPath();
                for (var u = [[0, 0], [o, 0], [0, s], [o, s], [0, 0], [0, s], [o, 0], [o, s], [0, s / 2], [o, s / 2], [o / 2, 0], [o / 2, s]], c = 1; c < u.length; c += 2)
                    r.moveTo(u[c - 1][0], u[c - 1][1]),
                        r.lineTo(u[c][0], u[c][1]);
                r.lineWidth = 4,
                    r.stroke()
            }
            return e
        }
        ,
        Mu);
    function Mu(t) {
        var e = wu.call(this, t) || this;
        return e.tilesInView = {},
            e.tilesLoading = {},
            e._parentTiles = [],
            e._childTiles = [],
            e.tileCache = new vu(t.options.maxCacheSize,e.deleteTile.bind(Ee(e))),
            e
    }
    function Su() {
        return !1
    }
    C.registerRenderer("canvas", k);
    s(Eu, Tu = yl(k)),
        (E = Eu.prototype).isDrawable = function() {
            return !0
        }
        ,
        E.needToRedraw = function() {
            var t = this.getMap();
            return !(!this._gl() || t.getPitch() || !t.isZooming() || t.isMoving() || t.isRotating()) || Tu.prototype.needToRedraw.call(this)
        }
        ,
        E.drawTile = function(t, e) {
            var i, n, r, o, s, a, h = this.getMap();
            t && h && e && (h = t._glScale = t._glScale || h.getGLScale(t.z),
                i = t.size[0],
                n = t.size[1],
            !1 !== t.cache && this._bindGLBuffer(e, i, n),
                this._gl() ? (r = (o = t.point).x * h,
                    o = o.y * h,
                    s = this.getTileOpacity(e),
                    a = null,
                this.layer.options.debug && (a = this.getDebugInfo(t.id)),
                    this.drawGLImage(e, r, o, i, n, h, s, a),
                    s < 1 ? this.setToRedraw() : this.setCanvasUpdated()) : Tu.prototype.drawTile.call(this, t, e))
        }
        ,
        E.writeZoomStencil = function() {
            var t = this.gl;
            t.stencilFunc(t.ALWAYS, 1, 255),
                t.stencilOp(t.KEEP, t.KEEP, t.REPLACE)
        }
        ,
        E.startZoomStencilTest = function() {
            var t = this.gl;
            t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
                t.stencilFunc(t.EQUAL, 0, 255)
        }
        ,
        E.endZoomStencilTest = function() {
            this.pauseZoomStencilTest()
        }
        ,
        E.pauseZoomStencilTest = function() {
            var t = this.gl;
            t.stencilFunc(t.ALWAYS, 1, 255)
        }
        ,
        E.resumeZoomStencilTest = function() {
            var t = this.gl;
            t.stencilFunc(t.EQUAL, 0, 255)
        }
        ,
        E._bindGLBuffer = function(t, e, i) {
            t.glBuffer || (t.glBuffer = this.bufferTileData(0, 0, e, i))
        }
        ,
        E.loadTileImage = function(t, e) {
            var i = this.layer.options.crossOrigin;
            t.crossOrigin = null !== i ? i : "",
                t.src = e
        }
        ,
        E.onCanvasCreate = function() {
            this.canvas.gl && this.canvas.gl.wrap || this.createCanvas2()
        }
        ,
        E.createContext = function() {
            Tu.prototype.createContext.call(this),
                this.createGLContext()
        }
        ,
        E.resizeCanvas = function(t) {
            this.canvas && (Tu.prototype.resizeCanvas.call(this, t),
                this.resizeGLCanvas())
        }
        ,
        E.clearCanvas = function() {
            this.canvas && (Tu.prototype.clearCanvas.call(this),
                this.clearGLCanvas())
        }
        ,
        E.getCanvasImage = function() {
            if (!this._gl() || !this.canvas2)
                return Tu.prototype.getCanvasImage.call(this);
            var t = Tu.prototype.getCanvasImage.call(this);
            return t && (t.image = this.canvas2),
                t
        }
        ,
        E._gl = function() {
            if (this.canvas.gl && this.canvas.gl.wrap)
                return !0;
            var t = this.getMap();
            return t && (t.getPitch() || t.getBearing()) || this.layer && !!this.layer.options.fragmentShader
        }
        ,
        E.deleteTile = function(t) {
            Tu.prototype.deleteTile.call(this, t),
            t && t.image && this.disposeImage(t.image),
                delete t.image
        }
        ,
        E.onRemove = function() {
            Tu.prototype.onRemove.call(this),
                this.removeGLCanvas()
        }
    ;
    var Tu, E = Eu;
    function Eu() {
        return Tu.apply(this, arguments) || this
    }
    function ku(e) {
        var t = this.layer.getTileSize()
            , i = this.canvas.constructor
            , n = this.getMap()
            , r = n.getDevicePixelRatio()
            , o = O.createCanvas(t.width * r, t.height * r, i)
            , s = (o.layer = this.layer,
            this)
            , r = new g(n.pointToCoordinate(e.point),n.pointToCoordinate(e.point.add(t.toPoint())),n.getProjection());
        return this.layer.drawTile(o, {
            url: e.url,
            point: e.point,
            center: n.pointToCoordinate(e.point.add(t.width / 2, t.height / 2)),
            extent: r,
            z: e.z,
            x: e.x,
            y: e.y
        }, function(t) {
            t ? s.onTileError(o, e) : s.onTileLoad(o, e)
        }),
            o
    }
    C.registerRenderer("gl", E);
    s(Lu, Ru = k),
        Lu.prototype.loadTile = function() {
            return ku.apply(this, arguments)
        }
    ;
    var Ru, Au = Lu;
    function Lu() {
        return Ru.apply(this, arguments) || this
    }
    s(Iu, Ou = E),
        Iu.prototype.loadTile = function() {
            return ku.apply(this, arguments)
        }
    ;
    var Ou, Du = Iu;
    function Iu() {
        return Ou.apply(this, arguments) || this
    }
    fl.registerRenderer("canvas", Au),
        fl.registerRenderer("gl", Du);
    s(Zu, ju = _e),
        (zu = Zu.prototype).callInNextFrame = function(t) {
            this._handlerQueue.push(t)
        }
        ,
        zu.executeFrameCallbacks = function() {
            var t = this._handlerQueue;
            this._handlerQueue = [];
            for (var e = 0, i = t.length; e < i; e++)
                t[e]()
        }
        ,
        zu.offsetPlatform = function(t, e) {
            if (!this.map._panels.front)
                return this;
            if (!e && 0 === t.x && 0 === t.y)
                return this;
            var i, e = this.map._panels, n = this._frontCount = e.back.layerDOM.childElementCount, r = this._backCount = e.front.layerDOM.childElementCount, o = this._uiCount = e.front.uiDOM.childElementCount;
            return (n || r || o) && (i = this.map.offsetPlatform(),
                i = t ? i.add(t)._round() : i.round(),
            r && ri(e.back, i),
            (n || o) && ri(e.front, i)),
                this
        }
        ,
        zu.domChanged = function() {
            var t = this.map._panels;
            if (!t.front)
                return !1;
            var e = t.back.layerDOM.childElementCount;
            if (void 0 === this._frontCount || this._frontCount !== e)
                return !0;
            e = t.front.layerDOM.childElementCount;
            if (void 0 === this._backCount || this._backCount !== e)
                return !0;
            e = t.front.uiDOM.childElementCount;
            return void 0 === this._uiCount || this._uiCount !== e
        }
        ,
        zu.resetContainer = function() {
            var t;
            this.map && (this.map._resetMapViewPoint(),
            this.map._panels.front && (t = new R(0,0),
                ri(this.map._panels.back, t),
                ri(this.map._panels.front, t)))
        }
        ,
        zu.onZoomEnd = function() {
            this.resetContainer()
        }
        ,
        zu.onLoad = function() {
            this._frameLoop()
        }
    ;
    var ju, zu = Zu;
    function Zu(t) {
        var e = ju.call(this) || this;
        return e.map = t,
            e._handlerQueue = {},
            e
    }
    s(Gu, Hu = zu),
        (A = Gu.prototype).load = function() {
            this.initContainer()
        }
        ,
        A.renderFrame = function(t) {
            if (!this.map)
                return !1;
            delete this._isViewChanged;
            var e = this.map
                , i = (e._fireEvent("framestart"),
                this.updateMapDOM(),
                this._getAllLayerToRender());
            return this.drawLayers(i, t),
            this.drawLayerCanvas(i) && this._drawCenterCross(),
                e._fireEvent("frameend"),
                this._recordView(),
                this._mapview = this._getMapView(),
                delete this._spatialRefChanged,
                this._fireLayerLoadEvents(),
                this.executeFrameCallbacks(),
                !(this._canvasUpdated = !1)
        }
        ,
        A.updateMapDOM = function() {
            var t, e = this.map;
            e.isZooming() || ((t = e._getViewPointFrameOffset()) ? e.offsetPlatform(t) : this.domChanged() && this.offsetPlatform(null, !0))
        }
        ,
        A.drawLayers = function(t, e) {
            for (var i = this.map, n = i.isInteracting(), r = [], o = [], s = i.options.fpsOnInteracting || 0, a = 0 === s ? 0 : 1e3 / s, h = this.map.options.layerCanvasLimitOnInteracting, l = t.length, u = i.getBaseLayer(), c = 0, d = 0; d < l; d++) {
                var g = t[d];
                if (g.isVisible()) {
                    var p = g.isCanvasRender()
                        , f = (p && r.push(g.getId()),
                        g._getRenderer());
                    if (f) {
                        var m = this._checkLayerRedraw(g)
                            , _ = (p && f.isCanvasUpdated() && (m || o.push(g.getId()),
                            this.setLayerCanvasUpdated()),
                            f.__zoomTransformMatrix);
                        if (delete f.__zoomTransformMatrix,
                            m) {
                            if (n && p) {
                                if (0 < h && h < l - 1 - d && g !== u) {
                                    g._getRenderer().clearCanvas();
                                    continue
                                }
                                c += this._drawCanvasLayerOnInteracting(g, c, a, e)
                            } else
                                n && f.drawOnInteracting ? (f.prepareRender && f.prepareRender(),
                                    f.checkAndDraw ? f.checkAndDraw(f.drawOnInteracting, this._eventParam, e) : f.drawOnInteracting(this._eventParam, e)) : (f.render(e),
                                p && _ && f.isLoadingResource() && (f.__zoomTransformMatrix = _));
                            p && (o.push(g.getId()),
                                this.setLayerCanvasUpdated())
                        } else
                            p && n && (i.isZooming() && !i.getPitch() ? (f.prepareRender(),
                                f.__zoomTransformMatrix = this._zoomMatrix) : (i.getPitch() || i.isRotating()) && f.clearCanvas())
                    }
                }
            }
            var s = this._canvasIds || []
                , y = this._updatedIds || [];
            this._canvasIds = r,
                this._updatedIds = o,
            this.isLayerCanvasUpdated() || (s.join("---") === r.join("---") && y.join("---") === o.join("---") || this.setLayerCanvasUpdated())
        }
        ,
        A._checkLayerRedraw = function(t) {
            if (this.isSpatialReferenceChanged())
                return !0;
            var e = this.map
                , i = t._getRenderer();
            return t.isCanvasRender() ? i.testIfNeedRedraw() : !(!i.needToRedraw || !i.needToRedraw()) || (e.isInteracting() || this.isViewChanged())
        }
        ,
        A._drawCanvasLayerOnInteracting = function(t, e, i, n) {
            var r = this.map
                , o = t._getRenderer()
                , s = o.getDrawTime()
                , e = 0 === i || 0 < i && e + s <= i;
            if (o.mustRenderOnInteracting && o.mustRenderOnInteracting())
                o.render(n);
            else {
                if (o.drawOnInteracting && (t === r.getBaseLayer() || e || r.isZooming() && t.options.forceRenderOnZooming || r.isMoving() && t.options.forceRenderOnMoving || r.isRotating() && t.options.forceRenderOnRotating))
                    return o.prepareRender(),
                        o.prepareCanvas(),
                        o.checkAndDraw ? o.checkAndDraw(o.drawOnInteracting, this._eventParam, n) : o.drawOnInteracting(this._eventParam, n),
                        s;
                !r.isZooming() || r.getPitch() || r.isRotating() ? (r.getPitch() || r.isRotating()) && o.clearCanvas() : (o.prepareRender(),
                    o.__zoomTransformMatrix = this._zoomMatrix)
            }
            return o.drawOnInteracting && !e && o.onSkipDrawOnInteracting(this._eventParam, n),
                0
        }
        ,
        A._fireLayerLoadEvents = function() {
            var i;
            this._updatedIds && 0 < this._updatedIds.length && (i = this.map,
                this._updatedIds.reverse().forEach(function(t) {
                    var e, t = i.getLayer(t);
                    !t || (e = t._getRenderer()) && e.isRenderComplete() && t.fire("layerload")
                }))
        }
        ,
        A.isLayerCanvasUpdated = function() {
            return this._canvasUpdated
        }
        ,
        A.setLayerCanvasUpdated = function() {
            this._canvasUpdated = !0
        }
        ,
        A.drawLayerCanvas = function(t) {
            var e = this.map;
            if (!e)
                return !1;
            if (!this.isLayerCanvasUpdated() && !this.isViewChanged())
                return !1;
            this.canvas || this.createCanvas(),
                e._fireEvent("renderstart", {
                    context: this.context
                }),
            this._updateCanvasSize() || this.clearCanvas();
            for (var i, n, r = e.isInteracting(), o = e.options.layerCanvasLimitOnInteracting, s = t.length, a = [], h = 0; h < s; h++)
                t[h].isVisible() && t[h].isCanvasRender() && t[h]._getRenderer() && (n = this._getLayerImage(t[h])) && n.image && (t[h] === e.getBaseLayer() ? i = [t[h], n] : a.push([t[h], n]));
            i && (this._drawLayerCanvasImage(i[0], i[1]),
                this._drawFog());
            for (var s = a.length, l = r && 0 <= o && o < s ? s - o : 0; l < s; l++)
                this._drawLayerCanvasImage(a[l][0], a[l][1]);
            return e._fireEvent("renderend", {
                context: this.context
            }),
                !0
        }
        ,
        A.setToRedraw = function() {
            for (var t = this._getAllLayerToRender(), e = 0, i = t.length; e < i; e++) {
                var n = t[e].getRenderer();
                n && n.canvas && n.setToRedraw && n.setToRedraw()
            }
        }
        ,
        A.updateMapSize = function(t) {
            var e, i;
            t && !this._containerIsCanvas && (e = t.width + "px",
                t = t.height + "px",
                (i = this.map._panels).mapWrapper.style.width = e,
                i.mapWrapper.style.height = t,
                this._updateCanvasSize())
        }
        ,
        A.getMainPanel = function() {
            return this.map ? this._containerIsCanvas ? this.map._containerDOM : this.map._panels ? this.map._panels.mapWrapper : null : null
        }
        ,
        A.toDataURL = function(t) {
            return this.canvas ? this.canvas.toDataURL(t) : null
        }
        ,
        A.remove = function() {
            c.webgl && "undefined" != typeof document && $e(document, "visibilitychange", this._thisVisibilitychange),
            this._resizeInterval && clearInterval(this._resizeInterval),
                delete this.context,
                delete this.canvas,
                delete this.map,
                delete this._spatialRefChanged,
                this._cancelFrameLoop()
        }
        ,
        A.hitDetect = function(t) {
            var e = this.map;
            if (e && e.options.hitDetect && !e.isInteracting()) {
                for (var i = e._getLayers(), n = "default", r = e.options.hitDetectLimit || 0, o = 0, s = i.length - 1; 0 <= s; s--) {
                    var a = i[s];
                    if (!(!a.options.hitDetect || a.isEmpty && a.isEmpty())) {
                        var h = a._getRenderer();
                        if (h && h.hitDetect && (!h.isBlank || !h.isBlank())) {
                            if ("default" !== a.options.cursor && h.hitDetect(t)) {
                                n = a.options.cursor || "pointer";
                                break
                            }
                            if (o++,
                            0 < r && r < o)
                                break
                        }
                    }
                }
                e._trySetCursor(n)
            }
        }
        ,
        A._getLayerImage = function(t) {
            t = t._getRenderer();
            return t.getCanvasImage ? t.getCanvasImage() : null
        }
        ,
        A.initContainer = function() {
            var r = this.map._panels;
            function t(t, e, i, n) {
                e = f("div", e);
                return i && (e.style.cssText = i),
                    r[t] = e,
                n || ni(e),
                    e
            }
            var e, i, n, o, s, a, h, l, u, c, d, g = this.map._containerDOM;
            this._containerIsCanvas || (c = "position:absolute;top:0px;left:0px;",
                e = t("mapWrapper", "maptalks-wrapper", "position:absolute;overflow:hidden;", !(g.innerHTML = "")),
                i = t("allLayers", "maptalks-all-layers", c + "padding:0px;margin:0px;z-index:0;overflow:visible;", !0),
                n = t("backStatic", "maptalks-back-static", c + "z-index:0;", !0),
                o = t("back", "maptalks-back", c + "z-index:1;"),
                s = t("backLayer", "maptalks-back-layer", c),
                a = t("canvasContainer", "maptalks-canvas-layer", c + "border:none;z-index:2;"),
                h = t("frontStatic", "maptalks-front-static", c + "z-index:3;", !0),
                l = t("front", "maptalks-front", c + "z-index:4;", !0),
                u = t("frontLayer", "maptalks-front-layer", c + "z-index:0;"),
                c = t("ui", "maptalks-ui", c + "border:none;z-index:1;", !0),
                d = t("control", "maptalks-control", "z-index:1", !0),
                g.appendChild(e),
                i.appendChild(n),
                o.appendChild(s),
                o.layerDOM = s,
                i.appendChild(o),
                i.appendChild(a),
                l.appendChild(u),
                l.layerDOM = u,
                l.uiDOM = c,
                i.appendChild(h),
                i.appendChild(l),
                l.appendChild(c),
                e.appendChild(i),
                e.appendChild(d),
                this.createCanvas(),
                this.resetContainer(),
                g = this.map._getContainerDomSize(),
                this.updateMapSize(g))
        }
        ,
        A.isViewChanged = function() {
            if (void 0 !== this._isViewChanged)
                return this._isViewChanged;
            var t = this._mapview
                , e = this._getMapView();
            return this._isViewChanged = !t || !Ct(t, e),
                this._isViewChanged
        }
        ,
        A._recordView = function() {
            var t = this.map;
            !t._onViewChange || t.isInteracting() || t.isAnimating() || Ct(t.getView(), t._getCurrentView()) || t._onViewChange(t.getView())
        }
        ,
        A.isSpatialReferenceChanged = function() {
            return this._spatialRefChanged
        }
        ,
        A._getMapView = function() {
            var t = this.map
                , e = t._getPrjCenter();
            return {
                x: e.x,
                y: e.y,
                zoom: t.getZoom(),
                pitch: t.getPitch(),
                bearing: t.getBearing(),
                width: t.width,
                height: t.height
            }
        }
        ,
        A._frameLoop = function(t) {
            var e = this;
            this.map ? (this.renderFrame(t),
                this._animationFrame = K(function(t) {
                    e._frameLoop(t)
                })) : this._cancelFrameLoop()
        }
        ,
        A._cancelFrameLoop = function() {
            this._animationFrame && Q(this._animationFrame)
        }
        ,
        A._drawLayerCanvasImage = function(t, e) {
            var i, n, r = this.context, o = e.point.round(), s = this.map.getDevicePixelRatio(), s = (1 !== s && o._multi(s),
                e.image), a = s.width, h = s.height;
            o.x + a <= 0 || o.y + h <= 0 || ((n = P(n = t.options.opacity) ? n : 1) <= 0 || ((e = P(e = e.opacity) ? e : 1) <= 0 || (i = r.globalAlpha,
            n < 1 && (r.globalAlpha *= n),
            e < 1 && (r.globalAlpha *= e),
            t.options.cssFilter && (r.filter = t.options.cssFilter),
                e = (n = t.getRenderer()).__zoomTransformMatrix,
                t = n.clipCanvas(this.context),
            e && (r.save(),
                r.setTransform.apply(r, e)),
                r.drawImage(s, 0, 0, a, h, o.x, o.y, a, h),
            e && r.restore(),
            t && r.restore(),
            "none" !== r.filter && (r.filter = "none"),
                r.globalAlpha = i)))
        }
        ,
        A._drawCenterCross = function() {
            var t, e, i = this.map.options.centerCross;
            i && (t = this.context,
                e = new R(this.canvas.width / 2,this.canvas.height / 2),
                p(i) ? i(t, e) : O.drawCross(this.context, e.x, e.y, 2, "#f00"))
        }
        ,
        A._drawContainerExtent = function() {
            var t = this.map.options.cascadePitches
                , e = this.map.height - this.map._getVisualHeight(t[0])
                , t = this.map.height - this.map._getVisualHeight(t[1])
                , i = this.map.getContainerExtent()
                , n = this.context;
            n.beginPath(),
                n.moveTo(0, i.ymin),
                n.lineTo(i.xmax, i.ymin),
                n.stroke(),
                n.beginPath(),
                n.moveTo(0, e),
                n.lineTo(i.xmax, e),
                n.stroke(),
                n.beginPath(),
                n.moveTo(0, t),
                n.lineTo(i.xmax, t),
                n.stroke()
        }
        ,
        A._drawFog = function() {
            var t, e, i, n, r, o, s, a = this.map;
            a.getPitch() <= a.options.maxVisualPitch || !a.options.fog || (t = a.getDevicePixelRatio(),
                e = this.context,
                i = a.getContainerExtent(),
            (n = (a.height - a._getVisualHeight(75)) * t) < 0 && (n = 0),
                o = i.ymin * t,
                r = Math.ceil(o - n),
                a = a.options.fogColor.join(),
                s = 1 - 30 / (r + 30),
                (o = e.createLinearGradient(0, n, 0, 30 + o)).addColorStop(0, "rgba(" + a + ", 0)"),
                o.addColorStop(.3, "rgba(" + a + ", 0.3)"),
                o.addColorStop(s, "rgba(" + a + ", 1)"),
                o.addColorStop(1, "rgba(" + a + ", 0)"),
                e.beginPath(),
                e.fillStyle = o,
                e.fillRect(0, n, Math.ceil(i.getWidth()) * t, Math.ceil(r + 30)))
        }
        ,
        A._getAllLayerToRender = function() {
            return this.map._getLayers()
        }
        ,
        A.clearCanvas = function() {
            this.canvas && O.clearRect(this.context, 0, 0, this.canvas.width, this.canvas.height)
        }
        ,
        A._updateCanvasSize = function() {
            if (!this.canvas || this._containerIsCanvas)
                return !1;
            var t = this.map
                , e = t.getSize()
                , i = this.canvas
                , t = t.getDevicePixelRatio();
            return (e.width * t !== i.width || e.height * t !== i.height) && (i.height = t * e.height,
                i.width = t * e.width,
            i.style && (i.style.width = e.width + "px",
                i.style.height = e.height + "px"),
                !0)
        }
        ,
        A.createCanvas = function() {
            this._containerIsCanvas ? this.canvas = this.map._containerDOM : (this.canvas = f("canvas"),
                this._updateCanvasSize(),
                this.map._panels.canvasContainer.appendChild(this.canvas)),
                this.context = this.canvas.getContext("2d")
        }
        ,
        A._checkSize = function() {
            this.map && !this.map.isInteracting() && (oi(this.map._containerDOM),
                this.map.checkSize())
        }
        ,
        A._setCheckSizeInterval = function(t) {
            var e = this;
            clearInterval(this._resizeInterval),
                this._checkSizeInterval = t,
                this._resizeInterval = setInterval(function() {
                    !e.map || e.map.isRemoved() ? clearInterval(e._resizeInterval) : e._checkSize()
                }, this._checkSizeInterval)
        }
        ,
        A._registerEvents = function() {
            var e = this
                , i = this.map;
            i.options.checkSize && !$ && "undefined" != typeof window && this._setCheckSizeInterval(i.options.checkSizeInterval),
            c.mobile || i.on("_mousemove", this._onMapMouseMove, this),
                i.on("_dragrotatestart _dragrotating _dragrotateend _movestart _moving _moveend _zoomstart", function(t) {
                    e._eventParam = t
                }),
                i.on("_zooming", function(t) {
                    i.getPitch() || (e._zoomMatrix = t.matrix.container),
                        e._eventParam = t
                }),
                i.on("_zoomend", function(t) {
                    e._eventParam = t,
                        delete e._zoomMatrix
                }),
                i.on("_spatialreferencechange", function() {
                    e._spatialRefChanged = !0
                }),
            c.webgl && "undefined" != typeof document && Qe(document, "visibilitychange", this._thisVisibilitychange, this)
        }
        ,
        A._onMapMouseMove = function(t) {
            var e = this
                , i = this.map;
            !i.isInteracting() && i.options.hitDetect && (this._hitDetectFrame && Q(this._hitDetectFrame),
                this._hitDetectFrame = K(function() {
                    e.hitDetect(t.containerPoint)
                }))
        }
        ,
        A._getCanvasLayers = function() {
            return this.map._getLayers(function(t) {
                return t.isCanvasRender()
            })
        }
        ,
        A._onVisibilitychange = function() {
            "visible" === document.visibilityState && this.setToRedraw()
        }
    ;
    var Hu, A = Gu;
    function Gu(t) {
        var e = Hu.call(this, t) || this;
        return e._containerIsCanvas = !!t._containerDOM.getContext,
            e._thisVisibilitychange = e._onVisibilitychange.bind(Ee(e)),
            e._registerEvents(),
            e._loopTime = 0,
            e
    }
    h.registerRenderer("canvas", A),
        h.mergeOptions({
            fog: !1,
            fogColor: [233, 233, 233]
        });
    zu = Object.freeze({
        ResourceCache: Cn,
        CanvasRenderer: vn,
        ImageGLRenderable: yl,
        MapRenderer: zu,
        MapCanvasRenderer: A,
        Renderable: pn,
        ImageLayerCanvasRenderer: Sl,
        ImageLayerGLRenderer: Dl,
        TileLayerCanvasRenderer: k,
        TileLayerGLRenderer: E,
        CanvasTileLayerCanvasRenderer: Au,
        CanvasTileLayerGLRenderer: Du,
        OverlayLayerCanvasRenderer: Xl,
        VectorLayerCanvasRenderer: eu,
        CanvasLayerRenderer: zl
    }),
        A = {
            _getRenderPoints: function() {
                return [[this._getCenter2DPoint(this.getMap().getGLZoom())], null]
            }
        },
        Ao.include(A),
        os.include(A),
        is.include(A),
        cs.include(A),
        hs.include({
            _getRenderPoints: function(t) {
                var e = this.getMap();
                if ("vertex" !== t)
                    return [[e.coordToPoint(this.getCenter(), e.getGLZoom())], null];
                for (var i = this._trimRing(this.getShell()), n = [], r = 0, o = i.length; r < o; r++)
                    n.push(e.coordToPoint(i[r], e.getGLZoom()));
                return [n, null]
            }
        }),
        Sl = {
            _getRenderPoints: function(t) {
                var e, i, n = this.getMap(), r = n.getGLZoom(), o = null;
                if ("point" === t)
                    (d = this._getPath2DPoints(this._getPrjCoordinates(), !1, r)) && 0 < d.length && Array.isArray(d[0]) && (d = d[0].concat(d[1]));
                else if ("vertex" === t)
                    if (o = [],
                    (d = this._getPath2DPoints(this._getPrjCoordinates(), !1, r)) && 0 < d.length && Array.isArray(d[0])) {
                        for (var s = 0, a = d.length; s < a; s++)
                            for (var h = 0, l = d[s].length; h < l; h++)
                                0 === h ? o.push([d[s][h], d[s][h + 1]]) : o.push([d[s][h - 1], d[s][h]]);
                        d = d[0].concat(d[1])
                    } else
                        for (var u = 0, c = d.length; u < c; u++)
                            0 === u ? o.push([d[u], d[u + 1]]) : o.push([d[u - 1], d[u]]);
                else if ("line" === t) {
                    var d = []
                        , o = []
                        , g = this._getPath2DPoints(this._getPrjCoordinates(), !1, r);
                    if (0 < g.length && Array.isArray(g[0]))
                        for (var p, f = 1, m = g.length; f < m; f++) {
                            p = g[f],
                            this instanceof S && 0 < p.length && !p[0].equals(p[p.length - 1]) && p.push(p[0]);
                            for (var _ = 1, y = p.length; _ < y; _++)
                                d.push(p[_].add(p[_ - 1])._multi(.5)),
                                    o.push([p[_ - 1], p[_]])
                        }
                    else {
                        this instanceof S && 0 < g.length && !g[0].equals(g[g.length - 1]) && g.push(g[0]);
                        for (var v = 1, x = g.length; v < x; v++)
                            d.push(g[v].add(g[v - 1])._multi(.5)),
                                o.push([g[v - 1], g[v]])
                    }
                } else
                    "vertex-first" === t ? (d = (e = this._getPrjCoordinates()).length ? [n._prjToPoint(e[0], r)] : [],
                        o = e.length ? [[n._prjToPoint(e[0], r), n._prjToPoint(e[1], r)]] : []) : "vertex-last" === t ? (d = (t = (e = this._getPrjCoordinates()).length) ? [n._prjToPoint(e[t - 1], r)] : [],
                        i = t - 1,
                        o = t ? [[n._prjToPoint(e[1 < t ? t - 2 : t - 1], r), n._prjToPoint(e[i], r)]] : []) : (t = this._getProjection().project(this.getCenter()),
                        d = [n._prjToPoint(t, r)]);
                return [d, o]
            }
        },
        Io.include(Sl),
        S.include(Sl),
        y.include({
            _redrawWhenPitch: function() {
                return !1
            },
            _redrawWhenRotate: function() {
                return !1
            }
        }),
        Dl = {
            _redrawWhenPitch: function() {
                return !0
            },
            _redrawWhenRotate: function() {
                return this instanceof os || this instanceof cs
            },
            _paintAsPath: function() {
                var t = this.getMap();
                return 0 < this.getAltitude() || t.getPitch() || this instanceof os && t.getBearing()
            },
            _getPaintParams: function() {
                var t = this.getMap();
                if (this._paintAsPath())
                    return S.prototype._getPaintParams.call(this, !0);
                var e = this._getPrjCoordinates()
                    , e = t._prjToPoint(e, t.getGLZoom())
                    , t = this._getRenderSize(e);
                return [e].concat(t)
            },
            _paintOn: function() {
                return (this._paintAsPath() ? O.polygon : O.ellipse).apply(O, arguments)
            },
            _getRenderSize: function(t) {
                var e = this.getMap()
                    , i = e.getGLZoom()
                    , n = this._getPrjExtent()
                    , r = e._prjToPoint(n.getMin(), i)
                    , e = e._prjToPoint(n.getMax(), i);
                return [Math.abs(e.x - r.x) / 2, Math.abs(e.y - t.y), Math.abs(t.y - r.y)]
            }
        };
    os.include(Dl),
        is.include(Dl),
        hs.include({
            _getPaintParams: function() {
                var t = this.getMap().getGLZoom()
                    , e = this._getPrjShell();
                return [this._getPath2DPoints(e, !1, t)]
            },
            _paintOn: O.polygon
        }),
        cs.include(Dl, {
            _redrawWhenPitch: function() {
                return !0
            },
            _getPaintParams: function() {
                if (this._paintAsPath())
                    return S.prototype._getPaintParams.call(this, !0);
                var t = this.getMap()
                    , t = t._prjToPoint(this._getPrjCoordinates(), t.getGLZoom());
                return [t, this._getRenderSize(t)[0], [this.getStartAngle(), this.getEndAngle()]]
            },
            _paintOn: function() {
                var t, e;
                return this._paintAsPath() ? O.polygon.apply(O, arguments) : (t = this.getMap().getBearing(),
                    e = arguments,
                t && (e[3] = e[3].slice(0),
                    e[3][0] += t,
                    e[3][1] += t),
                    O.sector.apply(O, e))
            }
        }),
        a.include({
            _paintAsPath: function() {
                return !0
            }
        }),
        Io.include({
            arrowStyles: {
                classic: [3, 4]
            },
            _getArrowShape: function(t, e, i, n, r) {
                if (!t || !e || t.equals(e))
                    return null;
                var o = i * n[0]
                    , i = i * n[1] + (r = r || 0)
                    , n = o / 2 + r
                    , o = e.nextCtrlPoint || e.prevCtrlPoint ? e.prevCtrlPoint ? e.sub(new R(e.prevCtrlPoint)) : e.sub(new R(e.nextCtrlPoint)) : e.sub(t)
                    , r = (o._unit(),
                    e.sub(o.multi(i)))
                    , t = (o._perp(),
                    r.add(o.multi(n)));
                return o._multi(-1),
                    [t, e, r.add(o.multi(n)), t]
            },
            _getPaintParams: function() {
                var t = this._getPrjCoordinates();
                return [this._getPath2DPoints(t, !1, this.getMap().getGLZoom())]
            },
            _paintOn: function(t, e, i, n, r) {
                this.options.smoothness ? O.paintSmoothLine(t, e, i, this.options.smoothness, !1, this._animIdx, this._animTailRatio) : O.path(t, e, i, null, r),
                    this._paintArrow(t, e, i)
            },
            _getArrowPlacement: function() {
                return this.options.arrowPlacement
            },
            _getArrowStyle: function() {
                var t = this.options.arrowStyle;
                return t ? Array.isArray(t) ? t : this.arrowStyles[t] : null
            },
            _getArrows: function(t, e, i) {
                var n = this._getArrowStyle();
                if (!n || t.length < 2)
                    return [];
                for (var r, o = 0 < t.length && Array.isArray(t[0]) ? t : [t], s = this._getArrowPlacement(), a = [], t = this.getMap(), h = t.coordToContainerPoint(this.getFirstCoordinate()), l = t.coordToContainerPoint(this.getLastCoordinate()), u = o.length - 1; 0 <= u; u--)
                    ("vertex-first" === s || "vertex-firstlast" === s && o[u][0].closeTo(h, .01)) && (r = this._getArrowShape(o[u][1], o[u][0], e, n, i)) && a.push(r),
                        "vertex-last" === s || "vertex-firstlast" === s && o[u][o[u].length - 1].closeTo(l, .01) ? (r = this._getArrowShape(o[u][o[u].length - 2], o[u][o[u].length - 1], e, n, i)) && a.push(r) : "point" === s && this._getArrowPoints(a, o[u], e, n, i);
                return a
            },
            _getArrowPoints: function(t, e, i, n, r) {
                for (var o = 0, s = e.length - 1; o < s; o++) {
                    var a = this._getArrowShape(e[o], e[o + 1], i, n, r);
                    a && t.push(a)
                }
            },
            _paintArrow: function(t, e, i) {
                var n = this._getInternalSymbol().lineWidth
                    , r = ((!P(n) || n < 3) && (n = 3),
                    this._getArrows(e, n));
                if (r.length) {
                    t.setLineDash && t.setLineDash([]);
                    for (var o = r.length - 1; 0 <= o; o--)
                        t.fillStyle = t.strokeStyle,
                            O.polygon(t, r[o], i, i)
                }
            }
        }),
        S.include({
            _getPaintParams: function(t) {
                var e = this.getMap().getGLZoom()
                    , i = this._getPrjShell()
                    , n = this._getPath2DPoints(i, t, e)
                    , r = 0 < n.length && Array.isArray(n[0])
                    , o = (r && (n = [[n[0]], [n[1]]]),
                    this._getPrjHoles())
                    , s = [];
                if (o && 0 < o.length) {
                    for (var i = this._simplified, a = 0; a < o.length; a++) {
                        var h = this._getPath2DPoints(o[a], t, e);
                        Array.isArray(h) && r ? Array.isArray(h[0]) ? (n[0].push(h[0]),
                            n[1].push(h[1])) : n[0].push(h) : s.push(h)
                    }
                    i && (this._simplified = i)
                }
                return r || ot(n = [n], s),
                    [n]
            },
            _paintOn: function(t, e, i, n, r) {
                O.polygon(t, e, i, n, r, this.options.smoothness)
            }
        }),
        h.VERSION = "0.49.1",
        t.Util = le,
        t.DomUtil = we,
        t.StringUtil = ue,
        t.MapboxUtil = Yt,
        t.Map = h,
        t.ui = w,
        t.control = Dh,
        t.renderer = zu,
        t.symbolizer = lr,
        t.animation = e,
        t.Browser = c,
        t.Ajax = _i,
        t.Canvas = O,
        t.Promise = Ti,
        t.Class = _e,
        t.Eventable = Si,
        t.JSONAble = Ai,
        t.Handlerable = Oi,
        t.Handler = ki,
        t.DragHandler = Zi,
        t.MapTool = Xs,
        t.DrawTool = ta,
        t.AreaTool = x,
        t.DistanceTool = v,
        t.SpatialReference = br,
        t.INTERNAL_LAYER_PREFIX = D,
        t.GEOMETRY_COLLECTION_TYPES = I,
        t.GEOJSON_TYPES = j,
        t.RESOURCE_PROPERTIES = z,
        t.RESOURCE_SIZE_PROPERTIES = Z,
        t.NUMERICAL_PROPERTIES = H,
        t.COLOR_PROPERTIES = G,
        t.DEFAULT_TEXT_SIZE = 14,
        t.projection = yn,
        t.measurer = ce,
        t.Coordinate = M,
        t.CRS = be,
        t.Extent = g,
        t.Point = R,
        t.PointExtent = U,
        t.Size = Le,
        t.Transformation = on,
        t.Layer = kr,
        t.TileLayer = C,
        t.GroupTileLayer = T,
        t.WMSTileLayer = dl,
        t.CanvasTileLayer = fl,
        t.ImageLayer = El,
        t.OverlayLayer = d,
        t.VectorLayer = Us,
        t.CanvasLayer = Fl,
        t.ParticleLayer = Ul,
        t.ClusterLayer = ru,
        t.TileSystem = Ih,
        t.TileConfig = zh,
        t.ArcCurve = _s,
        t.Circle = is,
        t.ConnectorLine = zs,
        t.ArcConnectorLine = Gs,
        t.CubicBezierCurve = xs,
        t.Curve = ps,
        t.Ellipse = os,
        t.GeoJSON = es,
        t.Geometry = y,
        t.GeometryCollection = Zo,
        t.Label = Os,
        t.LineString = Io,
        t.Marker = Ao,
        t.MultiLineString = Yo,
        t.MultiPoint = Bo,
        t.MultiPolygon = l,
        t.Polygon = S,
        t.QuadBezierCurve = Ps,
        t.Rectangle = hs,
        t.Sector = cs,
        t.TextBox = Rs,
        t.TextMarker = u,
        Object.defineProperty(t, "__esModule", {
            value: !0
        })
});
;/*
    http://www.JSON.org/json2.js
    2008-03-24

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html

    This file creates a global JSON object containing three methods: stringify,
    parse, and quote.


        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects without a toJSON
                        method. It can be a function or an array.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t'), it contains the
                        characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method will
            be passed the key associated with the value, and this will be bound
            to the object holding the key.

            This is the toJSON method added to Dates:

                function toJSON(key) {
                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                }

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If no replacer parameter is provided, then a default replacer
            will be used:

                function replacer(key, value) {
                    return Object.hasOwnProperty.call(this, key) ?
                        value : undefined;
                }

            The default replacer is passed the key and value for each item in
            the structure. It excludes inherited members.

            If the replacer parameter is an array, then it will be used to
            select the members to be serialized. It filters the results such
            that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representaions, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the value
            that is filled with line breaks and indentation to make it easier to
            read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            then indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });


        JSON.quote(text)
            This method wraps a string in quotes, escaping some characters
            as needed.


    This is a reference implementation. You are free to copy, modify, or
    redistribute.

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD THIRD PARTY
    CODE INTO YOUR PAGES.
*/

/*jslint regexp: true, forin: true, evil: true */

/*global JSON */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, floor, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join, length,
    parse, propertyIsEnumerable, prototype, push, quote, replace, stringify,
    test, toJSON, toString
*/

if (!this.JSON) {

    // Create a JSON object only if one does not already exist. We create the
    // object in a closure to avoid global variables.

    JSON = function() {

        function f(n) {
            // Format integers to have at least two digits.
            return n < 10 ? '0' + n : n;
        }

        Date.prototype.toJSON = function() {

            // Eventually, this method will be based on the date.toISOString method.

            return this.getUTCFullYear() + '-' + f(this.getUTCMonth() + 1) + '-' + f(this.getUTCDate()) + 'T' + f(this.getUTCHours()) + ':' + f(this.getUTCMinutes()) + ':' + f(this.getUTCSeconds()) + 'Z';
        }
        ;

        var escapeable = /["\\\x00-\x1f\x7f-\x9f]/g, gap, indent, meta = {
            // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
        }, rep;

        function quote(string) {

            // If the string contains no control characters, no quote characters, and no
            // backslash characters, then we can safely slap some quotes around it.
            // Otherwise we must also replace the offending characters with safe escape
            // sequences.

            return escapeable.test(string) ? '"' + string.replace(escapeable, function(a) {
                var c = meta[a];
                if (typeof c === 'string') {
                    return c;
                }
                c = a.charCodeAt();
                return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
            }) + '"' : '"' + string + '"';
        }

        function str(key, holder) {

            // Produce a string from holder[key].

            var i, // The loop counter.
                k, // The member key.
                v, // The member value.
                length, mind = gap, partial, value = holder[key];

            // If the value has a toJSON method, call it to obtain a replacement value.

            if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
                value = value.toJSON(key);
            }

            // If we were called with a replacer function, then call the replacer to
            // obtain a replacement value.

            if (typeof rep === 'function') {
                value = rep.call(holder, key, value);
            }

            // What happens next depends on the value's type.

            switch (typeof value) {
                case 'string':
                    return quote(value);

                case 'number':

                    // JSON numbers must be finite. Encode non-finite numbers as null.

                    return isFinite(value) ? String(value) : 'null';

                case 'boolean':
                case 'null':

                    // If the value is a boolean or null, convert it to a string. Note:
                    // typeof null does not produce 'null'. The case is included here in
                    // the remote chance that this gets fixed someday.

                    return String(value);

                // If the type is 'object', we might be dealing with an object or an array or
                // null.

                case 'object':

                    // Due to a specification blunder in ECMAScript, typeof null is 'object',
                    // so watch out for that case.

                    if (!value) {
                        return 'null';
                    }

                    // Make an array to hold the partial results of stringifying this object value.

                    gap += indent;
                    partial = [];

                    // If the object has a dontEnum length property, we'll treat it as an array.

                    if (typeof value.length === 'number' && !(value.propertyIsEnumerable('length'))) {

                        // The object is an array. Stringify every element. Use null as a placeholder
                        // for non-JSON values.

                        length = value.length;
                        for (i = 0; i < length; i += 1) {
                            partial[i] = str(i, value) || 'null';
                        }

                        // Join all of the elements together, separated with commas, and wrap them in
                        // brackets.

                        v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
                        gap = mind;
                        return v;
                    }

                    // If the replacer is an array, use it to select the members to be stringified.

                    if (typeof rep === 'object') {
                        length = rep.length;
                        for (i = 0; i < length; i += 1) {
                            k = rep[i];
                            if (typeof k === 'string') {
                                v = str(k, value, rep);
                                if (v) {
                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
                                }
                            }
                        }
                    } else {

                        // Otherwise, iterate through all of the keys in the object.

                        for (k in value) {
                            v = str(k, value, rep);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }

                    // Join all of the member texts together, separated with commas,
                    // and wrap them in braces.

                    v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
                    gap = mind;
                    return v;
            }
        }

        // Return the JSON object containing the stringify, parse, and quote methods.

        return {
            stringify: function(value, replacer, space) {

                // The stringify method takes a value and an optional replacer, and an optional
                // space parameter, and returns a JSON text. The replacer can be a function
                // that can replace values, or an array of strings that will select the keys.
                // A default replacer method can be provided. Use of the space parameter can
                // produce text that is more easily readable.

                var i;
                gap = '';
                indent = '';
                if (space) {

                    // If the space parameter is a number, make an indent string containing that
                    // many spaces.

                    if (typeof space === 'number') {
                        for (i = 0; i < space; i += 1) {
                            indent += ' ';
                        }

                        // If the space parameter is a string, it will be used as the indent string.

                    } else if (typeof space === 'string') {
                        indent = space;
                    }
                }

                // If there is no replacer parameter, use the default replacer.

                if (!replacer) {
                    rep = function(key, value) {
                        if (!Object.hasOwnProperty.call(this, key)) {
                            return undefined;
                        }
                        return value;
                    }
                    ;

                    // The replacer can be a function or an array. Otherwise, throw an error.

                } else if (typeof replacer === 'function' || (typeof replacer === 'object' && typeof replacer.length === 'number')) {
                    rep = replacer;
                } else {
                    throw new Error('JSON.stringify');
                }

                // Make a fake root object containing our value under the key of ''.
                // Return the result of stringifying the value.

                return str('', {
                    '': value
                });
            },

            parse: function(text, reviver) {

                // The parse method takes a text and an optional reviver function, and returns
                // a JavaScript value if the text is a valid JSON text.

                var j;

                function walk(holder, key) {

                    // The walk method is used to recursively walk the resulting structure so
                    // that modifications can be made.

                    var k, v, value = holder[key];
                    if (value && typeof value === 'object') {
                        for (k in value) {
                            if (Object.hasOwnProperty.call(value, k)) {
                                v = walk(value, k);
                                if (v !== undefined) {
                                    value[k] = v;
                                } else {
                                    delete value[k];
                                }
                            }
                        }
                    }
                    return reviver.call(holder, key, value);
                }

                // Parsing happens in three stages. In the first stage, we run the text against
                // regular expressions that look for non-JSON patterns. We are especially
                // concerned with '()' and 'new' because they can cause invocation, and '='
                // because it can cause mutation. But just to be safe, we want to reject all
                // unexpected forms.

                // We split the first stage into 4 regexp operations in order to work around
                // crippling inefficiencies in IE's and Safari's regexp engines. First we
                // replace all backslash pairs with '@' (a non-JSON character). Second, we
                // replace all simple value tokens with ']' characters. Third, we delete all
                // open brackets that follow a colon or comma or that begin the text. Finally,
                // we look to see that the remaining characters are only whitespace or ']' or
                // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

                if (/^[\],:{}\s]*$/.test(text.replace(/\\["\\\/bfnrtu]/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

                    // In the second stage we use the eval function to compile the text into a
                    // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
                    // in JavaScript: it can begin a block or an object literal. We wrap the text
                    // in parens to eliminate the ambiguity.

                    j = eval('(' + text + ')');

                    // In the optional third stage, we recursively walk the new structure, passing
                    // each name/value pair to a reviver function for possible transformation.

                    return typeof reviver === 'function' ? walk({
                        '': j
                    }, '') : j;
                }

                // If the text is not JSON parseable, then a SyntaxError is thrown.

                throw new SyntaxError('JSON.parse');
            },

            quote: quote
        };
    }();
}
;/**
 * 描述: 地图参数及地图基础方法
 * 作者: liuxf
 * 版本: v1.1 build 2017-09-28 by liuxf
 * 日志:
 * V1.1 2017-09-28 根据JS文件地址动态获取图标的url
 * V1.0 2017-07-19 初始版本
 */

//地图参数
var MapParam = {
        theme: 'cgo8',
        apiType: 'AMap',
        siteRoot: window.document.location.pathname.substring(0, window.document.location.pathname.substr(1).indexOf('/') + 1),
        drawVehicleTrackLineTime: 100,
        //每次绘制轨迹线的时间，单位：毫秒； 即100毫秒画一次
        trackLineMaxPointCount: 100,
        //每条轨迹线最大的点数
        trackingVehicleZoom: -1,
        //当前车缩放级别， -1是表示不缩放
        addressApi: "BaiduMapJs",
        //地理位置解析使用的API类型，默认：BaiduMapJs
        isOpenVehicleCluser: true,
        //是否开启车辆聚合点功能 默认：true-开启
        isOpenFlagCluser: true,
        //是否开启标注聚合点功能 默认：true-开启
        vehicleCluserMaxZoom: 15,
        //最大的聚合级别，大于该级别就不进行相应的聚合, 默认15级
        vehicleClusterMinSize: 5,
        //车辆聚合点的最小数量。默认：5
        isShowTrafficControl: true,
        //实时路况开关控制控件
        isShowClusterControl: false,
        //聚合点开关控制控件
        isShowLayerControl: false,
        //是否显示图层控制
        isShowVehicleRealTrack: false,
        //是否显示车辆小尾巴功能
        isOpenMapInnerIPMode: false,
        //是否开启专网模式，默认0-不开启 1-开启，只有极其特殊情况下才开启
        vehicleRealTrackCount: 3,
        //小尾巴线的点数
        enableCluserRightClick: false,
        //是否开启聚合点右键点击事件
        currentLayer: 'AMap',
        currentLayerName: '高德地图',
        vehicleIconConfig: null,
        isShowAllTrackPoint: false,
        //是否显示所有轨迹点
        isShowTrackDirection: false,
        //是否显示轨迹线方向
        vehicleBgClass: '',
        //车辆图标文字背景css类
        flagBgClass: '',
        //标注图标文字背景css类
        poiBgClass: '',
        //POI图标文字背景css类
        tkey: '',
        //天地图key
        careLandKey: '',
        //凯立德地理位置解析key
        serverConfigUrl: "",
        //自定义图标存放服务器地址
        iconRotate: true,
        //图标是否旋转
        initMapParam: function() {
            //XP系统，IE8及以下则关闭聚合点功能
            var ua = navigator.userAgent.toLowerCase();
            var browser = {};
            browser.isIE = (ua.match(/msie/) != null || ua.match(/trident/) != null);
            browser.isIE8 = browser.isIE && (ua.indexOf('trident/4.0') > -1);
            browser.isWinXP = (ua.indexOf("windows nt 5.1") > -1 || ua.indexOf("windows xp") > -1);
            browser.isWin2003 = (ua.indexOf("windows nt 5.2") > -1 || ua.indexOf("windows 2003") > -1);
            if (browser.isIE && (browser.isIE8 || browser.isWinXP || browser.isWin2003)) {
                MapParam.isOpenVehicleCluser = false;
                MapParam.isOpenFlagCluser = false;
            }

            var js = document.scripts;
            var jsPath;
            var index = -1;
            for (var i = 0; i < js.length; i++) {
                jsPath = js[i].src.toLowerCase();
                index = jsPath.indexOf("/bundles/map/");
                if (index < 0) {
                    index = jsPath.indexOf("/scripts/map/")
                }

                if (index > 0) {
                    MapParam.siteRoot = jsPath.substring(0, index);
                    break;
                }
            }
            if (typeof (g_lang) != 'undefined') {
                initTileLang(g_lang);
            }
        },
        setVehicleIconConfig: function(config) {
            if (config == null)
                return;
            var tmpConfig = {};
            var tmpItem;
            for (var i in config) {
                tmpItem = config[i];
                tmpConfig[tmpItem.IconType] = tmpItem;
            }
            MapParam.vehicleIconConfig = tmpConfig;
            tmpConfig = null;
        },
        setServerConfigUrl: function(config) {
            //获取自定义图标所在地址
            for (var i in config) {
                if (config[i].ServerCode == "CustVehicleIconURL")
                    MapParam.serverConfigUrl = config[i].Url;
            }
        },
        initVehicleIconConfig: function() {
            //暂时不用
            if (MapParam.vehicleIconConfig != null)
                return;
            var serveruri = MapParam.siteRoot + '/comm/VehicleIconParam?t=' + Math.random();
            $.ajax({
                url: serveruri,
                dataType: "jsonp",
                jsonp: "callback",
                type: 'get',
                timeout: 10000,
                success: function(data) {
                    if (data.status == 1) {
                        MapParam.setVehicleIconConfig(data.config);
                    }
                    //else {
                    //    callback("无数据");
                    //}
                },
                error: function(e) {//callback("无数据");
                }
            });
        }
    }

//瓦片地图参数 底图默认1，文字透明图层默认99
var TileLayerParam = {
    "AMap": {
        "url": 'https://webrd0{1,2,3,4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x=[x]&y=[y]&z=[z]',
        "zIndex": 1
    },
    "AMap_Sate": [{
        "url": 'https://webst0{1,2,3,4}.is.autonavi.com/appmaptile?style=6&x=[x]&y=[y]&z=[z]',
        "zIndex": 1
    }, {
        "url": 'https://webst0{1,2,3,4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x=[x]&y=[y]&z=[z]',
        "zIndex": 2
    }],
    "AMap_Google": {
        url: 'https://mt{1,2,3,0}.google.cn/vt/lyrs=m@225000000&hl=zh-CN&gl=cn&src=app&x=[x]&y=[y]&z=[z]&s=Galile',
        zIndex: 1
    },
    "AMap_GoogleSate": [{
        url: 'https://mt{1,2,3,0}.google.cn/vt/lyrs=s%40804&hl=zh-CN&gl=cn&src=app&x=[x]&y=[y]&z=[z]&s=Galile',
        zIndex: 1
    }, {
        url: 'https://mt{1,2,3,0}.google.cn/vt/imgtp=png32&lyrs=h@225000000&hl=zh-CN&gl=cn&src=app&x=[x]&y=[y]&z=[z]&s=Galile',
        zIndex: 2
    }],
    "AMap_icttic": {
        url: 'http://{a,b,c}.qqearth.com:81/engine?st=GetImage&box=[x],[y]&lev=[z]&type=vect&uid=scdxbd',
        zIndex: 1
    }
};

function initInnerIPMode(root) {
    MapParam.isOpenMapInnerIPMode = true;
    MapParam.isShowTrafficControl = false;
    TileLayerParam.AMap.url = root + '?id=0&r={1,2,3,4}&x=[x]&y=[y]&z=[z]';
    TileLayerParam.AMap_Sate[0].url = root + "?id=1&r={1,2,3,4}&x=[x]&y=[y]&z=[z]";
    TileLayerParam.AMap_Sate[1].url = root + "?id=2&r={1,2,3,4}&x=[x]&y=[y]&z=[z]";
    TileLayerParam.AMap_Google.url = root + "?id=3&r={1,2,3,0}&x=[x]&y=[y]&z=[z]";
    TileLayerParam.AMap_GoogleSate[0].url = root + "?id=4&r={1,2,3,0}&x=[x]&y=[y]&z=[z]";
    TileLayerParam.AMap_GoogleSate[1].url = root + "?id=5&r={1,2,3,0}&x=[x]&y=[y]&z=[z]";
    TileLayerParam.AMap_icttic.url = root + "?id=6&r={a,b,c}&x=[x]&y=[y]&z=[z]";
}

function initTileLang(lang) {
    switch (lang) {
        case "en":
        case "ar":
        case "es":
        case "ru":
            //url
            TileLayerParam.AMap.url = TileLayerParam.AMap.url.replace("lang=zh_cn", "lang=en");
            TileLayerParam.AMap_Sate[1].url = TileLayerParam.AMap_Sate[1].url.replace("lang=zh_cn", "lang=en");
            TileLayerParam.AMap_Google.url = TileLayerParam.AMap_Google.url.replace("&hl=zh-CN&gl=cn", "&hl=en-US&gl=us");
            TileLayerParam.AMap_GoogleSate[0].url = TileLayerParam.AMap_GoogleSate[0].url.replace("&hl=zh-CN&gl=cn", "&hl=en-US&gl=us");
            TileLayerParam.AMap_GoogleSate[1].url = TileLayerParam.AMap_GoogleSate[1].url.replace("&hl=zh-CN&gl=cn", "&hl=en-US&gl=us");
            break;
        default:
            break;
    }
}

//地图图层控制
var MapLayerSwitcher = {
    vehicle: true,
    //车辆
    flag: true,
    //标注
    poi: true,
    //poi
    polyline: true,
    //路线
    polygon: true //区域
};

MapParam.initMapParam();

//鼠标类型
var CursorType = {
    'default': 'default',
    'zoomIn': 'url(' + MapParam.siteRoot + '/images/cursor/zoomin.cur),crosshair',
    //放大
    'zoomOut': 'url(' + MapParam.siteRoot + '/images/cursor/zoomout.cur),crosshair',
    //缩小
    'rectZoomIn': 'url(' + MapParam.siteRoot + '/images/cursor/zoomin.cur),crosshair',
    //拉框放大
    'rectZoomOut': 'url(' + MapParam.siteRoot + '/images/cursor/zoomout.cur),crosshair',
    //拉框缩小
    'pan': 'url(' + MapParam.siteRoot + '/images/cursor/openhand.cur), default',
    //漫游
    'getvehicle': 'url(' + MapParam.siteRoot + '/images/cursor/openhand.cur), default',
    //获取车辆ID工具
    'rule': 'crosshair',
    //测量距离
    'measureArea': 'crosshair',
    //测量面积
    'zoomToCenter': 'default',
    //居中
    'point': 'url(' + MapParam.siteRoot + '/images/cursor/pen_r.cur),crosshair',
    //点击地图触发回调事件
    'drawpath': 'crosshair',
    //画线
    'drawpoi': 'url(' + MapParam.siteRoot + '/images/cursor/pen_r.cur),crosshair',
    //画poi
    'delpoi': 'url(' + MapParam.siteRoot + '/images/cursor/pen_r.cur),crosshair',
    //画poi
    'polyline': 'url(' + MapParam.siteRoot + '/images/cursor/pen_r.cur),crosshair',
    //画线
    'circle': 'url(' + MapParam.siteRoot + '/images/cursor/pen_r.cur),crosshair',
    //画圆
    'rectangle': 'url(' + MapParam.siteRoot + '/images/cursor/pen_r.cur),crosshair',
    //画矩形
    'polygon': 'url(' + MapParam.siteRoot + '/images/cursor/pen_r.cur),crosshair'//画多边形
}

//点信息对象
function MarkerOption(type, key, icon, gpslng, gpslat, lng, lat, labeltxt, popContent, isbound, textColor, gpsTime, angle) {
    this.type = type,
        this.key = key,
        //点的唯一标识
        this.icon = icon,
        //{ "width": 19, "height": 31 }
        this.gpslng = gpslng,
        this.gpslat = gpslat,
        this.lng = MapParam.apiType == 'TMap' ? null : lng,
        this.lat = MapParam.apiType == 'TMap' ? null : lat,
        labeltxt = labeltxt + "";
    //转换labeltxt 为字符串
    this.labeltxt = MapParam.apiType == 'TMap' ? (labeltxt || '').replace(/<(?!\/?br?.+?>)[^<>]*>/g, "").replace('<br\>', '<br>').replace('<br/>', '<br>') : (labeltxt || '').replace('<br\>', '<br>').replace('<br/>', '<br>'),
        //TMap label 不支持html
        this.angle = angle || '',
        //方向
        this.popContent = popContent || '',
        this.isbound = isbound,
        this.textColor = textColor || '';
    this.gpsTime = gpsTime || '';
    //车辆缓动判断移动速度

    //if (g_MapEngine && g_MapEngine == 'TMap') {
    //    this.labeltxt = this.labeltxt.replace('<br>', '*br*').replace(/<[^>]+>/gi, '').replace('*br*', '<br>');
    //}
}

function MarkerOptionCompare(option1, option2) {
    if (option1.type == option2.type && option1.key == option2.key && option1.icon == option2.icon && (option1.icon != null && option1.icon.path == option2.icon.path) && (option1.gpslng == option2.gpslng || option1.lng == option2.lng) && (option1.gpslat == option2.gpslat || option1.lat == option2.lat) && option1.labeltxt == option2.labeltxt && option1.angle == option2.angle && option1.popContent == option2.popContent && option1.isbound == option2.isbound)
        return true;
    return false;
}

//气泡框
function box(lng, lat, content, key) {
    this.key = key,
        this.lng = lng,
        this.lat = lat,
        this.content = content
}
//线
function Line(key, lineArr, strokeColor, strokeOpacity, strokeWeight, strokeStyle) {
    this.key = key,
        //点的唯一标识
        this.path = lineArr,
        //设置线覆盖物路径
        this.strokeColor = strokeColor,
        //线颜色
        this.strokeOpacity = strokeOpacity,
        //线透明度
        this.strokeWeight = strokeWeight,
        //线宽
        this.strokeStyle = strokeStyle
    //线样式
}

function ShowVehicleOption() {
    this.labeltext = '',
        this.x = undefined,
        this.y = undefined,
        this.direction = undefined,
        this.iconType = '1',
        this.isZoom = false,
        this.popContent = undefined,
        this.carStatus = undefined,
        this.alarmType = null,
        this.isFill = false,
        this.accOn = false,
        this.gpsValid = false,
        this.vehicleId = undefined,
        this.isShowTrack = false,
        this.trackColor = undefined,
        this.speed = undefined,
        this.clickCallback = undefined,
        this.showCallback = undefined,
        this.bFastMode = false,
        this.gpsTime = undefined
    //yyyy-MM-dd HH:mm:ss
}

function GetVehicleIcon(iconType, carStatus, gpsValid, accOn, isFill, direction, speed) {
    var icondir, iconname;

    if (!iconType) {
        iconType = "default";
    }

    if (speed != null) {
        speed = parseFloat(speed);
    } else {
        speed = 1.0;
    }
    carStatus = carStatus.toString();

    switch (carStatus) {
        case "1":
            //报警
            iconname = 'alarm';
            if (!gpsValid) //未定位优先
            {
                icondir = 'gpsinvalid';
            } else if (!accOn) {
                //acc关
                icondir = 'accoff';
            } else {
                icondir = (speed == 0.0 ? 'speed0' : 'drive');
            }
            break;
        case "2":
        case "0":
            if (!gpsValid) {
                icondir = 'gpsinvalid';
                // iconname = 'normal';  2021/11/25
                if (isFill)
                    iconname = 'full';
                else
                    iconname = 'normal';
            } else if (!accOn) {
                icondir = 'accoff';
                if (isFill)
                    iconname = 'full';
                else
                    iconname = 'normal';
            } else {
                icondir = (speed == 0.0 ? 'speed0' : 'drive');
                if (isFill)
                    iconname = 'full';
                else
                    iconname = 'normal';
            }
            break;
        case "6":
            //停运
            if (!gpsValid) {
                icondir = 'gpsinvalid';
                iconname = 'operateoff';
            } else if (!accOn) {
                icondir = 'accoff';
                iconname = 'operateoff';
            } else {
                icondir = (speed == 0.0 ? 'speed0' : 'drive');
                iconname = 'operateoff';
            }
            break;
        case "5":
            icondir = '';
            iconname = 'offline';
            break;
        case "11":
            icondir = 'speed0';
            iconname = 'alarm';
            break;
        case "12":
            icondir = 'speed0';
            iconname = 'normal';
            break;
        case "13":
            icondir = 'speed0';
            iconname = 'full';
            break;
        case "98":
            //carStatus:98 表示空图标
            iconType = '';
            icondir = '';
            iconname = 'park';
            break;
        case "99":
            //carStatus:99 表示空图标
            iconType = '';
            icondir = '';
            iconname = 'blank';
            break;
    }

    return new MapVehicleIcon(icondir,iconname,direction,iconType);
}

function MapVehicleIcon(icondir, iconname, direction, iconType) {
    iconname = iconname || "";
    direction = direction || "";

    if (typeof (g_crop) != 'undefined' && g_crop == "xinben") {
        //鑫犇所有ACC显示成红色
        if (icondir == "accoff") {
            iconname = "alarm";
        }
    }

    var width = 32
        , height = 32
        , x = -16
        , y = -16;
    var fileExt = (iconType == "top7") ? '.gif' : '.png';

    //兼容旧版本
    if (iconType == "") {//根目录
    } else if (iconType == "1") {
        iconType = "default";
    } else if ((MapParam.vehicleIconConfig == null || MapParam.vehicleIconConfig[iconType] == null) && iconType != 'default' && iconType != 'top7') {
        iconType = 'default';
    }

    var status = (icondir == "" ? "" : (icondir + '_')) + iconname;
    if (iconType == 'default' || iconType == "top7") {
        MapParam.iconRotate = false;
        //默认图标不旋转 取不同的图标
        //对应表匹配
        if (MapParam.vehicleIconConfig != null && MapParam.vehicleIconConfig[iconType] != null) {
            var newFileName = MapParam.vehicleIconConfig[iconType][status];
            if (newFileName != null) {
                var af = newFileName.split('_');
                if (af.length == 2) {
                    icondir = af[0];
                    iconname = af[1];
                } else {
                    icondir = "";
                    iconname = newFileName;
                }
            }
        }

        if (icondir == "drive") {
            var d = Math.round(direction / 22.5);
            if (d >= 16 || d < 0)
                d = 0;

            if (d < 10)
                iconname = iconname + "0" + d.toString();
            else
                iconname = iconname + d.toString();
        }
        //alarm.png or alarm00.png
    } else if (iconType != "") {
        //判断是否是自定义图标(Belong不为null 说明是自定义的)
        if (MapParam.vehicleIconConfig[iconType].Belong) {
            //自定义
            var tmpIconConfig = MapParam.vehicleIconConfig[iconType];
            MapParam.iconRotate = tmpIconConfig["MapIconWhirling"] == 1 ? true : false;
            //自定义图标是否旋转

            if (tmpIconConfig['iconWidth']) {
                //地图上显示图标大小、偏移量
                width = tmpIconConfig['iconWidth'],
                    height = tmpIconConfig['iconHeight'],
                    x = tmpIconConfig['iconOffsetX'],
                    y = tmpIconConfig['iconOffsetY'];
            }

            //因为是驼峰写法  转换一下图标的名字
            let pngName = ""
            switch (iconname) {
                case "normal":
                    pngName = icondir + "Normal"
                    break;
                case "full":
                    pngName = icondir + "Full"
                    break;
                case "alarm":
                    pngName = icondir + "Alarm"
                    break;
                default:
                    pngName = "offline"
            }

            return {
                path: MapParam.serverConfigUrl + "/" + iconType + "/map/" + pngName + fileExt,
                //
                iconSize: {
                    width: width,
                    height: height
                },
                offset: {
                    x: x,
                    y: y
                }
            };
        } else {
            //对应表匹配
            if (MapParam.vehicleIconConfig != null && MapParam.vehicleIconConfig[iconType] != null) {
                MapParam.iconRotate = false;
                //默认图标不旋转
                var tmpIconConfig = MapParam.vehicleIconConfig[iconType];
                var newFileName = tmpIconConfig[status];
                if (newFileName != null) {
                    icondir = newFileName;
                }

                if (tmpIconConfig['iconWidth']) {
                    //新增字段
                    width = tmpIconConfig['iconWidth'],
                        height = tmpIconConfig['iconHeight'],
                        x = tmpIconConfig['iconOffsetX'],
                        y = tmpIconConfig['iconOffsetY'];
                }
            }

            var d = Math.round(direction / 22.5);
            if (d >= 16 || d < 0)
                d = 0;

            if (d < 10)
                iconname = "0" + d.toString();
            else
                iconname = d.toString();
        }
    }

    if (iconType != "") {
        iconType = iconType + "/";
    }

    if (icondir != "") {
        icondir = icondir + "/";
    }

    if (iconType + icondir + iconname + fileExt == "park.png") {
        //停车图标的偏移量特殊处理
        width = 32,
            height = 32,
            x = -16,
            y = -26;
    }

    return {
        path: MapParam.siteRoot + '/images/vehicle/' + iconType + icondir + iconname + fileExt,
        iconSize: {
            width: width,
            height: height
        },
        offset: {
            x: x,
            y: y
        }
    };
}

function MapFlagIcon(iconpath) {
    var iconwidth = 32;
    var iconHeight = 32;

    var p = iconpath.split('/');

    iconpath = p[p.length - 1];

    return {
        path: MapParam.siteRoot + '/images/mapflag/' + iconpath,
        iconSize: {
            width: iconwidth,
            height: iconHeight
        },
        offset: {
            x: -16,
            y: -30
        }
    };
}

MapParam.trackPointIcon = {
    path: MapParam.siteRoot + '/images/poi/poi_blue_smallest.png',
    iconSize: {
        width: 10,
        height: 16
    },
    offset: {
        x: -5,
        y: -14
    }
};
///poiColor:图标颜色 poiLevel为5是特定字符 如"NormalOff"为正常停车图标，
///         1、2、3为"RED"红色 "BLUE"蓝色  4为"START"起点 "END"终点
///poiLevel:图标级别 5为车辆图标，1为大图标，2为中图标，3为小图标, 4为起点终点图标
///isTxtOnImg:是否文字在图标上显示
function MapPoiIcon(poiColor, poiLevel, isTxtOnImg) {
    var icon = {};
    icon.path = MapParam.siteRoot + '/images/poi/';
    if (poiColor == null) {
        poiColor = "RED";
    }
    if (poiLevel == null) {
        poiLevel = 1;
    }
    switch (poiLevel.toString()) {
        //1 默认大图标,2 中图标,3 小图标,4 起点终点类图标,5 车辆图标
        case "1":
            icon.path = icon.path + 'poi_' + poiColor + '.png';
            icon.iconSize = {
                width: 25,
                height: 40
            };
            icon.offset = {
                x: -12,
                y: -37
            };
            break;
        case "2":
            icon.path = icon.path + 'poi_' + poiColor + '_smaller.png';
            icon.iconSize = {
                width: 14,
                height: 22
            };
            icon.offset = {
                x: -7,
                y: -20
            };
            break;
        case "3":
            icon.path = icon.path + 'poi_' + poiColor + '_smallest.png';
            icon.iconSize = {
                width: 10,
                height: 16
            };
            icon.offset = {
                x: -5,
                y: -14
            };
            break;
        case "4":
            icon.path = icon.path + 'poi_' + poiColor + '.png';
            icon.iconSize = {
                width: 25,
                height: 40
            };
            icon.offset = {
                x: -12,
                y: -37
            }
            break;
        case "5":
            if (poiColor == 'NormalOff')
                icon.path = MapParam.siteRoot + '/images/vehicle/default/accoff/normal.png';
            else {
                //poiColor如accoff_normal将下划线_替换为/
                icon.path = MapParam.siteRoot + '/images/vehicle/default/' + poiColor.replace(/_/g, '/') + '.png';
            }
            icon.iconSize = {
                width: 32,
                height: 32
            };
            icon.offset = {
                x: -16,
                y: -16
            }
            break;
        case "6":
            icon.path = icon.path + 'poi_track_point_' + poiColor + '.png';
            icon.iconSize = {
                width: 24,
                height: 24
            };
            icon.offset = {
                x: -12,
                y: -12
            };
            break;
    }
    return icon;
    //向右向下为负
}

function MapWeatherAlarmIcon(type, level) {
    let typeArr = ["暴雪", "暴雨", "冰雹", "大风", "大雾", "大雪", "道路结冰", "地质灾害", "低温", "高温", "寒潮", "寒冷", "降温", "雷暴", "雷电", "雷雨大风", "其他", "强对流", "强降雨", "霜冻", "台风", "雪灾"]

    if (typeArr.indexOf(type) == -1) {
        //过滤掉不需要的预警
        return false;
    }
    var icon = {};
    icon.path = MapParam.siteRoot + '/images/weather/' + type + "/" + level + ".png";

    icon.iconSize = {
        width: 48,
        height: 48
    };
    icon.offset = {
        x: -24,
        y: -24
    };

    return icon;
    //向右向下为负
}

function MapCurrentVehicleIcon() {
    return {
        path: MapParam.siteRoot + '/images/vehicle/CurrentVehicle.gif',
        iconSize: {
            width: 100,
            height: 100
        },
        offset: {
            x: -50,
            y: -50
        }
    };
}

//坐标转换
var GpsConvert = {
    PI: 3.14159265358979324,
    x_pi: 3.14159265358979324 * 3000.0 / 180.0,
    delta: function(lat, lon) {
        // Krasovsky 1940
        //
        // a = 6378245.0, 1/f = 298.3
        // b = a * (1 - f)
        // ee = (a^2 - b^2) / a^2;
        var a = 6378245.0;
        //  a: 卫星椭球坐标投影到平面地图坐标系的投影因子。
        var ee = 0.00669342162296594323;
        //  ee: 椭球的偏心率。
        var dLat = this.transformLat(lon - 105.0, lat - 35.0);
        var dLon = this.transformLon(lon - 105.0, lat - 35.0);
        var radLat = lat / 180.0 * this.PI;
        var magic = Math.sin(radLat);
        magic = 1 - ee * magic * magic;
        var sqrtMagic = Math.sqrt(magic);
        dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * this.PI);
        dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * this.PI);
        return {
            'lat': dLat,
            'lon': dLon
        };
    },

    //WGS-84 to GCJ-02
    WGS84_to_GCJ02: function(wgsLat, wgsLon, noFormat) {
        if (this.outOfChina(wgsLat, wgsLon))
            return {
                'lat': wgsLat,
                'lon': wgsLon
            };

        var d = this.delta(wgsLat, wgsLon);

        if (noFormat)
            return {
                'lat': (parseFloat(wgsLat) + parseFloat(d.lat)),
                'lon': (parseFloat(wgsLon) + parseFloat(d.lon))
            };
        return {
            'lat': this.formatNumber6(parseFloat(wgsLat) + parseFloat(d.lat)),
            'lon': this.formatNumber6(parseFloat(wgsLon) + parseFloat(d.lon))
        };
    },
    //GCJ-02 to WGS-84
    GCJ02_to_WGS84: function(gcjLat, gcjLon, noFormat) {
        if (this.outOfChina(gcjLat, gcjLon))
            return {
                'lat': gcjLat,
                'lon': gcjLon
            };

        var d = this.delta(gcjLat, gcjLon);

        if (noFormat)
            return {
                'lat': (gcjLat - d.lat),
                'lon': (gcjLon - d.lon)
            };
        return {
            'lat': this.formatNumber6(gcjLat - d.lat),
            'lon': this.formatNumber6(gcjLon - d.lon)
        };
    },
    //GCJ-02 to WGS-84 exactly
    GCJ02_to_WGS84_Exact: function(gcjLat, gcjLon, noFormat) {
        var initDelta = 0.01;
        var threshold = 0.000000001;
        var dLat = initDelta
            , dLon = initDelta;
        var mLat = gcjLat - dLat
            , mLon = gcjLon - dLon;
        var pLat = gcjLat + dLat
            , pLon = gcjLon + dLon;
        var wgsLat, wgsLon, i = 0;
        while (1) {
            wgsLat = (mLat + pLat) / 2;
            wgsLon = (mLon + pLon) / 2;
            var tmp = this.WGS84_to_GCJ02(wgsLat, wgsLon);
            dLat = tmp.lat - gcjLat;
            dLon = tmp.lon - gcjLon;
            if ((Math.abs(dLat) < threshold) && (Math.abs(dLon) < threshold))
                break;

            if (dLat > 0)
                pLat = wgsLat;
            else
                mLat = wgsLat;
            if (dLon > 0)
                pLon = wgsLon;
            else
                mLon = wgsLon;

            if (++i > 10000)
                break;
        }

        if (noFormat)
            return {
                'lat': wgsLat,
                'lon': wgsLon
            };
        return {
            'lat': this.formatNumber6(wgsLat),
            'lon': this.formatNumber6(wgsLon)
        };
    },
    //GCJ-02 to BD-09
    GCJ02_to_BD09: function(gcjLat, gcjLon, noFormat) {
        var x = gcjLon
            , y = gcjLat;
        var z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * this.x_pi);
        var theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * this.x_pi);
        bdLon = z * Math.cos(theta) + 0.0065;
        bdLat = z * Math.sin(theta) + 0.006;

        if (noFormat)
            return {
                'lat': bdLat,
                'lon': bdLon
            };
        return {
            'lat': this.formatNumber6(bdLat),
            'lon': this.formatNumber6(bdLon)
        };
    },
    //BD-09 to GCJ-02
    BD09_to_GCJ02: function(bdLat, bdLon, noFormat) {
        var x = bdLon - 0.0065
            , y = bdLat - 0.006;
        var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * this.x_pi);
        var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * this.x_pi);
        var gcjLon = z * Math.cos(theta);
        var gcjLat = z * Math.sin(theta);

        if (noFormat)
            return {
                'lat': gcjLat,
                'lon': gcjLon
            };
        return {
            'lat': this.formatNumber6(gcjLat),
            'lon': this.formatNumber6(gcjLon)
        };
    },
    WGS84_to_BD09: function(wgsLat, wgsLon, noFormat) {
        if (this.outOfChina(wgsLat, wgsLon))
            return {
                'lat': wgsLat,
                'lon': wgsLon
            };

        var d = this.delta(wgsLat, wgsLon);
        var gcjLat = parseFloat(wgsLat) + parseFloat(d.lat);
        var gcjLon = parseFloat(wgsLon) + parseFloat(d.lon);
        //WGS84 to GCJ-02

        var x = gcjLon
            , y = gcjLat;
        var z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * this.x_pi);
        var theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * this.x_pi);
        bdLon = z * Math.cos(theta) + 0.0065;
        bdLat = z * Math.sin(theta) + 0.006;
        //GCJ-02 to BD09

        if (noFormat)
            return {
                'lat': bdLat,
                'lon': bdLon
            };
        return {
            'lat': this.formatNumber6(bdLat),
            'lon': this.formatNumber6(bdLon)
        };
    },
    BD09_to_WGS84: function(bdLat, bdLon, noFormat) {
        var x = bdLon - 0.0065
            , y = bdLat - 0.006;
        var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * this.x_pi);
        var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * this.x_pi);
        //BD09 to GCJ-02
        var gcjLon = z * Math.cos(theta);
        var gcjLat = z * Math.sin(theta);

        if (this.outOfChina(gcjLat, gcjLon))
            return {
                'lat': gcjLat,
                'lon': gcjLon
            };

        var d = this.delta(gcjLat, gcjLon);
        //GCJ-02 to WGS84

        if (noFormat)
            return {
                'lat': (gcjLat - d.lat),
                'lon': (gcjLon - d.lon)
            };
        return {
            'lat': this.formatNumber6(gcjLat - d.lat),
            'lon': this.formatNumber6(gcjLon - d.lon)
        };
    },
    //WGS-84 to Web mercator
    //mercatorLat -> y mercatorLon -> x
    mercator_encrypt: function(wgsLat, wgsLon) {
        var x = wgsLon * 20037508.34 / 180.;
        var y = Math.log(Math.tan((90. + wgsLat) * this.PI / 360.)) / (this.PI / 180.);
        y = y * 20037508.34 / 180.;
        return {
            'lat': y,
            'lon': x
        };
        /*
        if ((Math.abs(wgsLon) > 180 || Math.abs(wgsLat) > 90))
            return null;
        var x = 6378137.0 * wgsLon * 0.017453292519943295;
        var a = wgsLat * 0.017453292519943295;
        var y = 3189068.5 * Math.log((1.0 + Math.sin(a)) / (1.0 - Math.sin(a)));
        return {'lat' : y, 'lon' : x};
        //*/
    },
    // Web mercator to WGS-84
    // mercatorLat -> y mercatorLon -> x
    mercator_decrypt: function(mercatorLat, mercatorLon) {
        var x = mercatorLon / 20037508.34 * 180.;
        var y = mercatorLat / 20037508.34 * 180.;
        y = 180 / this.PI * (2 * Math.atan(Math.exp(y * this.PI / 180.)) - this.PI / 2);
        return {
            'lat': y,
            'lon': x
        };
        /*
        if (Math.abs(mercatorLon) < 180 && Math.abs(mercatorLat) < 90)
            return null;
        if ((Math.abs(mercatorLon) > 20037508.3427892) || (Math.abs(mercatorLat) > 20037508.3427892))
            return null;
        var a = mercatorLon / 6378137.0 * 57.295779513082323;
        var x = a - (Math.floor(((a + 180.0) / 360.0)) * 360.0);
        var y = (1.5707963267948966 - (2.0 * Math.atan(Math.exp((-1.0 * mercatorLat) / 6378137.0)))) * 57.295779513082323;
        return {'lat' : y, 'lon' : x};
        //*/
    },
    // two point's distance
    distance: function(latA, lonA, latB, lonB) {
        var earthR = 6371000.;
        var x = Math.cos(latA * this.PI / 180.) * Math.cos(latB * this.PI / 180.) * Math.cos((lonA - lonB) * this.PI / 180);
        var y = Math.sin(latA * this.PI / 180.) * Math.sin(latB * this.PI / 180.);
        var s = x + y;
        if (s > 1)
            s = 1;
        if (s < -1)
            s = -1;
        var alpha = Math.acos(s);
        var distance = alpha * earthR;
        return distance;
    },
    outOfChina: function(lat, lon) {
        if (lon < 72.004 || lon > 137.8347)
            return true;
        if (lat < 18.15 || lat > 55.8271)
            return true;
        return false;
    },
    transformLat: function(x, y) {
        var ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
        ret += (20.0 * Math.sin(6.0 * x * this.PI) + 20.0 * Math.sin(2.0 * x * this.PI)) * 2.0 / 3.0;
        ret += (20.0 * Math.sin(y * this.PI) + 40.0 * Math.sin(y / 3.0 * this.PI)) * 2.0 / 3.0;
        ret += (160.0 * Math.sin(y / 12.0 * this.PI) + 320 * Math.sin(y * this.PI / 30.0)) * 2.0 / 3.0;
        return ret;
    },
    transformLon: function(x, y) {
        var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
        ret += (20.0 * Math.sin(6.0 * x * this.PI) + 20.0 * Math.sin(2.0 * x * this.PI)) * 2.0 / 3.0;
        ret += (20.0 * Math.sin(x * this.PI) + 40.0 * Math.sin(x / 3.0 * this.PI)) * 2.0 / 3.0;
        ret += (150.0 * Math.sin(x / 12.0 * this.PI) + 300.0 * Math.sin(x / 30.0 * this.PI)) * 2.0 / 3.0;
        return ret;
    },
    formatNumber6: function(num) {
        //保留6位小数
        return Math.round(num * 1000000) / 1000000;
    }
};
//函数别名
GpsConvert.BAIDU_EPSG4326 = GpsConvert.BD09_to_WGS84,
    GpsConvert.BAIDU_EPSG3857 = GpsConvert.BD09_to_GCJ02,
    GpsConvert.EPSG4326_EPSG3857 = GpsConvert.WGS84_to_GCJ02,
    GpsConvert.EPSG4326_BAIDU = GpsConvert.WGS84_to_BD09,
    GpsConvert.EPSG4490_EPSG3857 = GpsConvert.WGS84_to_GCJ02,
    GpsConvert.EPSG4490_BAIDU = GpsConvert.WGS84_to_BD09,
    GpsConvert.EPSG3857_EPSG4326 = GpsConvert.GCJ02_to_WGS84,
    GpsConvert.EPSG3857_BAIDU = GpsConvert.GCJ02_to_BD09;

//直接调用后台接口
var ServerLoctionQuery = function(lon, lat, loctype, mtype, callback) {
    var topServerUrl = MapParam.topMapServerUrl ? MapParam.topMapServerUrl : MapParam.siteRoot;
    try {
        var serveruri = topServerUrl + '/TopMap/geo/regeoc?lng={0}&lat={1}&loctype={2}&mtType={3}';
        var tmpBD = {
            lon: lon,
            lat: lat
        };
        $.ajax({
            url: serveruri.replace("{0}", tmpBD.lon.toFixed(6).toString()).replace("{1}", tmpBD.lat.toFixed(6).toString()).replace('{2}', loctype).replace("{3}", mtype),
            dataType: "jsonp",
            jsonp: "callback",
            type: 'get',
            timeout: 3000,
            success: function(data) {
                if (data.status == 1) {
                    callback(data.address, data.addressComponent ? data.addressComponent : [], data.roadName ? data.roadName : '');
                } else {
                    callback("无数据");
                }
            },
            error: function(e) {
                callback("无数据");
            }
        });
    } catch (err) {
    }
}

var ServerLocationQueryPromise = function(lon, lat, loctype, mtype) {
    return new Promise((resolve,reject)=>{
            var topServerUrl = MapParam.topMapServerUrl ? MapParam.topMapServerUrl : MapParam.siteRoot;
            try {
                var serveruri = topServerUrl + '/TopMap/geo/regeoc?lng={0}&lat={1}&loctype={2}&mtType={3}';
                var tmpBD = {
                    lon: lon,
                    lat: lat
                };
                $.ajax({
                    url: serveruri.replace("{0}", tmpBD.lon.toFixed(6).toString()).replace("{1}", tmpBD.lat.toFixed(6).toString()).replace('{2}', loctype).replace("{3}", mtype),
                    dataType: "jsonp",
                    jsonp: "callback",
                    type: 'get',

                    timeout: 10000,
                    success: function(data) {
                        if (data.status == 1) {
                            resolve(data);
                        } else {
                            reject();
                        }
                    },
                    error: function(e) {
                        reject();
                    }
                });
            } catch (err) {
                reject();
            }
        }
    )
}

var BDLocationQuery = function() {
    /**********************基本参数开始**********************/
    var MCBAND = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0]
        , LLBAND = [75, 60, 45, 30, 15, 0]
        , MC2LL = [[1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2], [-7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37], [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06], [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4], [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 826088.5]]
        , LL2MC = [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [0.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-0.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-0.0003218135878613132, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]];
    /**********************基本参数结束**********************/

    /***********将像素转换成地图坐标***********/
    //point:当前像素 var point = new BMap.Point(x, y);
    //zoom:当前地图缩放级别 var zoom = map.getZoom();
    //center:当前地图可视范围中心点坐标 var center = map.getCenter();
    //bounds:地图可视区域    var bound = map.getSize();
    //var PixelToPoint = function (point, zoom, center, bounds) {
    //    if (!point) {
    //        return;
    //    }
    //    var zoomunit = GetZoomUnits(zoom);
    //    var mercatorLng = center.lng + zoomunit * (point.x - bounds.width / 2);
    //    var mercatorLat = center.lat - zoomunit * (point.y - bounds.height / 2);
    //    var mercatorLngLat = { lng: mercatorLng, lat: mercatorLat };
    //    return mercatorToLngLat(mercatorLngLat)
    //}

    /***********将地图坐标转换成像素***********/
        //point:当前像素 var point = new BMap.Point(x, y);
        //zoom:当前地图缩放级别 var zoom = map.getZoom();
        //center:当前地图可视范围中心点坐标 var center = map.getCenter();
        //bounds:地图可视区域    var bound = map.getSize();
    var PointToPixel = function(point, zoom, center, bounds) {
            // 坐标到像素
            if (!point) {
                return
            }
            point = FormatPoint(point);
            center = FormatPoint(center);
            var units = GetZoomUnits(zoom);
            var x = Math.round((point.lng - center.lng) / units + bounds.width / 2);
            var y = Math.round((center.lat - point.lat) / units + bounds.height / 2);
            return {
                x: x,
                y: y
            }
        }
    //转换缩放级别
    var GetZoomUnits = function(zoom) {
        return Math.pow(2, (18 - zoom));
    }

    var FormatPoint = function(point) {
        var lng_lat, mc;
        point.lng = getLoop(point.lng, -180, 180);
        point.lat = getRange(point.lat, -74, 74);
        lng_lat = {
            lng: point.lng,
            lat: point.lat
        };
        for (var i = 0; i < LLBAND.length; i++) {
            if (lng_lat.lat >= LLBAND[i]) {
                mc = LL2MC[i];
                break
            }
        }
        if (!mc) {
            for (var i = LLBAND.length - 1; i >= 0; i--) {
                if (lng_lat.lat <= -LLBAND[i]) {
                    mc = LL2MC[i];
                    break
                }
            }
        }
        var cE = convertor(point, mc);
        var lng_lat = {
            lng: cE.lng.toFixed(2),
            lat: cE.lat.toFixed(2)
        };
        return lng_lat
    }
    var getLoop = function(lng, a, b) {
        while (lng > b) {
            lng -= b - a
        }
        while (lng < a) {
            lng += b - a
        }
        return lng
    }
    var getRange = function(lat, a, b) {
        if (a != null) {
            lat = Math.max(lat, a)
        }
        if (b != null) {
            lat = Math.min(lat, b)
        }
        return lat
    }
    var convertor = function(point, mc) {
        if (!point || !mc) {
            return
        }
        var lng = mc[0] + mc[1] * Math.abs(point.lng);
        var c = Math.abs(point.lat) / mc[9];
        var lat = mc[2] + mc[3] * c + mc[4] * c * c + mc[5] * c * c * c + mc[6] * c * c * c * c + mc[7] * c * c * c * c * c + mc[8] * c * c * c * c * c * c;
        lng *= (point.lng < 0 ? -1 : 1);
        lat *= (point.lat < 0 ? -1 : 1);
        return {
            lng: lng,
            lat: lat
        }
    }

    var uri = "https://api.map.baidu.com/?qt=rgc&x={0}&y={1}&dis_poi=1000&poi_num=0&language=zh-CN&latest_admin=1&ie=utf-8&oue=0&fromproduct=jsapi&res=api&ak={key}";
    var serveruri = MapParam.siteRoot + '/geo/regeo?lng={0}&lat={1}&loctype={2}&mtype=BaiduMapJs';

    var lang = 'zh-CN';
    if (typeof (g_lang) != 'undefined') {
        switch (g_lang) {
            case "en":
            case "ar":
            case "es":
            case "ru":
                //url
                uri = uri.replace('language=zh-CN', 'language=en');
                lang = 'en';
                break;
            default:
                break;
        }
    }

    var currentKeyIndex = -1;
    var keys = null;
    var getNextKey = function() {
        if (!keys)
            keys = MapParam.baiduJsKey.split(',');
        if (keys.length == 1)
            return keys[0];
        currentKeyIndex++;
        if (keys.length <= currentKeyIndex)
            currentKeyIndex = 0;
        return keys[currentKeyIndex];
    }

    var getAddressFromHttp = function(lon, lat, pType, callback) {
        var tmpBD;
        if (callback == null || typeof (callback) != 'function') {
            return;
        }
        try {
            lon = parseFloat(lon);
            lat = parseFloat(lat);
            if (lon == 0 || lat == 0) {
                callback("无数据");
                return;
            }
            if (pType == "GCJ02")
                tmpBD = GpsConvert.GCJ02_to_BD09(lat, lon);
            else if (pType == 'WGS84')
                tmpBD = GpsConvert.WGS84_to_BD09(lat, lon);
            else
                tmpBD = {
                    lon: lon,
                    lat: lat
                };
            var tPixel = FormatPoint({
                lng: tmpBD.lon,
                lat: tmpBD.lat
            });

            //专线模式
            if (MapParam.isOpenMapInnerIPMode) {
                getAddressFromServer(tmpBD.lon, tmpBD.lat, "BD09", callback);
                return;
            }

            $.ajax({
                url: uri.replace("{0}", tPixel.lng.toString()).replace("{1}", tPixel.lat.toString()).replace("{key}", getNextKey()),
                dataType: "jsonp",
                jsonp: "callback",
                type: 'get',
                timeout: 3000,
                success: function(data) {
                    if (data.result && data.result.error == 0) {
                        var address = data.content.address;
                        if (lang != 'en') {
                            if (data.content.address_detail && data.content.address_detail.street_number != "" && !isNaN(data.content.address_detail.street_number)) {
                                address = address + "号";
                            }
                        }

                        var addressComponent = [];
                        //结构化地址：省，市，区县，乡镇
                        var adc = data.content.address_detail;
                        var roadName = '';
                        //道路名称
                        if (adc) {
                            addressComponent.push(adc.province ? adc.province : '');
                            //省
                            addressComponent.push(adc.city ? adc.city : '');
                            //市
                            addressComponent.push(adc.district ? adc.district : '');
                            //区县
                            //addressComponent.push(adc.township ? adc.township : '');  //乡镇，百度没有提供

                            roadName = adc.street ? adc.street : '';
                        }
                        if (lang == 'en') {
                            callback(address, addressComponent, roadName);
                        } else {
                            callback(address + " " + data.content.poi_desc, addressComponent, roadName);
                        }
                    } else {
                        callback("无数据");
                    }
                },
                error: function(e) {
                    callback("无数据");
                    //可能为客户端访问不到百度接口,从服务端取一次地理位置解析,
                    //getAddressFromServer(tmpBD.lon, tmpBD.lat, "BD09", callback);
                }
            });
        } catch (e) {
            console.error("Baidu getAddress", e);
            callback("无数据");
        }
    };

    var bdGeoc = undefined;
    var bdKeyFail = false;
    //百度key 是否确认无法使用的标志
    var getAddressFromJsApi = function(lon, lat, pType, callback) {
        var tmpBD;
        lon = parseFloat(lon);
        lat = parseFloat(lat);
        if (lon == 0 || lat == 0) {
            callback("无数据");
            return;
        }
        if (pType == "GCJ02")
            tmpBD = GpsConvert.GCJ02_to_BD09(lat, lon);
        else if (pType == 'WGS84')
            tmpBD = GpsConvert.WGS84_to_BD09(lat, lon);
        else
            tmpBD = {
                lon: lon,
                lat: lat
            };

        bdGeoc.getLocation(new BMap.Point(tmpBD.lon,tmpBD.lat), function(data) {
            //console.log(data);
            var address = data.address;
            var addressComponent = [];
            //结构化地址：省，市，区县，乡镇
            var adc = data.addressComponents;
            var roadName = '';
            //道路名称
            if (adc) {
                addressComponent.push(adc.province ? adc.province : '');
                //省
                addressComponent.push(adc.city ? adc.city : '');
                //市
                addressComponent.push(adc.district ? adc.district : '');
                //区县
                addressComponent.push(adc.town ? adc.town : '');
                //乡镇

                roadName = adc.street ? adc.street : '';
            }
            if (lang == 'en') {
                callback(address, addressComponent, roadName);
            } else {
                var poi_desc = "";
                if (data.surroundingPois && data.surroundingPois.length > 0) {
                    var distance = getDistance(data.point.lng, data.point.lat, data.surroundingPois[0].point.lng, data.surroundingPois[0].point.lat);
                    var direction = getDirection(data.point.lng, data.point.lat, data.surroundingPois[0].point.lng, data.surroundingPois[0].point.lat);
                    var poiName = data.surroundingPois[0].title;
                    poi_desc = poiName + direction + (distance > 0 ? distance.toString() + "米" : "");
                }
                callback(address + " " + poi_desc, addressComponent, roadName);
            }

        }, {
            poiRadius: 1000,
            numPois: 1
        });
    }

    var getAddress = function(lon, lat, pType, callback) {
        if (callback == null || typeof (callback) != 'function') {
            return;
        }

        try {
            if (!bdGeoc) {
                //加载geo类
                if (typeof (BMap) == 'object') {
                    bdGeoc = new BMap.Geocoder({
                        extensions_town: true
                    });
                } else {
                    console.log('bdGeoc failed.');
                }
            }

            if (bdGeoc) {
                return getAddressFromJsApi(lon, lat, pType, callback);
            }

            return getAddressFromHttp(lon, lat, pType, callback);

        } catch (e) {
            console.error("Baidu getAddress", e);
            callback("无数据");
        }
    }

    var getAddressFromServer = function(lon, lat, pType, callback) {
        var tmpBD;
        if (pType == "GCJ02")
            tmpBD = GpsConvert.GCJ02_to_BD09(lat, lon);
        else if (pType == 'WGS84')
            tmpBD = GpsConvert.WGS84_to_BD09(lat, lon);
        else
            tmpBD = {
                lon: lon,
                lat: lat
            };
        $.ajax({
            url: serveruri.replace("{0}", tmpBD.lon.toFixed(6).toString()).replace("{1}", tmpBD.lat.toFixed(6).toString()).replace('{2}', pType).replace("{key}", getNextKey()),
            dataType: "jsonp",
            jsonp: "callback",
            type: 'get',
            timeout: 3000,
            success: function(data) {
                if (data.status == 1) {
                    callback(data.address, data.addressComponent ? data.addressComponent : [], data.roadName ? data.roadName : '');
                } else {
                    callback("无数据");
                }
            },
            error: function(e) {
                callback("无数据");
            }
        });
    };

    // 计算两个经纬度之间的距离
    function getDistance(lng1, lat1, lng2, lat2) {
        try {
            let distance = BMapLib.GeoUtils.getDistance(new BMap.Point(lng1,lat1), new BMap.Point(lng2,lat2));
            return Math.round(distance);
        } catch (e) {
            return 0;
        }
    }

    function getAngle(lng1, lat1, lng2, lat2) {
        var x1 = lng1;
        var y1 = lat1;
        var x2 = lng2;
        var y2 = lat2;
        var pi = Math.PI;
        var w1 = y1 / 180 * pi;
        var j1 = x1 / 180 * pi;
        var w2 = y2 / 180 * pi;
        var j2 = x2 / 180 * pi;
        var ret;
        if (j1 == j2) {
            if (w1 > w2)
                return 270;
            //北半球的情况，南半球忽略
            else if (w1 < w2)
                return 90;
            else
                return -1;
            //位置完全相同
        }

        ret = 4 * Math.pow(Math.sin((w1 - w2) / 2), 2) - Math.pow(Math.sin((j1 - j2) / 2) * (Math.cos(w1) - Math.cos(w2)), 2);
        ret = Math.sqrt(ret);
        var temp = (Math.sin(Math.abs(j1 - j2) / 2) * (Math.cos(w1) + Math.cos(w2)));
        ret = ret / temp;
        ret = Math.atan(ret) / pi * 180;
        if (j1 > j2) // 1为参考点坐标
        {
            if (w1 > w2)
                ret += 180;
            else
                ret = 180 - ret;
        } else if (w1 > w2)
            ret = 360 - ret;
        return ret;
    }

    function getDirection(lng1, lat1, lng2, lat2) {
        var angle = getAngle(lng2, lat2, lng1, lat1);
        if ((angle <= 10) || (angle > 350))
            return "东";
        if ((angle > 10) && (angle <= 80))
            return "东北";
        if ((angle > 80) && (angle <= 100))
            return "北";
        if ((angle > 100) && (angle <= 170))
            return "西北";
        if ((angle > 170) && (angle <= 190))
            return "西";
        if ((angle > 190) && (angle <= 260))
            return "西南";
        if ((angle > 260) && (angle <= 280))
            return "南";
        if ((angle > 280) && (angle <= 350))
            return "东南";
        return "附近";

    }

    //function getDirection (lon, lat, plon, plat) {
    //    var direct = '';
    //    if (lon < plon - 0.001)
    //        direct = '西';
    //    else if (lon > plon + 0.001)
    //        direct = '东';

    //    if (lat < plat - 0.001)
    //        direct = direct+ '南';
    //    else if (lat > plat + 0.001)
    //        direct = direct + '北';

    //    if (direct == '')
    //        direct = '附近';
    //    return direct;
    //}

    return {
        getAddress: getAddress
    }
}();

var GDLocationQuery = function() {
    var uri = "https://restapi.amap.com/v3/geocode/regeo?key={key}&s=rsv3&language=zh-CN&location={0},{1}&extensions=all&platform=JS&logversion=2.0&appname=http%3A%2F%2Flocalhost%2FTopMap&csid=F77435A8-B51B-4F8E-B222-A55D8E653BC4&sdkversion=1.4.7";
    var serveruri = MapParam.siteRoot + '/geo/regeo?lng={0}&lat={1}&loctype={2}&mtype=AMapWeb';

    var lang = 'zh-CN';
    if (typeof (g_lang) != 'undefined') {
        switch (g_lang) {
            case "en":
            case "ar":
            case "es":
            case "ru":
                //url
                uri = uri.replace('language=zh-CN', 'language=en');
                lang = 'en';
                break;
            default:
                break;
        }
    }

    var currentKeyIndex = -1;
    var keys = null;
    var getNextKey = function() {
        var key;
        if (!keys) {
            //初始化一次
            keys = MapParam.gdWebKey.split(',');
            var tmpList;
            for (var i in keys) {
                //高德key 如果有安全密钥需要进行处理
                if (keys[i].indexOf('|') >= 0) {
                    tmpList = keys[i].split('|');
                    keys[i] = tmpList[0] + "&jscode=" + tmpList[1];
                }
            }
        }
        if (keys.length == 1)
            return keys[0];

        currentKeyIndex++;
        if (keys.length <= currentKeyIndex)
            currentKeyIndex = 0;
        return keys[currentKeyIndex];
    }

    var getAddress = function(lon, lat, pType, callback) {
        try {
            var tmpGD;
            if (callback == null || typeof (callback) != 'function') {
                return;
            }

            lon = parseFloat(lon);
            lat = parseFloat(lat);

            if (lon == 0 || lat == 0) {
                callback("无数据");
                return;
            }

            if (pType == "WGS84")
                tmpGD = GpsConvert.WGS84_to_GCJ02(lat, lon);
            else if (pType == 'BD09')
                tmpGD = GpsConvert.BD09_to_GCJ02(lat, lon);
            else
                tmpGD = {
                    lon: lon,
                    lat: lat
                };

            //专线模式
            if (MapParam.isOpenMapInnerIPMode) {
                getAddressFromServer(tmpGD.lon, tmpGD.lat, "GCJ02", callback);
                return;
            }

            $.ajax({
                url: uri.replace("{0}", tmpGD.lon.toFixed(6).toString()).replace("{1}", tmpGD.lat.toFixed(6).toString()).replace("{key}", getNextKey()),
                dataType: "jsonp",
                jsonp: "callback",
                type: 'get',
                timeout: 3000,
                success: function(data) {
                    if (data.status == '1') {
                        address = data.regeocode.formatted_address;
                        //地址需要继续完善
                        if (address instanceof Array)
                            address = '无数据';
                        if (lang != 'en') {
                            var pois = data.regeocode.pois;
                            //poi
                            if (pois && pois.length > 0) {
                                var direction = '';
                                switch (pois[0].direction) {
                                    case "东":
                                        direction = "西";
                                        break;
                                    case "西":
                                        direction = "东";
                                        break;
                                    case "南":
                                        direction = "北";
                                        break;
                                    case "北":
                                        direction = "南";
                                        break;
                                    case "东南":
                                        direction = "西北";
                                        break;
                                    case "西南":
                                        direction = "东北";
                                        break;
                                    case "东北":
                                        direction = "西南";
                                        break;
                                    case "西北":
                                        direction = "东南";
                                        break;
                                }
                                var iIndex = address.indexOf(pois[0].name);
                                if (iIndex > 0)
                                    address = address.substr(0, iIndex);

                                address = address + ' ' + pois[0].name + direction + parseFloat(pois[0].distance).toFixed(0) + '米';
                            }
                        }
                        var addressComponent = [];
                        //结构化地址：省，市，区县，乡镇
                        var adc = data.regeocode.addressComponent;
                        if (adc) {
                            addressComponent.push(adc.province && !(adc.province instanceof Array) ? adc.province : '');
                            //省
                            addressComponent.push(adc.city && !(adc.city instanceof Array) ? adc.city : '');
                            //市
                            addressComponent.push(adc.district && !(adc.district instanceof Array) ? adc.district : '');
                            //区县
                            addressComponent.push(adc.township && !(adc.township instanceof Array) ? adc.township : '');
                            //乡镇
                        }

                        var roadName = '';
                        //道路名称
                        var roads = data.regeocode.roads;
                        if (roads && roads.length > 0) {
                            roadName = roads[0].name ? roads[0].name : '';
                        }

                        callback(address, addressComponent, roadName);
                    } else {
                        callback("无数据");
                    }
                },
                error: function(e) {
                    callback("无数据");
                    //可能为客户端访问不到高德接口,从服务端取一次地理位置解析,
                    //getAddressFromServer(tmpGD.lon, tmpGD.lat, "GCJ02", callback);
                }
            });
        } catch (e) {
            console.error("AMap getAddress", e);
            callback("无数据");
        }
    };

    var getAddressFromServer = function(lon, lat, pType, callback) {
        try {
            var tmpGD;
            if (pType == "WGS84")
                tmpGD = GpsConvert.WGS84_to_GCJ02(lat, lon);
            else if (pType == 'BD09')
                tmpGD = GpsConvert.BD09_to_GCJ02(lat, lon);
            else
                tmpGD = {
                    lon: lon,
                    lat: lat
                };
            $.ajax({
                url: serveruri.replace("{0}", tmpGD.lon.toFixed(6).toString()).replace("{1}", tmpGD.lat.toFixed(6).toString()).replace('{2}', "GCJ02").replace("{key}", getNextKey()),
                dataType: "jsonp",
                jsonp: "callback",
                type: 'get',
                timeout: 3000,
                success: function(data) {
                    if (data.status == 1) {
                        callback(data.address, data.addressComponent ? data.addressComponent : [], data.roadName ? data.roadName : '');
                    } else {
                        callback("无数据");
                    }
                },
                error: function(e) {
                    callback("无数据");
                }
            });
        } catch (e) {
            console.error("AMap getAddressFromServer", e);
            callback("无数据");
        }
    };

    return {
        getAddress: getAddress
    }
}();

var JGLocationQuery = function() {
    var uri = "http://gisportal.jiugang.com:8080/dfc/services/geocoding/matching/reverse?x={0}&y={1}&top=1";
    var serveruri = 'http://jiugang.cgopt.cn:8088/topmap/geo/regeo?lng={0}&lat={1}&loctype=WGS84&mtype=JGMap';
    var xmlParse = function(text) {
        var xmlDoc;
        if (typeof (DOMParser) != 'undefined') {
            try //Firefox, Mozilla, Opera, etc.
            {
                var parser = new DOMParser();
                xmlDoc = parser.parseFromString(text, "text/xml");
            } catch (e) {}
        } else {
            try //Internet Explorer
            {
                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = "false";
                xmlDoc.loadXML(text);
            } catch (e) {}
        }

        return xmlDoc;
    };

    var getAddress = function(lon, lat, pType, callback) {
        var tmpWGS84;
        if (callback == null || typeof (callback) != 'function') {
            return;
        }
        try {
            lon = parseFloat(lon);
            lat = parseFloat(lat);
            if (lon == 0 || lat == 0) {
                callback("无数据");
                return;
            }
            if (pType == "GCJ02")
                tmpWGS84 = GpsConvert.GCJ02_to_WGS84(lat, lon);
            else if (pType == 'BD09')
                tmpWGS84 = GpsConvert.BD09_to_WGS84(lat, lon);
            else
                tmpWGS84 = {
                    lon: lon,
                    lat: lat
                };

            $.ajax({
                url: uri.replace("{0}", tmpWGS84.lon.toString()).replace("{1}", tmpWGS84.lat.toString()),
                dataType: "jsonp",
                jsonp: "callback",
                type: 'get',
                timeout: 3000,
                success: function(data) {

                    if (data.result && data.result.error == 0) {
                        var address = data.content.address;
                        if (lang != 'en') {
                            if (data.content.address_detail && data.content.address_detail.street_number != "" && !isNaN(data.content.address_detail.street_number)) {
                                address = address + "号";
                            }
                        }

                        var addressComponent = [];
                        //结构化地址：省，市，区县，乡镇
                        var adc = data.content.address_detail;
                        var roadName = '';
                        //道路名称
                        if (adc) {
                            addressComponent.push(adc.province ? adc.province : '');
                            //省
                            addressComponent.push(adc.city ? adc.city : '');
                            //市
                            addressComponent.push(adc.district ? adc.district : '');
                            //区县
                            //addressComponent.push(adc.township ? adc.township : '');  //乡镇，百度没有提供

                            roadName = adc.street ? adc.street : '';
                        }
                        if (lang == 'en') {
                            callback(address, addressComponent, roadName);
                        } else {
                            callback(address + " " + data.content.poi_desc, addressComponent, roadName);
                        }
                    } else {
                        callback("无数据");
                    }
                },
                error: function(e) {
                    callback("无数据");
                    //可能为客户端访问不到百度接口,从服务端取一次地理位置解析,
                    //getAddressFromServer(tmpBD.lon, tmpBD.lat, "BD09", callback);
                }
            });
        } catch (e) {
            console.error("Baidu getAddress", e);
            callback("无数据");
        }
    };

    var getAddressFromServer = function(lon, lat, pType, callback) {
        try {
            var tmpGD;
            if (pType == "WGS84")
                tmpGD = GpsConvert.WGS84_to_GCJ02(lat, lon);
            else if (pType == 'BD09')
                tmpGD = GpsConvert.BD09_to_GCJ02(lat, lon);
            else
                tmpGD = {
                    lon: lon,
                    lat: lat
                };
            $.ajax({
                url: serveruri.replace("{0}", tmpGD.lon.toFixed(6).toString()).replace("{1}", tmpGD.lat.toFixed(6).toString()).replace('{2}', "GCJ02"),
                dataType: "jsonp",
                jsonp: "callback",
                type: 'get',
                timeout: 3000,
                success: function(data) {
                    if (data.status == 1) {
                        callback(data.address, data.addressComponent ? data.addressComponent : [], data.roadName ? data.roadName : '');
                    } else {
                        callback("无数据");
                    }
                },
                error: function(e) {
                    callback("无数据");
                }
            });
        } catch (e) {
            console.error("AMap getAddressFromServer", e);
            callback("无数据");
        }
    };

    return {
        getAddress: getAddressFromServer
    }
}();

//凯立德
var KLDLocationQuery = function() {
    var uri = "http://api.careland.com.cn/api/v2/rgeo?ak={2}&xytype=1&pn=1&p={0},{1}";
    //xytype：  0 凯立德坐标系 1  wgs84   2 国家加密坐标系
    var currentKeyIndex = -1;
    var keys = null;
    var getNextKey = function() {
        if (!keys)
            keys = MapParam.careLandKey.split(',');
        if (keys.length == 1)
            return keys[0];
        +currentKeyIndex++;
        if (keys.length <= currentKeyIndex)
            currentKeyIndex = 0;
        return keys[currentKeyIndex];
    }

    var getAddress = function(lon, lat, pType, callback) {
        var tmpWGS84;
        if (callback == null || typeof (callback) != 'function') {
            return;
        }
        try {
            lon = parseFloat(lon);
            lat = parseFloat(lat);
            if (lon == 0 || lat == 0) {
                callback("无数据");
                return;
            }
            if (pType == "GCJ02")
                tmpWGS84 = GpsConvert.GCJ02_to_WGS84(lat, lon);
            else if (pType == 'BD09')
                tmpWGS84 = GpsConvert.BD09_to_WGS84(lat, lon);
            else
                tmpWGS84 = {
                    lon: lon,
                    lat: lat
                };

            $.ajax({
                url: uri.replace("{0}", tmpWGS84.lon.toString()).replace("{1}", tmpWGS84.lat.toString()).replace("{2}", getNextKey()),
                dataType: "jsonp",
                jsonp: "callback",
                type: 'get',
                timeout: 3000,
                success: function(data) {
                    if (data.errorCode == "0") {
                        var result = data.results[0]
                        var address = result.detailed_addres
                        if (result.description) {
                            address += result.description
                        }
                        callback(address)
                    } else {
                        callback("无数据")
                    }
                    //if (data.results && data.result.error == 0) {

                    //}
                    //else {
                    //    callback("无数据");
                    //}
                },
                error: function(e) {
                    callback("无数据");

                    //getAddressFromServer(tmpBD.lon, tmpBD.lat, "BD09", callback);
                }
            });
        } catch (e) {
            console.error("Baidu getAddress", e);
            callback("无数据");
        }
    };

    return {
        getAddress: getAddress
    }
}();

//四维地图地理位置解析
var SWLocationQuery = function() {
    var uri = "http://a.qqearth.com:81/SE_RGC2?st=Rgc2&uid={2}&point={0},{1}&output=json&cd=wgs84&adr=address";
    //var uri = "http://map.yiweihang.com/SE_RGC?st=Rgc&uid={2}&point={0},{1}&output=json&cd=wgs84&adr=address";

    var currentKeyIndex = -1;
    var keys = null;
    var getNextKey = function() {
        if (!keys)
            keys = MapParam.swKey.split(',');
        if (keys.length == 1)
            return keys[0];
        currentKeyIndex++;
        if (keys.length <= currentKeyIndex)
            currentKeyIndex = 0;
        return keys[currentKeyIndex];
    }

    var getAddress = function(lon, lat, pType, callback) {
        var tmpWGS84;
        if (callback == null || typeof (callback) != 'function') {
            return;
        }
        try {
            lon = parseFloat(lon);
            lat = parseFloat(lat);
            if (lon == 0 || lat == 0) {
                callback("无数据");
                return;
            }
            if (pType == "GCJ02")
                tmpWGS84 = GpsConvert.GCJ02_to_WGS84(lat, lon);
            else if (pType == 'BD09')
                tmpWGS84 = GpsConvert.BD09_to_WGS84(lat, lon);
            else
                tmpWGS84 = {
                    lon: lon,
                    lat: lat
                };

            $.ajax({
                url: uri.replace("{0}", tmpWGS84.lon.toString()).replace("{1}", tmpWGS84.lat.toString()).replace("{2}", getNextKey()),
                dataType: "jsonp",
                jsonp: "callback",
                type: 'get',
                timeout: 3000,
                success: function(data) {
                    if (data.status == "ok") {
                        var result = data.result;
                        var address = result.district_text.replaceAll(">", "") + result.address;

                        callback(address)
                    } else {
                        callback("无数据")
                    }
                },
                error: function(e) {
                    callback("无数据");
                    //可能为客户端访问不到百度接口,从服务端取一次地理位置解析,
                    //getAddressFromServer(tmpBD.lon, tmpBD.lat, "BD09", callback);
                }
            });
        } catch (e) {
            console.error("Baidu getAddress", e);
            callback("无数据");
        }
    };

    return {
        getAddress: getAddress
    }
}();

var MapCommon = {};
MapCommon.getTicks = function(s) {
    if (s == undefined)
        return 0;
    try {
        s = s.replace(/-/g, '/');
        return new Date(s).getTime();
    } catch (e) {
        return 0;
    }
}
;
var TMapCommon = (function() {
        var me = this;
        this.tileLayerParam = {
            "AMap": {
                urlTemplate: 'https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}',
                subdomains: ['1', '2', '3', '4'],
                minZoom: 4,
                maxZoom: 18,
                zIndex: 1,
                tileRetryCount: 3,
                crossOrigin: 'anonymous',
                renderer: 'canvas',
                //多车轨迹回放 使用webgl 渲染多个地图会卡顿，改为canvas
                forceRenderOnZooming: true,
            },
            "AMap_Sate": [{
                urlTemplate: 'https://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
                subdomains: ['1', '2', '3', '4'],
                zIndex: 1,
                tileRetryCount: 3,
                renderer: 'canvas'
            }, {
                urlTemplate: 'https://webst0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}',
                subdomains: ['1', '2', '3', '4'],
                zIndex: 2,
                tileRetryCount: 3,
                renderer: 'canvas'
            }],
            "AMap_Google": {
                urlTemplate: 'https://mt{s}.google.cn/vt/lyrs=m@225000000&hl=zh-CN&gl=cn&src=app&x={x}&y={y}&z={z}&s=Galile',
                subdomains: ['1', '2', '3', '0'],
                minZoom: 4,
                maxZoom: 19,
                zIndex: 1,
                tileRetryCount: 3,
                renderer: 'canvas'
            },
            "AMap_GoogleSate": [{
                urlTemplate: 'https://mt{s}.google.cn/vt/lyrs=s%40804&hl=zh-CN&gl=cn&src=app&x={x}&y={y}&z={z}&s=Galile',
                subdomains: ['1', '2', '3', '0'],
                minZoom: 4,
                maxZoom: 19,
                zIndex: 1,
                tileRetryCount: 3,
                renderer: 'canvas'
            }, {
                urlTemplate: 'https://mt{s}.google.cn/vt/imgtp=png32&lyrs=h@225000000&hl=zh-CN&gl=cn&src=app&x={x}&y={y}&z={z}&s=Galile',
                subdomains: ['1', '2', '3', '0'],
                minZoom: 4,
                maxZoom: 19,
                zIndex: 2,
                tileRetryCount: 3,
                renderer: 'canvas'
            }],
            "AMap_icttic": {
                urlTemplate: 'http://{s}.qqearth.com:81/engine?st=GetImage&box={x},{y}&lev={z}&type=vect&uid=scdxbd',
                subdomains: ['a', 'b', 'c'],
                zIndex: 1,
                tileRetryCount: 3
            },
            "Tianditu": [{
                tileSystem: [1, -1, -180, 90],
                //urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=vec_c&x={x}&y={y}&l={z}&tk=de0dc270a51aaca3dd4e64d4f8c81ff6',
                urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=vec_c&x={x}&y={y}&l={z}',
                subdomains: ['1', '2', '3', '4', '5'],
                zIndex: 1,
                spatialReference: {
                    projection: 'EPSG:4326'
                },
                tileRetryCount: 3,
                crossOrigin: 'anonymous',
                renderer: 'canvas'
            }, {
                tileSystem: [1, -1, -180, 90],
                //urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=cva_c&x={x}&y={y}&l={z}&tk=de0dc270a51aaca3dd4e64d4f8c81ff6',
                urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=cva_c&x={x}&y={y}&l={z}',
                subdomains: ['1', '2', '3', '4', '5'],
                zIndex: 3,
                spatialReference: {
                    projection: 'EPSG:4326'
                },
                tileRetryCount: 3,
                crossOrigin: 'anonymous',
                renderer: 'canvas'
            }],
            "Tianditu_Sate": [{
                tileSystem: [1, -1, -180, 90],
                //urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=img_c&x={x}&y={y}&l={z}&tk=de0dc270a51aaca3dd4e64d4f8c81ff6',
                urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=img_c&x={x}&y={y}&l={z}',
                subdomains: ['1', '2', '3', '4', '5'],
                zIndex: 1,
                spatialReference: {
                    projection: 'EPSG:4326'
                },
                tileRetryCount: 3,
                renderer: 'canvas'
            }, {
                tileSystem: [1, -1, -180, 90],
                //urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=cia_c&x={x}&y={y}&l={z}&tk=de0dc270a51aaca3dd4e64d4f8c81ff6',
                urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=cia_c&x={x}&y={y}&l={z}',
                subdomains: ['1', '2', '3', '4', '5'],
                zIndex: 2,
                spatialReference: {
                    projection: 'EPSG:4326'
                },
                tileRetryCount: 3,
                renderer: 'canvas'
            }],
            "BMap": {
                //urlTemplate: 'http://online{s}.map.bdimg.com/onlinelabel/?qt=tile&x={x}&y={y}&z={z}&styles=pl',
                urlTemplate: 'https://maponline{s}.bdimg.com/tile/?qt=vtile&x={x}&y={y}&z={z}&styles=pl&scaler=1&from=jsapi2_0',
                subdomains: [0, 1, 2, 3],
                zIndex: 1,
                minZoom: 4,
                maxZoom: 19,
                spatialReference: {
                    projection: 'BAIDU'
                },
                tileRetryCount: 3,
                crossOrigin: 'anonymous',
                renderer: 'canvas',
            },
            "BMap_Sate": [{
                urlTemplate: 'https://maponline{s}.bdimg.com/starpic/?qt=satepc&u=x={x};y={y};z={z};v=009;type=sate&fm=46&v=009',
                subdomains: [0, 1, 2, 3],
                zIndex: 1,
                minZoom: 4,
                maxZoom: 19,
                spatialReference: {
                    projection: 'BAIDU'
                },
                tileRetryCount: 3,
                renderer: 'canvas'
            }, {
                //'urlTemplate': 'http://online{s}.map.bdimg.com/onlinelabel/?qt=tile&x={x}&y={y}&z={z}&styles=pl',
                urlTemplate: 'https://maponline{s}.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=sl&scaler=1&from=jsapi2_0',
                subdomains: [0, 1, 2, 3],
                zIndex: 2,
                minZoom: 4,
                maxZoom: 19,
                spatialReference: {
                    projection: 'BAIDU'
                },
                tileRetryCount: 3,
                renderer: 'canvas'
            }],
            "JiuGang": [{
                tileSystem: [1, -1, -180, 90],
                //urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=vec_c&x={x}&y={y}&l={z}&tk=de0dc270a51aaca3dd4e64d4f8c81ff6',
                urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=vec_c&x={x}&y={y}&l={z}',
                subdomains: ['1', '2', '3', '4', '5'],
                zIndex: 1,
                spatialReference: {
                    projection: 'EPSG:4326'
                },
                tileRetryCount: 3,
                renderer: 'canvas'
            }, {
                tileSystem: [1, -1, -180, 90],
                //urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=cva_c&x={x}&y={y}&l={z}&tk=de0dc270a51aaca3dd4e64d4f8c81ff6',
                urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=cva_c&x={x}&y={y}&l={z}',
                subdomains: ['1', '2', '3', '4', '5'],
                zIndex: 2,
                spatialReference: {
                    projection: 'EPSG:4326'
                },
                tileRetryCount: 3,
                renderer: 'canvas'
            }, {
                tileSystem: [1, -1, -180, 90],
                //urlTemplate: 'http://10.99.110.23:8081/geoesb/proxy/services/maps/rest/9011b45b8a5d4ab4a449b9d1fe726d9b/886e60bb7e014f22a707de23e6f6505d/zxyTileImage.png?z={z}&x={x}&y={y}&width=256&height=256&transparent=true&overlapDisplayed=false',
                urlTemplate: function(x, y, z) {
                    var s = me.scale[z];
                    return MapParam.gjServerUrl + '/geoesb/proxy/services/maps/rest/9011b45b8a5d4ab4a449b9d1fe726d9b/886e60bb7e014f22a707de23e6f6505d/tileImage.png?width=256&height=256&redirect=false&transparent=true&cacheEnabled=true&origin=%7B%22x%22:-180,%22y%22:90%7D&overlapDisplayed=false&scale=' + s + '&x=' + x + '&y=' + y;
                },
                maxZoom: 18,
                minZoom: 10,
                spatialReference: {
                    projection: 'EPSG:4326',
                    fullExtent: {
                        'top': 39.92,
                        'left': 98.16,
                        'bottom': 39.77,
                        'right': 98.36
                    }
                },
                zIndex: 3,
                tileRetryCount: 3,
                renderer: 'canvas'
            }],
            "JiuGang_Sate": [{
                tileSystem: [1, -1, -180, 90],
                //urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=img_c&x={x}&y={y}&l={z}&tk=de0dc270a51aaca3dd4e64d4f8c81ff6',
                urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=img_c&x={x}&y={y}&l={z}',
                subdomains: ['1', '2', '3', '4', '5'],
                zIndex: 1,
                spatialReference: {
                    projection: 'EPSG:4326'
                },
                tileRetryCount: 3
            }, {
                tileSystem: [1, -1, -180, 90],
                //urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=cia_c&x={x}&y={y}&l={z}&tk=de0dc270a51aaca3dd4e64d4f8c81ff6',
                urlTemplate: 'https://t{s}.tianditu.gov.cn/DataServer?T=img_c&x={x}&y={y}&l={z}',
                subdomains: ['1', '2', '3', '4', '5'],
                zIndex: 2,
                spatialReference: {
                    projection: 'EPSG:4326'
                },
                tileRetryCount: 3,
                renderer: 'canvas'
            }, {
                tileSystem: [1, -1, -180, 90],
                //urlTemplate: 'http://10.99.110.23:8081/geoesb/proxy/services/maps/rest/83115edbeac64b578815fb227fffb2d4/886e60bb7e014f22a707de23e6f6505d/zxyTileImage.png?z={z}&x={x}&y={y}&width=256&height=256&transparent=true&overlapDisplayed=false',
                urlTemplate: function(x, y, z) {
                    var s = me.scale[z];
                    return MapParam.gjServerUrl + '/geoesb/proxy/services/maps/rest/83115edbeac64b578815fb227fffb2d4/886e60bb7e014f22a707de23e6f6505d/tileImage.png?width=256&height=256&redirect=false&transparent=true&cacheEnabled=true&origin=%7B%22x%22:-180,%22y%22:90%7D&overlapDisplayed=false&scale=' + s + '&x=' + x + '&y=' + y;
                },
                maxZoom: 18,
                minZoom: 10,
                spatialReference: {
                    projection: 'EPSG:4326',
                    fullExtent: {
                        'top': 39.92,
                        'left': 98.16,
                        'bottom': 39.77,
                        'right': 98.36
                    }
                },
                zIndex: 3,
                tileRetryCount: 3,
                renderer: 'canvas'
            }],
            "Ningbogang": [{
                urlTemplate: 'https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}',
                subdomains: ['1', '2', '3', '4'],
                minZoom: 4,
                maxZoom: 18,
                zIndex: 1,
                tileRetryCount: 3,
                crossOrigin: 'anonymous',
                renderer: 'canvas'
            }, {
                urlTemplate: 'http://47.98.185.125:6080/arcgis/rest/services/%E5%AE%81%E6%B3%A2%E6%B8%AF/MapServer/tile/{z}/{y}/{x}',
                minZoom: 11,
                maxZoom: 18,
                tileRetryCount: 3,
                crossOrigin: 'anonymous',
                renderer: 'canvas',
                spatialReference: {
                    projection: 'EPSG:3857',
                    //坐标转换规则
                    //console.log(map.getProjection().project(new maptalks.Coordinate(121.537975, 29.766565)));
                    //console.log(map.getProjection().project(new maptalks.Coordinate(122.121681, 30.048303)));
                    fullExtent: {
                        'top': 3509761,
                        'bottom': 3473579,
                        'right': 13594524,
                        'left': 13529545
                    }
                },

            }]
        };

        this.trafficLayerParam = {
            "AMap_Traffic": {
                urlTemplate: function(x, y, z) {
                    return MapParam.siteRoot + "/tile/gdtraffic?x=" + x + "&y=" + y + "&z=" + z + "&t=" + (new Date().getTime().toString());
                },
                zIndex: 5,
                maxZoom: 17,
                minZoom: 6,
                background: false
            },
            "BMap_Traffic": {
                //'urlTemplate': 'http://online{s}.map.bdimg.com/onlinelabel/?qt=tile&x={x}&y={y}&z={z}&styles=pl',
                urlTemplate: function(x, y, z) {
                    return 'https://its.map.baidu.com/traffic/TrafficTileService?label=web2D&v=081&smallflow=1&time=' + (new Date().getTime().toString()) + '&x=' + x + '&y=' + y + '&level=' + z;
                },
                //zoomOffset: 1,
                zIndex: 5,
                maxZoom: 18,
                minZoom: 6,
                background: false,
                spatialReference: {
                    projection: 'BAIDU'
                }
            }//有问题
            //,"TxMap_Traffic": {
            //    tileSystem: [1, -1, -180, -85.05112877980659],
            //    urlTemplate: function (x, y, z) {
            //        return ' https://rtt2.map.qq.com/rtt/?times=1&time=' + (new Date().getTime().toString()) + '&x=' + x + '&y=' + (-1 *y).toString() + '&z=' + z;
            //    },
            //    zIndex: 5,
            //    maxZoom: 18,
            //    minZoom: 6,
            //    background: false
            //}
        };

        //宁波港附加图层--马良专版
        this.NingbogangLayerParam = {
            urlTemplate: function(x, y, z) {
                return 'http://47.98.185.125:6080/arcgis/rest/services/%E5%AE%81%E6%B3%A2%E6%B8%AF/MapServer/tile/' + z + '/' + y + '/' + x;
            },
            //urlTemplate: 'http://47.98.185.125:6080/arcgis/rest/services/%E5%AE%81%E6%B3%A2%E6%B8%AF/MapServer/tile/{z}/{y}/{x}',
            minZoom: 11,
            maxZoom: 18,
            tileRetryCount: 3,
            crossOrigin: 'anonymous',
            renderer: 'canvas',
            spatialReference: {
                projection: 'EPSG:3857',
                //坐标转换规则
                fullExtent: {
                    'top': 3519761,
                    'bottom': 3472579,
                    'right': 13595524,
                    'left': 13519545
                }
            },
        }

        this.scale = {
            '2': '6.760654286410619e-9',
            '3': '1.3521308572821239e-8',
            '4': '2.7042617145642478e-8',
            '5': '5.4085234291284955e-8',
            '6': '1.0817046858256991e-7',
            '7': '2.1634093716513982e-7',
            '8': '4.3268187433027964e-7',
            '9': '8.653637486605593e-7',
            '10': '0.0000017307274973211186',
            '11': '0.000003461454994642237',
            '12': '0.000006922909989284474',
            '13': '0.000013845819978568949',
            '14': '0.000027691639957137897',
            '15': '0.000055383279914275794',
            '16': '0.00011076655982855159',
            '17': '0.00022153311965710318',
            '18': '0.00044306623931420635'
        }

        this.getOffset = function(iconSize, aMapOffset) {
            return {
                x: aMapOffset.x + iconSize.width / 2,
                y: aMapOffset.y + iconSize.height
            }
        }

        this.hasTraffic = function(prjCode) {
            return prjCode == 'BAIDU' || prjCode == 'EPSG:3857';
        }

        //获取路况图层信息
        this.getTrafficParam = function(prjCode, style) {
            var filter = (style == "normal") ? {} : {
                cssFilter: 'sepia(100%) invert(90%)'
            };

            if (prjCode == 'BAIDU') {
                return $.extend(this.trafficLayerParam['BMap_Traffic'], filter);
            } else if (prjCode == 'EPSG:3857') {
                return $.extend(this.trafficLayerParam['AMap_Traffic'], filter);
            }

            return null;
        }

        //获取
        /**
         * 根据地图类型获取
         * @param {any} prjCode
         */
        this.getPositionType = function(prjCode) {
            var pType;
            switch (prjCode) {
                case "EPSG:3857":
                    pType = 'GCJ02';
                    break;
                case "BAIDU":
                    pType = 'BD09';
                    break;
                default:
                    pType = 'WGS84';
                    break;
            }
            return pType;

        }
        /**
         * 计算文字高宽（大致）
         * @param {any} str 文字
         * @param {any} wrapChar 换行符
         * @param {any} fontSize 文字大小
         */
        this.getTextSize = function(str, wrapChar, fontSize) {
            var textSize = {
                width: 0,
                height: 0
            };
            var lines = str.split(wrapChar);
            var tmpWidth = 0;
            for (var i in lines) {
                //数字宽度不同
                let numLength = lines[i].replace(/\D/g, '').length;

                tmpWidth = (lines[i].length - numLength) * fontSize + numLength * 8
                // tmpWidth = lines[i].length * fontSize; //文字大概宽度
                if (textSize.width < tmpWidth)

                    textSize.width = tmpWidth;
            }
            if (lines[lines.length - 1] == "") {
                textSize.height = lines = (fontSize + 2) * (lines.length - 1);
            } else {
                textSize.height = lines = (fontSize + 2) * lines.length;
            }
            return textSize;
        }
        this.initTileLang = function(lang) {
            switch (lang) {
                case "en":
                case "ar":
                case "es":
                case "ru":
                    //url
                    this.tileLayerParam.AMap.urlTemplate = this.tileLayerParam.AMap.urlTemplate.replace("lang=zh_cn", "lang=en");
                    this.tileLayerParam.AMap_Sate[1].urlTemplate = this.tileLayerParam.AMap_Sate[1].urlTemplate.replace("lang=zh_cn", "lang=en");
                    this.tileLayerParam.AMap_Google.urlTemplate = this.tileLayerParam.AMap_Google.urlTemplate.replace("&hl=zh-CN&gl=cn", "&hl=en-US&gl=us");
                    this.tileLayerParam.AMap_GoogleSate[0].urlTemplate = this.tileLayerParam.AMap_GoogleSate[0].urlTemplate.replace("&hl=zh-CN&gl=cn", "&hl=en-US&gl=us");
                    this.tileLayerParam.AMap_GoogleSate[1].urlTemplate = this.tileLayerParam.AMap_GoogleSate[1].urlTemplate.replace("&hl=zh-CN&gl=cn", "&hl=en-US&gl=us");
                    break;
                default:
                    break;
            }
        }
        /**
         * 设置图标的文字背景色
         * @param {object} markerOption
         * @param {object} userConfig
         * @param {int} fontSize
         * 文字颜色优先级 markerLabelBgCssClass == 'markerlabel-redfont'> markerOption.textColor > userConfig.textConfig
         */
        this.getSymbol = function(markerOption, userConfig, fontSize) {
            var newOffset = this.getOffset(markerOption.icon.iconSize, markerOption.icon.offset);
            //图标类型
            var markerType = markerOption.type;
            let _userConfig
            //webconfig 中的设置的图标文字背景
            var markerLabelBgCssClass = "";
            if (markerType == 'vehicle') {
                markerLabelBgCssClass = MapParam.vehicleBgClass;
                _userConfig = userConfig && userConfig.vehicle ? userConfig.vehicle : {
                    textColor: "#000",
                    isShowBorder: false
                };
            } else if (markerType == 'flag') {
                markerLabelBgCssClass = MapParam.flagBgClass;
                _userConfig = userConfig && userConfig.flag ? userConfig.flag : {
                    textColor: "#000",
                    isShowBorder: false
                };
            } else if (markerType == 'poi') {
                markerLabelBgCssClass = MapParam.poiBgClass;
                _userConfig = userConfig && userConfig.poi ? userConfig.poi : {
                    textColor: "#000",
                    isShowBorder: false
                };
            }
            var symbol = null;
            if (markerLabelBgCssClass == '') {
                var textSize = this.getTextSize(markerOption.labeltxt, '<br>', fontSize);
                symbol = [{
                    'markerFile': markerOption.icon.path,
                    'markerRotation': MapParam["iconRotate"] ? -parseInt(markerOption.angle) : 0,
                    //图标旋转
                    'markerWidth': markerOption.icon.iconSize.width,
                    'markerHeight': markerOption.icon.iconSize.height,
                    'markerDx': newOffset.x,
                    'markerDy': newOffset.y
                }, {
                    // box's symbol
                    'markerType': 'square',
                    //矩形
                    'markerFill': '#f3f3f3',
                    //填充色
                    'markerFillOpacity': _userConfig.isShowBorder == false ? 0 : 1,
                    //透明度
                    'markerLineColor': '#ccc',
                    //边框颜色
                    'markerLineWidth': _userConfig.isShowBorder == false ? 0 : 1,
                    'markerWidth': textSize.width,
                    //根据文字获取动态宽度
                    'markerHeight': textSize.height,
                    //根据文字获取动态高度
                    'markerDx': newOffset.x,
                    'markerDy': newOffset.y,
                    'markerVerticalAlignment': 'bottom'
                }, {
                    'textName': markerOption.labeltxt,
                    'textWrapCharacter': '<br>',
                    'textSize': fontSize,
                    //字体大小
                    'textFaceName': 'microsoft yahei',
                    'textFill': markerOption.textColor == '' ? _userConfig.textColor : markerOption.textColor,
                    'textWeight': 'bold',
                    'textHaloFill': '#fff',
                    'textHaloRadius': 1,
                    'textDy': newOffset.y + 2,
                    'textVerticalAlignment': 'bottom'
                }]
            } else if (markerLabelBgCssClass == 'markerlabel-writebg') {

                var textSize = this.getTextSize(markerOption.labeltxt, '<br>', fontSize);
                symbol = [{
                    'markerFile': markerOption.icon.path,
                    //'markerType': 'path',
                    //'markerPathWidth': 800,
                    //'markerPathHeight': 800,
                    //'markerPath': {
                    //    "path":"M184 818.1h657c19.2 0 37.1-6.9 50.5-19.4 13.6-12.6 21.1-29.6 21.1-47.8V626.7c0-36.4-32.8-67.2-71.6-67.2H656.4l-19.2-112.3c64.1-36.4 103.7-103.2 103.7-175.5 0-27.6-6-54.6-17.8-80.1-11.4-24.6-27.6-46.8-48.2-65.9-42.6-39.4-98.6-61.1-157.9-61.1-60.2 0-116.8 21.5-159.4 60.4-42.7 39.1-66.3 91.2-66.3 146.7 0 72.3 39.6 139 103.7 175.5l-19.2 112.3H184c-19.2 0-37.1 6.9-50.5 19.4-13.6 12.6-21.1 29.6-21.1 47.8v124.2c0 36.4 32.8 67.2 71.6 67.2z m7.9-180.1h192.2c35 0 65.5-26.7 69.7-60.8l24.7-123.9 0.1-0.4c4-27.7-9.8-53.5-35.9-67.4-42.9-22.8-68.5-64.7-68.5-112.1 0-72.9 64-132.1 142.7-132.1 78.7 0 142.7 58.5 142.7 130.4 0 47.4-25.6 89.3-68.5 112.1-25.5 13.6-40 41.3-35.9 69.1v0.2L580 577.2c4.2 34.1 34.8 60.8 69.8 60.8h183.4v103.4H191.9V638zM887.7 875.9H137.3c-22.1 0-40.2 18.1-40.2 40.2s18.1 40.2 40.2 40.2h750.4c22.1 0 40.2-18.1 40.2-40.2s-18-40.2-40.2-40.2z",
                    //     'fill': '#DE3333',
                    //    'stroke': '#000'
                    //},
                    'markerRotation': MapParam["iconRotate"] ? -parseInt(markerOption.angle) : 0,
                    //图标旋转
                    'markerWidth': markerOption.icon.iconSize.width,
                    'markerHeight': markerOption.icon.iconSize.height,
                    'markerDx': newOffset.x,
                    'markerDy': newOffset.y
                }, {
                    // box's symbol
                    'markerType': 'square',
                    //矩形
                    'markerFill': '#f3f3f3',
                    //填充色
                    'markerFillOpacity': 1,
                    //透明度
                    'markerLineColor': '#ccc',
                    //边框颜色
                    'markerLineWidth': 1,
                    'markerWidth': textSize.width,
                    //根据文字获取动态宽度
                    'markerHeight': textSize.height,
                    //根据文字获取动态高度
                    'markerDx': newOffset.x,
                    'markerDy': newOffset.y,
                    'markerVerticalAlignment': 'bottom'
                }, {
                    'textName': markerOption.labeltxt,
                    'textWrapCharacter': '<br>',
                    'textSize': fontSize,
                    'textFaceName': 'microsoft yahei',
                    'textFill': markerOption.textColor == '' ? _userConfig.textColor : markerOption.textColor,
                    'textWeight': 'bold',
                    'textHaloFill': '#fff',
                    'textHaloRadius': 1,
                    'textDy': newOffset.y + 2,
                    'textVerticalAlignment': 'bottom'
                }]
            } else if (markerLabelBgCssClass == 'markerlabel-redfont') {
                symbol = [{
                    'markerFile': markerOption.icon.path,
                    'markerRotation': MapParam["iconRotate"] ? -parseInt(markerOption.angle) : 0,
                    //图标旋转
                    'markerWidth': markerOption.icon.iconSize.width,
                    'markerHeight': markerOption.icon.iconSize.height,
                    'markerDx': newOffset.x,
                    'markerDy': newOffset.y
                }, {
                    'textName': markerOption.labeltxt,
                    'textWrapCharacter': '<br>',
                    'textSize': fontSize,
                    //字体大小fontSize == "" ? 12 : fontSize
                    'textFaceName': 'microsoft yahei',
                    'textFill': 'red',
                    'textWeight': 'bold',
                    'textHaloFill': '#fff',
                    'textHaloRadius': 1,
                    'textDy': newOffset.y + 2,
                    'textVerticalAlignment': 'bottom'
                }]
            }

            return symbol
        }

        return this;
    }
)();

if (typeof (g_lang) != 'undefined') {
    TMapCommon.initTileLang(g_lang);
}
MapParam.apiType = 'TMap';
//酒钢地图瓦片服务器特殊处理，通过服务器本机的8087 Nginx反向代理访问
MapParam.gjServerUrl = MapParam.siteRoot.toLowerCase().replace(':8088', ':8087');
;/**
 * 描述: 地图哈希表
 * 作者: liuxf
 * 版本: v1.0 build 2017-07-19 by liuxf
 * 日志:
 * V1.0 2017-07-19 初始版本
 */
function HashTable() {
    var count = 0;
    var entry = new Object();
    this.getHashTable = function() {
        return entry;
    }
    this.add = function(key, value) {
        if (!this.containsKey(key)) {
            count++;
        }
        entry[key] = value;
    }
    this.getValue = function(key) {
        return this.containsKey(key) ? entry[key] : null;
    }
    this.remove = function(key) {
        if (this.containsKey(key) && (delete entry[key])) {
            count--;
        }
    }
    this.containsKey = function(key) {
        return (key in entry);
    }
    this.containsValue = function(value) {
        for (var prop in entry) {
            if (entry[prop] == value) {
                return true;
            }
        }
        return false;
    }
    this.getValues = function() {
        var values = new Array();
        for (var prop in entry) {
            values.push(entry[prop]);
        }
        return values;
    }
    this.getKeys = function() {
        var keys = new Array();
        for (var prop in entry) {
            keys.push(prop);
        }
        return keys;
    }
    this.getCount = function() {
        return count;
    }
    this.clear = function() {
        count = 0;
        entry = new Object();
    }
}
;/// <reference path="../Map/jquery.min.js" />
/// <reference path="../Map/mapcommon.js" />
/// <reference path="../Map/hashtable.js" />
/// <reference path="./TMapCommon.js" />
/// <reference path="../lib/maptalks.js" />

/*const { map } = require("jquery");*/

/**
 * 描述: MapTalks API对外接口
 * 作者: liuxf
 * 版本: v1.0 build 2020-09-22 by liuxf
 */
var TMapApi = function() {
    //#region 全局变量
    this.apiName = "TMap";
    this.initCompleted = false;
    var mapObj = null;
    var placeSearch = null;
    //点覆盖物组 二位数组 [type,HashTable]， HashTable[key,marker]
    //type: vehicle、flag、poi
    var _markerType = ['vehicle', 'flag', 'poi'];
    var _vLayers = {
        'vehicle': {
            id: 'vehicle',
            name: '车辆',
            order: 10,
            zIndex: 100,
            layer: null,
            clusterLayer: null,
            cluster: true,
            maxClusterZoom: 15
        },
        'flag': {
            id: 'flag',
            name: '标注',
            order: 20,
            zIndex: 100,
            layer: null,
            clusterLayer: null,
            cluster: true,
            maxClusterZoom: 16
        },
        'poi': {
            id: 'poi',
            name: 'POI',
            order: 30,
            zIndex: 100,
            layer: null,
            clusterLayer: null,
            cluster: false
        },
        'polyline': {
            id: 'polyline',
            name: '路线',
            order: 40,
            zIndex: 90,
            layer: null,
            clusterLayer: null,
            cluster: false
        },
        'polygon': {
            id: 'polygon',
            name: '区域',
            order: 50,
            zIndex: 90,
            layer: null,
            clusterLayer: null,
            cluster: false
        },
        'temp': {
            id: 'temp',
            name: '临时',
            order: 60,
            zIndex: 100,
            layer: null,
            clusterLayer: null,
            cluster: false
        }
        //'vehicle': { id: 'vehicle', name: '车辆', order: 10, zIndex: -90, layer: null, clusterLayer: null, cluster: true, maxClusterZoom: 15 },
        //'flag': { id: 'flag', name: '标注', order: 20, zIndex: -90, layer: null, clusterLayer: null, cluster: true, maxClusterZoom: 16 },
        //'poi': { id: 'poi', name: 'POI', order: 30, zIndex: -90, layer: null, clusterLayer: null, cluster: false },
        //'polyline': { id: 'polyline', name: '路线', order: 40, zIndex: -100, layer: null, clusterLayer: null, cluster: false },
        //'polygon': { id: 'polygon', name: '区域', order: 50, zIndex: -100, layer: null, clusterLayer: null, cluster: false },
        //'temp': { id: 'temp', name: '临时', order: 60, zIndex: -90, layer: null, clusterLayer: null, cluster: false }
    };

    var markerArray = {};
    var circleList = new HashTable();
    var polygonList = new HashTable();
    var polylineList = new HashTable();
    var polylineEditerList = new HashTable();
    var circleEditerList = new HashTable();
    var polygonEditerList = new HashTable();

    var _trackList = {};
    //vehicleId为key
    //气泡框
    var _infoWindow = null;
    var _infoWindowObjId = "";
    //车辆点聚合
    var _clusterList = {};

    var PI = 3.141592653;

    //marker更新变量缓存
    var _HandlingMarkers = [];
    var _iHandlingWaitTime = 2000;
    var _drawingMarkers = {};
    var _updateingMarkers = {};
    var _removeingMarkers = {};

    var mousetool, distanceTool, areaTool;
    //鼠标工具、测距工具、面积量算工具
    var _currVehicleTimeout = null;
    //取消当前车定时器
    var _handleMarkersTimeout = null;
    //当前车相关
    var _currVehicleBgMarker = null;
    //当前车的背景-marker
    var _currVehicleId = null;
    //当前车Id
    var _currVehicleMarker = null;
    //当前车marker

    //var _currentLabelList = []; //鼠标工具需要画图需增加的label 圆形测量、矩形测量使用

    /***** 自定义鼠标画线 变量*****/
    var _drawLineClickListener, _drawLineMouseMoveListener, _drawLineDoubleClickListener, _drawLineRightClickListener;
    var _drawLineCallback;
    var _drawnLineArr, _drawingLine, _movingLine, _getLineIndex = 0;

    var _mapApi = this;
    this.mouseCurrCursor = 'default';
    //当前鼠标tool
    _mouseCallback = null;
    //当前鼠标tool的回调事件
    this.currentPoint = null;
    //当前点击的点
    this.currentZoomBox = null;
    //拉框信息
    this.currentSketchPoints = null;
    //多个点（多边形区域/路线）
    this.clickedVehicleId = null;
    //当前点击的车辆ID
    this.isMapClicked = true;

    //this.isShowVehicleInfoWindow = true;
    this.isShowCurrVehicleBg = true;

    var _bTrackMode = false;
    //是否画轨迹模式，地图全局 画轨迹模式 此模式下不进行车辆聚合，快速画车
    var _container;
    //事件
    var _clickCallback = null
        , _rightClickCallback = null;
    var _trackPointCallback = null
        , _cluserRightClickCallback = null;

    var _defaultMapOpt = {
        style: 'normal',
        //地图样式 参考地址：https://lbs.amap.com/api/javascript-api/guide/map/map-style/
        tool: 'normal'//tool目前支持normal、none
    }, _mapOpt;

    //当前投影类型Code, 外部投影坐标
    var _currentPrjCode = 'EPSG:3857';
    const _outPrjCode = 'EPSG:4326';
    const _gcjPrjCode = 'EPSG:3857';

    //pengh 20210401 轨迹线默认宽度
    var defaultTrackLineWidth = 2
    //#endregion

    //是否显示轨迹方向
    var showTrackDirction = false;

    //zoomContral 控件
    var zoomControl = null;

    //地图工具状态
    var mapToolStatus = {
        //traffic: "off",
        cluster: "off",
        //weatherAlarm: "off",
        layer: {
            vehicle: true,
            flag: true,
            poi: true,
            polyline: true,
            polygon: true,
            traffic: false,
            weatherAlarm: false,
            ningbogang: false
        },
        mapCopyRight: MapParam.mapCopyRight
    }

    //#region TMapApi

    //#endregion

    //获取地图对象
    this.getMapObj = function() {
        return mapObj;
    }

    //加载EasyUI 所需的css 和js
    this.initMapPopEvent = function(jsUrl, cssUrl) {

        let doc = document.createElement("script")
        doc.setAttribute("type", "text/javascript")
        doc.setAttribute("src", jsUrl)
        document.body.appendChild(doc)

        let element = document.createElement("link")
        element.setAttribute("rel", "stylesheet")
        element.setAttribute("type", "text/css")
        element.setAttribute("href", cssUrl)
        document.body.appendChild(element)

    }

    //#region 地图初始化
    //地图初始化
    this.init = function(container, lon, lat, zoom, mapOpt) {
        //opt处理
        _mapOpt = mapOpt = _initMapOpt(mapOpt);

        var opt = {
            center: [lon, lat],
            zoom: zoom,
            //centerCross:true,
            minZoom: 4,
            maxZoom: 18,
            dragRotate: false,
            dragPitch: false,
            seamlessZoom: false,
            //关闭小数层级
            zoomAnimation: false,
            //关闭这个  不然放大缩小 有bug
            panAnimation: false,
            //关闭地图移动动画（修复bug B2022051900162）
            //scrollWheelZoom:false,
            //zoomControl: (mapOpt.tool == 'none' || mapOpt.tool=="simple") ? false : {
            //    'position': 'top-left',
            //    'slider': true,
            //    'zoomLevel': true
            //},   //缩放控件
            scaleControl: mapOpt.tool != 'none',
            //比例尺
            overviewControl: mapOpt.tool == 'none' ? false : {
                'maximize': false
            },
            //鹰眼
            attribution: false,
            //版权-审图号
            baseLayer: _initDefaultLayersAndProjection(mapOpt.style),
            //基础地图
            spatialReference: {
                projection: _currentPrjCode
            }
        };

        mapObj = new maptalks.Map(container,opt);
        _container = container;
        ////初始化参数
        for (i in _markerType) {
            markerArray[_markerType[i]] = new HashTable();
            _drawingMarkers[_markerType[i]] = new HashTable();
            _updateingMarkers[_markerType[i]] = new HashTable();
            _removeingMarkers[_markerType[i]] = new HashTable();
        }

        _initLayers();

        //地图信息窗
        _infoWindow = new maptalks.ui.InfoWindow({
            autoPan: true,
            //set it to false if you don't want the map to do panning animation to fit the opened window.
            autoOpenOn: false,
            autoCloseOn: 'click',
            //点击地图自动关闭信息窗
            animation: false,
            animationDuration: 0,
            //eventsPropagation:true, //设置 信息窗体中的事件会失效 whether stop ALL events' propagation.
            eventsToStop: "mousewheel wheel",
            //信息窗体  鼠标滚轮事件不冒泡   火狐 wheel   其他mousewheel
            width: 'auto',
            autoPanDuration: -1,
            //取消移动动画
            dx: 4,
            //横向x偏移
            dy: -40 //纵向y偏移 -20
        }).addTo(mapObj);

        _initCustomControls();

        //绘图工具，支持 Point, LineString, Polygon, Circle, Ellipse, Rectangle, ArcCurve, QuadBezierCurve, CubicBezierCurve
        mousetool = new maptalks.DrawTool({
            mode: 'Point',
            once: false,
            blockGeometryEvents: true
        }).addTo(mapObj).disable();

        mousetool.on('drawend', _mouseToolDrawComplete);
        _handleMarkersTimeout = setTimeout(_execHandleMarkers, _iHandlingWaitTime);
        //定时画标记

        mapObj.on('spatialreferencechange', _onSpatialReferenceChange);

        if (MapParam.isShowVehicleRealTrack) {
            //小尾巴监听缩放级别改变事件
            mapObj.on('zoomend', _zoomChangeEvent);
        }

        _initMapEvent();

        this.initCompleted = true;

        //window.addEventListener('resize', () => {
        //    //重新加载地图尺寸
        //    console.log("map resize")
        //    mapObj.checkSize();
        //})

    }

    //初始化opt
    function _initMapOpt(mapOpt) {
        mapOpt = $.extend({}, _defaultMapOpt, mapOpt);
        if (mapOpt.style == '')
            mapOpt.style = 'normal';
        if (mapOpt.tool == '')
            mapOpt.tool = 'normal';
        return mapOpt;
    }

    function _initLayers() {
        _vLayers['vehicle'].cluster = true;
        _vLayers['vehicle'].maxClusterZoom = MapParam.isOpenVehicleCluser ? MapParam.vehicleCluserMaxZoom : 1;
        //关闭聚合功能为将MaxZoom设置为1
        _vLayers['vehicle'].minClusterSize = MapParam.vehicleClusterMinSize;
        _vLayers['vehicle'].clusterSymbol = {
            'markerFile': {
                property: 'count',
                type: 'interval',
                stops: [[0, MapParam.siteRoot + '/images/comm/m1.png'], [9, MapParam.siteRoot + '/images/comm/m2.png'], [99, MapParam.siteRoot + '/images/comm/m3.png'], [999, MapParam.siteRoot + '/images/comm/m4.png'], [9999, MapParam.siteRoot + '/images/comm/m5.png']]
            },
            'markerWidth': {
                property: 'count',
                type: 'interval',
                stops: [[0, 53], [9, 56], [99, 66], [999, 78], [9999, 90]]
            },
            'markerHeight': {
                property: 'count',
                type: 'interval',
                stops: [[0, 53], [9, 56], [99, 66], [999, 78], [9999, 90]]
            },
            'markerDy': {
                property: 'count',
                type: 'interval',
                stops: [[0, 26], [9, 28], [99, 33], [999, 39], [9999, 45]]
            }
        };
        _vLayers['vehicle'].clusterTextSymbol = {
            'textFaceName': 'microsoft yahei, sans-serif',
            'textSize': 13
        };

        _vLayers['flag'].cluster = true;
        _vLayers['flag'].maxClusterZoom = MapParam.isOpenFlagCluser ? 16 : 1;
        //关闭聚合功能为将MaxZoom设置为1
        _vLayers['flag'].minClusterSize = 5;
        _vLayers['flag'].clusterSymbol = {
            'markerFile': MapParam.siteRoot + '/images/comm/flag.png',
            'markerWidth': 32,
            'markerHeight': 32
        };
        _vLayers['flag'].clusterTextSymbol = {
            'textFaceName': 'microsoft yahei, sans-serif',
            'textSize': 13,
            'textDy': 8
        };

        for (var key in _vLayers) {
            var obj = _vLayers[key];
            if (obj.cluster) {
                var opt = {
                    zIndex: obj.zIndex,
                    maxClusterZoom: obj.maxClusterZoom,
                    minClusterSize: obj.minClusterSize,
                    maxClusterRadius: 100,
                    geometryEvents: true
                };

                if (obj.clusterSymbol)
                    opt.symbol = obj.clusterSymbol;
                if (obj.clusterTextSymbol)
                    opt.textSymbol = obj.clusterTextSymbol;
                if (obj.drawClusterText != undefined)
                    opt.drawClusterText = obj.drawClusterText;

                obj.clusterLayer = new maptalks.ClusterLayer(key + 'cluster',null,opt).addTo(mapObj);
                _clusterList[key] = obj.clusterLayer;
            }

            obj.layer = new maptalks.VectorLayer(key,null,{
                zIndex: obj.zIndex
            }).addTo(mapObj);
        }
    }

    function _initMapEvent() {
        if (1 == 1) {
            //var render = new maptalks.renderer.CanvasRenderer();
            //mapObj.on('baselayerload', function () {
            //    console.log("baselayerload")
            //})

            //mapObj.on('baselayerchangeend', function () {
            //    console.log("baselayerchangeend")
            //})

            //mapObj.on('resize', function () {
            //    var container = mapObj.getContainerExtent()
            //    if (container.xmax == 0) {
            //        console.log("隐藏")
            //    } else {
            //        console.log("显示")
            //        mapObj.checkSize();
            //    }
            //    //console.log("setCanvasUpdated", render.setCanvasUpdated())
            //    //console.log("render", render.setToRedraw())
            //})

            // 选择需要观察变动的节点
            const targetNode = document.getElementById('map');
            // 观察器的配置（需要观察什么变动）
            const config = {
                attributes: true,
                subtree: true
            };
            // childList: true, subtree: true
            // 当观察到变动时执行的回调函数
            const callback = function(mutationsList, observer) {
                // Use traditional 'for loops' for IE 11
                for (let mutation of mutationsList) {
                    if (mutation.type === 'attributes') {
                        if (mutation.target.outerHTML.indexOf('<canvas') == 0 && mutation.attributeName == 'style') {
                            if (_infoWindow && _infoWindow.isVisible()) {
                                let lnglat = _infoWindow._coordinate
                                var p = _coordConvert(lnglat.y, lnglat.x, _currentPrjCode, _gcjPrjCode);
                                _getAddressFromServer(p.lon, p.lat, function(result) {
                                    try {
                                        if (_infoWindow.content) {
                                            //获取id
                                            _infoWindow.content = _infoWindow.content.replace("正在解析地理位置......", result)
                                            _infoWindow.show(_lnglat)
                                        }
                                    } catch (e) {
                                    }

                                });
                                if ($.parser) {
                                    $.parser.parse();
                                    //调用easyUI 的方法   重新渲染 cgo 加载js
                                }
                            }
                        }
                    }
                }
            };

            // 创建一个观察器实例并传入回调函数
            const observer = new MutationObserver(callback);

            // 以上述配置开始观察目标节点
            observer.observe(targetNode, config);
        }

        //点击事件
        //聚合点点击事件 和聚合点右键事件存在问题 需要重写
        mapObj.on('click', function(e) {
            var coord = e.coordinate;
            var opt = {
                onlyCluster: true
            };
            var cluster;
            var zoom = mapObj.getZoom();
            //var fired = false;
            for (var key in _clusterList) {
                if (zoom > _clusterList[key].options["maxClusterZoom"] || !_clusterList[key].isVisible())
                    continue;
                cluster = _clusterList[key].identify(coord, opt);
                if (cluster != null && cluster.center) {
                    //当鼠标是漫游的时候  才可以点击聚合点放大  工单号 T2022120200024
                    if (_mapApi.mouseCurrCursor == 'default' || _mapApi.mouseCurrCursor == 'pan') {
                        mapObj.setCenterAndZoom(cluster.center, zoom + 2);
                        fired = true;
                        break;
                    }

                }
            }
            //if (_clickCallback) {
            //    var lonlat = _coordConvertOut(e.coordinate.y, e.coordinate.x);
            //    _clickCallback([e.containerPoint.x, e.containerPoint.y], [lonlat.lon, lonlat.lat], 'click');
            //}
        });

        //右键事件
        mapObj.on('contextmenu', function(e) {
            var coord = e.coordinate;
            var fired = false;

            if (MapParam.enableCluserRightClick) {
                var opt = {
                    onlyCluster: true
                };
                var cluster;
                var zoom = mapObj.getZoom();

                if (zoom <= _clusterList['vehicle'].options["maxClusterZoom"] && _clusterList['vehicle'].isVisible()) {
                    cluster = _clusterList['vehicle'].identify(coord, opt);
                    if (cluster != null && cluster.center) {
                        _onCluserRightClick(e.containerPoint, cluster);
                        //return false;
                        fired = true;
                    }
                }
            }

            if (!fired && _rightClickCallback) {
                var lonlat = _coordConvertOut(e.coordinate.y, e.coordinate.x);

                //获取周围60px 像素距离的顶点
                let zoom = mapObj.getZoom()
                var pixel = mapObj.coordinateToContainerPoint(e.coordinate, zoom)
                //东北点坐标
                let nePixel = new maptalks.Point(pixel.x + 60,pixel.y - 60)
                var nelnglat = mapObj.containerPointToCoordinate(nePixel);
                //西南坐标
                let swPixel = new maptalks.Point(pixel.x - 60,pixel.y + 60)
                var swlnglat = mapObj.containerPointToCoordinate(swPixel);

                var minPoint = _coordConvertOut(swlnglat.y, swlnglat.x);
                //左下角的点
                var maxPoint = _coordConvertOut(nelnglat.y, nelnglat.x);
                //右上角的点

                _rightClickCallback([e.containerPoint.x, e.containerPoint.y], [lonlat.lon, lonlat.lat], [[minPoint.lon, minPoint.lat], [maxPoint.lon, maxPoint.lat]], 'rightclick');
            }
        });

        //mouseup事件 当地图点击事件
        mapObj.on('mouseup', function(e) {
            if (_clickCallback) {
                var lonlat = _coordConvertOut(e.coordinate.y, e.coordinate.x);
                _clickCallback([e.containerPoint.x, e.containerPoint.y], [lonlat.lon, lonlat.lat], 'click');
            }
        });
    }

    function _initCustomControls() {
        if (_mapOpt.tool != 'none' && _mapOpt.tool != 'simple') {
            //tool == none 则不显示任何工具
            _initControlContainer();
            _initCluserControl();
            _initZoomControl();
            if (MapParam.isShowLayerControl) {
                _initLayerSwitchControl();
                //路况和天气图层加入  马良专版图层加入（宁波港）
            }
        }
    }

    //设置地图工具模式；
    this.setToolMode = function(type) {
        if (type == "default") {
            showCustomMapTool();
        } else if (type == 'simple') {
            hideCustomMapTool();
        } else {
            hideCustomMapTool();
        }
    }

    function _initZoomControl() {
        zoomControl = new maptalks.control.Zoom({
            'position': 'top-left',
            'slider': true,
            'zoomLevel': true
        }).addTo(mapObj)
    }

    this.getToolStatus = function() {
        return mapToolStatus;
    }

    //#endregion

    //#region 点击事件\缩放级别改变事件
    /**
     * 聚合点右键事件
     * @param {any} e
     */
    function _onCluserRightClick(containerPoint, cluster) {
        if (_cluserRightClickCallback != null && containerPoint != null && cluster != null) {
            var keyList = [];
            var markers = cluster.children;
            for (var i in markers) {
                keyList.push(_getExtData(markers[i]).key);
            }

            var lonlat = _coordConvertOut(cluster.center.y, cluster.center.x);
            _cluserRightClickCallback([containerPoint.x, containerPoint.y], [lonlat.lon, lonlat.lat], 'cluserrightclick', keyList);

        }
    }

    //缩放级别改变事件
    function _zoomChangeEvent() {
        if (!MapParam.isShowVehicleRealTrack)
            return;
        var currZoom = mapObj.getZoom();
        if (currZoom <= MapParam.vehicleCluserMaxZoom) {
            //需要隐藏所有小尾巴
            var tmpArray = _vlineList.getHashTable();
            for (var i in tmpArray) {
                if (tmpArray[i].getLayer() != null)
                    tmpArray[i].remove();
            }
        } else {
            //显示所有小尾巴
            var tmpArray = _vlineList.getHashTable();
            for (var i in tmpArray) {
                if (tmpArray[i].getLayer() == null)
                    tmpArray[i].addTo(_vLayers['polyline'].layer);
            }
        }
    }

    /**
     * 地图点击事件
     * @param {any} callback 回调函数，参数([x,y],[lon,lat],'click')
     */
    this.onClick = function(callback) {
        if (callback != null) {
            _clickCallback = callback;
        }
        return;
        if (_clickEvent != null) {
            mapObj.off('click', _clickEvent);
        }

        _clickEvent = function(e) {
            if (e != null && e.containerPoint && e.coordinate) {
                var lonlat = _coordConvertOut(e.coordinate.y, e.coordinate.x);
                callback([e.containerPoint.x, e.containerPoint.y], [lonlat.lon, lonlat.lat], 'click');
            }
        }
        mapObj.on('click', _clickEvent);
    }
    /**
     * 地图右键点击事件
     * @param {any} callback 回调函数，参数([x,y],[lon,lat],'rightclick')
     */
    this.onRightClick = function(callback) {
        if (callback != null) {
            _rightClickCallback = callback;
        }
        return;
        if (_rightClickEvent != null) {
            mapObj.off('contextmenu', _rightClickEvent);
        }

        _rightClickEvent = function(e) {
            if (e != null && e.containerPoint && e.coordinate) {
                var lonlat = _coordConvertOut(e.coordinate.y, e.coordinate.x);

                //获取周围60px 像素距离的顶点
                let zoom = mapObj.getZoom()
                var pixel = mapObj.coordinateToContainerPoint(zoom, e.coordinate)
                //东北点坐标
                let nePixel = new maptalks.Point(pixel.x + 60,pixel.y - 60)
                var nelnglat = mapObj.containerPointToCoordinate(nePixel);
                //西南坐标
                let swPixel = new maptalks.Point(pixel.x - 60,pixel.y + 60)
                var swlnglat = mapObj.containerPointToCoordinate(swPixel);

                var minPoint = _coordConvertOut(swlnglat.y, swlnglat.x);
                //左下角的点
                var maxPoint = _coordConvertOut(nelnglat.y, nelnglat.x);
                //右上角的点

                callback([e.containerPoint.x, e.containerPoint.y], [lonlat.lon, lonlat.lat], [[minPoint.lon, minPoint.lat], [maxPoint.lon, maxPoint.lat]], 'rightclick');
            }
        }
        mapObj.on('contextmenu', _rightClickEvent);
    }
    /**
     * 聚合点右键点击事件
     * @param {any} callback 回调函数，参数([x,y],[lon,lat],'cluserrightclick',[id1,id2,...])
     */
    this.onCluserRightClick = function(callback) {
        if (callback != null) {
            _cluserRightClickCallback = callback;
        }
    }

    this.onTrackPointClick = function(callback) {
        //轨迹点点击事件 callback参数-车ID,轨迹index
        if (callback != null) {
            _trackPointCallback = callback;
        }
    }

    /**
     * 地图SpatialReference变化，用于切换不同坐标系的处理
     * @param {any} e
     */

    //投影坐标改变
    function _onSpatialReferenceChange(e) {
        //e.old, e.new
        var oldCode = e.old ? e.old.projection : _currentPrjCode
            , newCode = e.new ? e.new.projection : _gcjPrjCode;

        //console.debug('_onSpatialReferenceChange', oldCode, newCode);
        if (oldCode == newCode)
            return;

        _currentPrjCode = newCode;
        //若有显示实时路况则需要重置
        _trafficeReset();

        var layers = mapObj.getLayers(function(layer) {
            return (layer instanceof maptalks.VectorLayer);
        });

        //改变所有图层的几何图形
        for (var i in layers) {
            var geos = layers[i].getGeometries();
            for (var j in geos) {
                _changeGeoProjection(geos[j], oldCode, newCode);
            }
        }

        //改变缓存数组
        if (_drawnLineArr != null) {
            for (var i in _drawnLineArr) {
                _drawnLineArr[i] = _changeCoordProjection(_drawnLineArr[i], oldCode, newCode);
            }
        }
        //_movingLine

        //改变中心点
        var newCenter = _changeCoordProjection(mapObj.getCenter(), oldCode, newCode);
        mapObj.setCenter(newCenter);

        var bOpenInfoWindow = _mapApi.getInfoWindowOpenState();
        if (bOpenInfoWindow) {
            _mapApi.closeInfoWindow();
        }
    }

    function _changeGeoProjection(geo, oldCode, newCode) {
        var fun = oldCode.replace(':', '') + '_' + newCode.replace(':', '');
        var coord, tmpLonLat, coord = geo.getCoordinates();

        if (coord instanceof maptalks.Coordinate) {
            tmpLonLat = GpsConvert[fun](coord.y, coord.x, true);
            coord = new maptalks.Coordinate(tmpLonLat.lon,tmpLonLat.lat);
        } else {
            if (geo.type == "Polygon") {
                coord = coord[0];
                //polyGon   getCoordinates 返回的坐标数组格式不同  --pengh
            }
            for (var i = 0; i < coord.length; i++) {
                tmpLonLat = GpsConvert[fun](coord[i].y, coord[i].x, true);
                coord[i] = new maptalks.Coordinate(tmpLonLat.lon,tmpLonLat.lat);
            }
        }
        geo.setCoordinates(coord);
        return geo;
    }

    function _changeCoordProjection(coord, oldCode, newCode) {
        var fun = oldCode.replace(':', '') + '_' + newCode.replace(':', '');
        var tmpLonLat = GpsConvert[fun](coord.y, coord.x, true);
        return new maptalks.Coordinate(tmpLonLat.lon,tmpLonLat.lat);
    }
    //#endregion

    //#region 地图自定义工具，图层切换、聚合点开关
    /**
     * 获取地图默认显示图层
     * @param {any} mapStyle 样式 normal-正常，其他-深蓝
     */
    function _initDefaultLayersAndProjection(mapStyle) {
        var defaultLayers = {};
        var tileParam = TMapCommon.tileLayerParam[MapParam.currentLayer];
        var filter = (mapStyle == "normal") ? {} : {
            cssFilter: 'sepia(100%) invert(90%)'
        };
        var baseLayers = [];
        if (!(tileParam instanceof Array)) {
            tileParam = [tileParam];
        }
        var layerType = MapParam.currentLayer

        for (var j in tileParam) {
            //添加天地图key
            if (layerType == "Tianditu" || layerType == "Tianditu_Sate" || layerType == "JiuGang" || layerType == "JiuGang_Sate") {
                if (typeof (tileParam[j].urlTemplate) == "string") {
                    if (tileParam[j].urlTemplate.indexOf("&tk=") == -1) {
                        tileParam[j].urlTemplate = tileParam[j].urlTemplate + "&tk=" + MapParam.tkey;
                    }
                }

            }
            baseLayers.push(new maptalks.TileLayer('base' + j.toString(),$.extend(tileParam[j], filter)));
        }

        _currentPrjCode = tileParam[0].spatialReference && tileParam[0].spatialReference.projection ? tileParam[0].spatialReference.projection : _gcjPrjCode;
        if (baseLayers.length > 1) {
            return new maptalks.GroupTileLayer('base',baseLayers);
        } else {
            return baseLayers[0];
        }

    }
    /**
     * 切换图层
     * @param {any} layerType 图层Id
     * @param {any} layerName 图层名称
     */
    this.changeBaseLayer = function(layerType, layerName) {
        console.log(layerType, layerName)
        if (layerType == MapParam.currentLayer || TMapCommon.tileLayerParam[layerType] == undefined)
            return;

        var filter = (_mapOpt.style == "normal") ? {} : {
            cssFilter: 'sepia(100%) invert(90%)'
        };
        //var needDelLayers = mapObj.getLayers(function (layer) {//不包含baseLayer
        //    return (layer instanceof maptalks.TileLayer);
        //});
        //if (needDelLayers.length > 0)
        //    mapObj.removeLayer(needDelLayers);

        var tileParam = TMapCommon.tileLayerParam[layerType];
        var baseLayers = [];
        if (tileParam instanceof Array) {
            for (var j in tileParam) {
                //添加天地图key
                if (layerType == "Tianditu" || layerType == "Tianditu_Sate" || layerType == "JiuGang" || layerType == "JiuGang_Sate") {
                    if (typeof (tileParam[j].urlTemplate) == "string") {
                        if (tileParam[j].urlTemplate.indexOf("&tk=") == -1) {
                            tileParam[j].urlTemplate = tileParam[j].urlTemplate + "&tk=" + MapParam.tkey;
                        }
                    }
                }
                baseLayers.push(new maptalks.TileLayer('base' + j.toString(),$.extend(tileParam[j], filter)));
            }
        } else {
            //添加天地图key
            if (layerType == "Tianditu" || layerType == "Tianditu_Sate" || layerType == "JiuGang" || layerType == "JiuGang_Sate") {
                if (typeof (tileParam[j].urlTemplate) == "string") {
                    if (tileParam[j].urlTemplate.indexOf("&tk=") == -1) {
                        tileParam[j].urlTemplate = tileParam[j].urlTemplate + "&tk=" + MapParam.tkey;
                    }
                }
            }
            baseLayers.push(new maptalks.TileLayer('base',$.extend(tileParam, filter)));
        }

        if (baseLayers.length > 1) {
            mapObj.setBaseLayer(new maptalks.GroupTileLayer('base',baseLayers));
        } else {
            mapObj.setBaseLayer(baseLayers[0]);
        }

        var firstParam = (tileParam instanceof Array) ? tileParam[0] : tileParam;
        mapObj.config({
            minZoom: firstParam.minZoom > 0 ? firstParam.minZoom : 4,
            maxZoom: firstParam.maxZoom > 0 ? firstParam.maxZoom : 18,
            spatialReference: firstParam.spatialReference != undefined ? firstParam.spatialReference : {
                projection: _gcjPrjCode
            }
        });
        var currentZoom = mapObj.getZoom();
        if (currentZoom > firstParam.maxZoom)
            mapObj.setZoom(firstParam.maxZoom);
        else if (currentZoom < firstParam.minZoom)
            mapObj.setZoom(firstParam.minZoom);

        MapParam.currentLayer = layerType;
        MapParam.currentLayerName = layerName;
        //高德、高德卫星、四维地图显示马良专版（宁波港）地图
        if (!(layerType == 'AMap' || layerType == 'AMap_Sate' || layerType == 'AMap_icttic')) {
            //关闭图层
            _ningbogangLayerOff();
        } else {
            if ((document.getElementById("map_ck_ningbogang") && document.getElementById("map_ck_ningbogang").checked) || mapToolStatus.layer.ningbogang) {
                //判断图层是否已经勾选
                _ningbogangLayerOn();
            }
        }
    }

    var _controlContainer = null;
    //自定义控件
    function _initControlContainer() {
        var ctn = document.createElement("div");
        ctn.className = "cm-controls";
        ctn.style.cssText = "position:absolute; right:18px; top:20px; font-size:12px; color:#333;z-index:200; backgroud-color:transparent;";
        _controlContainer = ctn;
        document.getElementById(_container).appendChild(ctn);
    }

    //实时路况控件
    var _trafficShowStatus = false;
    //当前是否显示实时路况
    var _trafficControl = null;
    var _cluserControl = null;

    //设置路况 对外提供方法
    this.setTraffic = function(type) {
        if (type == "on") {
            _trafficOn()
        } else {
            _trafficOff()
        }
    }

    function _trafficOn() {
        mapToolStatus.layer.traffic = true;
        //修改状态
        //简洁ui 要调用
        var layer = mapObj.getLayer('traffic');
        if (layer == null) {
            layer = new maptalks.TileLayer('traffic',TMapCommon.getTrafficParam(_currentPrjCode, _mapOpt.style));
            layer.addTo(mapObj);
        }
    }

    function _trafficOff(ctl) {
        mapToolStatus.layer.traffic = false;
        //修改状态
        //简洁ui 要调用
        var layer = mapObj.getLayer('traffic');
        if (layer != null) {
            layer.remove();
            layer = null;
        }
    }

    function _trafficeReset() {
        if (!_trafficControl) {
            return;
        }

        var hasTraffic = TMapCommon.hasTraffic(_currentPrjCode);
        _trafficControl.style.display = hasTraffic ? "block" : "none";

        if (_trafficShowStatus) {
            _trafficOff();
            if (hasTraffic) {
                _trafficOn();
            }
        }
    }

    //对外提供方法 -马良宁波港特殊图层
    this.setMaLiangSpecialLayer = function(type) {
        if (type == 'on') {
            _ningbogangLayerOn();
        } else {
            _ningbogangLayerOff();
        }
    }

    function _ningbogangLayerOn() {
        let currentLayer = MapParam.currentLayer
        if (!(currentLayer == 'AMap' || currentLayer == 'AMap_Sate' || currentLayer == 'AMap_icttic')) {
            return;
        }
        if (document.getElementById("map_ck_ningbogang")) {
            document.getElementById("map_ck_ningbogang").checked = true;
        }
        mapToolStatus.layer.ningbogang = true;
        //修改状态
        //简洁ui 要调用
        var layer = mapObj.getLayer('ningbogang');
        if (layer == null) {
            layer = new maptalks.TileLayer('ningbogang',TMapCommon.NingbogangLayerParam);
            layer.addTo(mapObj);
        }
    }
    function _ningbogangLayerOff() {
        mapToolStatus.layer.ningbogang = false;
        //修改状态
        //简洁ui 要调用
        var layer = mapObj.getLayer('ningbogang');
        if (layer != null) {
            layer.remove();
            layer = null;
        }
    }
    //聚合点控件
    function _initCluserControl() {
        if (!MapParam.isShowClusterControl) {
            return;
        }
        var ctn = document.createElement("div");
        ctn.id = "cluser-control";
        //加一个id做控制；
        ctn.className = "cm-cluser-control";
        //ctn.style.cssText = "position:absolute; right:18px; top:70px; font-size:12px; color:#333;z-index:200";
        ctn.style.cssText = "clear:both; ";
        _cluserControl = ctn
        var imgDiv = document.createElement("div");

        imgDiv.title = "车辆聚合:" + (MapParam.isOpenVehicleCluser ? "开" : "关");
        imgDiv.style.cssText = "float:right; width:32px; height:32px; margin-bottom:10px; cursor: pointer; background:#fff url(" + MapParam.siteRoot + "/images/comm/m0" + (MapParam.isOpenVehicleCluser ? "" : "_gray") + ".png) no-repeat;border:#ccc 1px solid;border-radius: 4px;box-shadow: 1px 1px 2px #ccc;";
        mapToolStatus.cluster = MapParam.isOpenVehicleCluser ? "on" : "off";
        // 状态

        imgDiv.onclick = function() {
            //removeAllMarkerFast('vehicle');
            if (MapParam.isOpenVehicleCluser) {
                //this.title = "车辆聚合:关";
                _vehicleClusterOff();
            } else {
                //this.title = "车辆聚合:开";
                _vehicleClusterOn();
            }
        }
        ;
        ctn.appendChild(imgDiv);
        _controlContainer.appendChild(ctn);
    }

    //设置聚合 对外提供方法
    this.setCluser = function(type) {
        if (type == "on") {
            _vehicleClusterOn()
        } else {
            _vehicleClusterOff()
        }
    }

    function _vehicleClusterOn() {
        //简洁ui 调用
        mapToolStatus.cluster = "on";
        //修改状态
        _clusterList['vehicle'].config({
            maxClusterZoom: MapParam.vehicleCluserMaxZoom
        });
        MapParam.isOpenVehicleCluser = true;

        if (!MapParam.isOpenVehicleCluser || !_cluserControl)
            return;

        var imgDiv = _cluserControl.children[0];
        imgDiv.title = "车辆聚合:开";
        imgDiv.style.backgroundImage = 'url(' + MapParam.siteRoot + '/images/comm/m0.png)';

    }

    function _vehicleClusterOff() {
        //简洁ui 调用
        mapToolStatus.cluster = "off";
        //修改状态
        _clusterList['vehicle'].config({
            maxClusterZoom: 1
        });
        MapParam.isOpenVehicleCluser = false;

        if (MapParam.isOpenVehicleCluser || !_cluserControl)
            return;

        var imgDiv = _cluserControl.children[0];
        imgDiv.title = "车辆聚合:关";
        imgDiv.style.backgroundImage = 'url(' + MapParam.siteRoot + '/images/comm/m0_gray.png)';
    }

    //图层选择控件
    function _initLayerSwitchControl() {
        var items = ["vehicle", "flag", "poi", "polyline", "polygon", "traffic"];
        var itemNames = ["车辆", "标注", "POI", "路线", "区域", "路况"];

        if (_mapOpt.isShowWeatherAlarm == 'on') {
            items.push('weather');
            itemNames.push("天气");
        }
        if (MapParam.initNingbogangLayer == 'True') {
            items.push('ningbogang');
            itemNames.push("附加");
        }

        var item;
        var ctn = document.createElement("div");
        ctn.id = "layer-control"
        //ctn.style.cssText = "position:absolute; right:18px; top:120px; font-size:12px; color:#333;z-index:200";
        ctn.style.cssText = "clear:both;";

        var ctn2 = document.createElement("div");
        ctn2.style.cssText = "float:right; background:#fff; border:#ccc 1px solid; border-radius: 4px;box-shadow: 1px 1px 2px #ccc;";
        ctn.appendChild(ctn2);
        var title = document.createElement("div");
        //title.innerText = "图层";
        title.title = "图层控制";
        title.style.cssText = "float:right; width:32px; height:32px;background:transparent url(" + MapParam.siteRoot + "/images/comm/tc.png) no-repeat;";
        ctn2.appendChild(title);
        var content = document.createElement("div");
        content.style.display = "none";
        content.style.paddingRight = "4px";
        for (var i in items) {
            item = items[i];
            var d = document.createElement("div");
            var ck = document.createElement("input");
            ck.id = _container + "_ck_" + item;
            ck.type = "checkbox";
            //ck.checked = true;
            ck.checked = mapToolStatus.layer[item];

            var clickEvent = function(item) {
                return function() {
                    var isShow = document.getElementById(_container + "_ck_" + item).checked;
                    _layerSwitch(item, isShow)
                }
                    ;
            };
            ck.onclick = clickEvent(item);

            var lbl = document.createElement("label");
            //lbl.for = _container + "_ck_" + item;
            lbl.setAttribute("for", _container + "_ck_" + item);
            lbl.innerText = itemNames[i] + "图层";
            d.appendChild(ck);
            d.appendChild(lbl);
            content.appendChild(d);
        }
        ctn2.appendChild(content);
        ctn.onmouseover = function() {
            content.style.display = "block";
            title.style.display = "none";
        }
        ;

        ctn.onmouseout = function() {
            content.style.display = "none";
            title.style.display = "block";
        }
        ;
        //document.getElementById(_container).appendChild(ctn);
        _controlContainer.appendChild(ctn);
    }

    //设置图层 对外提供方法
    this.layerSwitch = function(layerName, isShow) {
        //修改隐藏控件 checkbox的取值
        if (document.getElementById(_container + "_ck_" + layerName)) {
            document.getElementById(_container + "_ck_" + layerName).checked = isShow;
        }
        _layerSwitch(layerName, isShow)
    }

    function _layerSwitch(layerName, isShow) {
        mapToolStatus.layer[layerName] = isShow;
        //修改状态；
        if (layerName == 'traffic') {
            if (isShow) {
                _trafficOn();
            } else {
                _trafficOff();
            }
        } else if (layerName == 'weather') {
            if (isShow) {
                _mapApi.openWeatherAlarm();
            } else {
                _mapApi.closeWeatherAlarm();
            }
        } else if (layerName == 'ningbogang') {
            if (isShow) {
                _ningbogangLayerOn();
            } else {
                _ningbogangLayerOff();
            }
        }
        else {
            var layerConfig = _vLayers[layerName];
            if (layerConfig) {
                if (layerConfig.layer)
                    isShow ? layerConfig.layer.show() : layerConfig.layer.hide();
                if (layerConfig.clusterLayer)
                    isShow ? layerConfig.clusterLayer.show() : layerConfig.clusterLayer.hide();
            }
            MapLayerSwitcher[layerName] = isShow;
        }

    }

    //修改地图控件按钮 样式
    function showCustomMapTool() {
        //控制缩放控件
        if (zoomControl)
            zoomControl.show();
        //控制自定义地图工具按钮显示
        if (!_controlContainer) {
            //type = 'default'
            _initControlContainer();
            //  _initTrafficControl(); --废弃 去掉按钮 放到图层中去勾选
            _initCluserControl();
            _initZoomControl();
            //是否加载天气预警
            if (_mapOpt.isShowWeatherAlarm) {//  _initWeatherAlarmControl(); --废弃 去掉按钮 放到图层中去勾选
            }
            if (MapParam.isShowLayerControl) {
                _initLayerSwitchControl();
            }
        } else {
            _controlContainer.style.display = "block";
        }
    }

    function hideCustomMapTool() {
        //控制缩放控件
        if (zoomControl)
            zoomControl.hide();
        //控制自定义地图工具按钮隐藏
        if (_controlContainer)
            _controlContainer.style.display = "none";
    }

    //#endregion

    //#region 全局配置接口，是否显示当前车背景、是否显示所有轨迹点、是否显示小尾巴、设置轨迹模式...
    //设置是否显示当前车背景图（红色圈）
    this.setIsShowCurrVehicleBg = function(isShowCurrVehicleBg) {
        if (isShowCurrVehicleBg == false || isShowCurrVehicleBg == 'false')
            this.isShowCurrVehicleBg = false;
        else
            this.isShowCurrVehicleBg = true;
    }
    //设置是否显示所有轨迹点
    this.setIsShowAllTrackPoint = function(isShowAllTrackPoint) {
        if (isShowAllTrackPoint == true || isShowAllTrackPoint == 'true')
            MapParam.isShowAllTrackPoint = isShowAllTrackPoint;
        else
            MapParam.isShowAllTrackPoint = false;
    }

    //设置是否显示车辆小尾巴
    this.setIsShowVehicleRealTrack = function(isShowVehicleRealTrack) {
        if (isShowVehicleRealTrack == true || isShowVehicleRealTrack == 'true')
            MapParam.isShowVehicleRealTrack = true;
        else {
            MapParam.isShowVehicleRealTrack = false;
            //清理所有小尾巴
            try {
                var markers = markerArray['vehicle'].getHashTable();
                var markerOption;
                for (i in markers) {
                    markerOption = _getExtData(markers[i]);
                    _vline_del(markerOption);
                }
            } catch (e) {
                if (console) {
                    console.error(e);
                }
            }
        }
    }

    this.setTrackMode = function() {
        _bTrackMode = true;
        if (MapParam.isOpenVehicleCluser) {
            _vehicleClusterOff();
        }

        if (MapParam.isShowClusterControl) {
            var control = $('#' + _container + ' .cm-cluser-control');
            if (control.length > 0) {
                control.hide();
            }
            MapParam.isShowClusterControl = false;
        }
    }
    //#endregion

    //#region 地图中心、级别 设置和获取、地图偏移
    //获取当前地图中心、级别、地图名称
    this.getMapView = function() {
        var center = mapObj.getCenter();
        var lonlat = _coordConvertOut(center.y, center.x);
        return lonlat.lon + ',' + lonlat.lat + ',' + this.getZoom() + ',' + MapParam.currentLayer + ',' + MapParam.currentLayerName;
    }
    //设置当前地图中心、级别、地图名称
    this.setMap = function(mapExtent) {
        if (mapExtent) {
            var args = mapExtent.split(",");
            if (args.length >= 3) {
                _mapApi.setZoomAndCenter(args[2], args[0], args[1]);
            }
            if (args.length >= 5) {
                _mapApi.changeBaseLayer(args[3], args[4]);
            }
        }
    }
    //设置中心点,设置级别
    this.setZoomAndCenter = function(level, lon, lat) {
        if (level && lon && lat) {
            var point = _coordConvertIn(lat, lon);
            mapObj.setCenterAndZoom([point.lon, point.lat], level);
        }
    }
    ;
    this.zoomToBound = function(swX, swY, neX, neY) {
        var swPoint = _coordConvertIn(swY, swX);
        var nePoint = _coordConvertIn(neY, neX);
        var sw = new maptalks.Coordinate(swPoint.lon,swPoint.lat)
        var ne = new maptalks.Coordinate(nePoint.lon,nePoint.lat)
        var extent = new maptalks.Extent(sw,ne);
        //var extent = new maptalks.Extent([swPoint.lon, swPoint.lat], [nePoint.lon, nePoint.lat]);
        mapObj.fitExtent(extent, 0);
    }
    this.getZoom = function() {
        return mapObj.getZoom();
    }
    this.setZoom = function(level) {
        mapObj.setZoom(level);
    }
    //设置中心点
    this.setCenter = function(lon, lat) {
        var point = _coordConvertIn(lat, lon);
        mapObj.setCenter([point.lon, point.lat]);
    }
    ;
    //增加panBy接口，以像素为单位，沿x方向和y方向移动地图，x向右为正，y向下为正
    this.panBy = function(x, y) {
        mapObj.panBy([x, y]);
    }
    //#endregion

    //#region 设置鼠标工具、完成事件
    //设置鼠标工具
    this.setMouseTool = function(type, callback) {
        _clearMouseTool();
        this.mouseCurrCursor = type;
        _mouseCallback = callback;
        mapObj.setCursor(CursorType[type] ? CursorType[type] : CursorType['default']);
        switch (type) {
            case 'marker':
                mousetool.setMode('Point').enable();
                break;
            case 'zoomIn':
                //放大
                mousetool.setMode('Point').enable();
                break;
            case 'zoomOut':
                //缩小
                mousetool.setMode('Point').enable();
                break;
            case 'zoomToCenter':
                //居中
                mousetool.setMode('Point').enable();
                break;
            case 'point':
                //画点，地图触发回调事件
                //mousetool.marker({ visible: false, extData: { callback: callback } });
                mousetool.setMode('Point').enable();
                break;
            case 'rectZoomIn':
                //拉框放大
                mousetool.setMode('Rectangle').enable();

                break;
            case 'rectZoomOut':
                //拉框缩小
                mousetool.setMode('Rectangle').enable();
                break;
            case 'rule':
                //测距
                //mousetool.rule();
                if (!distanceTool) {
                    distanceTool = new maptalks.DistanceTool({
                        'symbol': {
                            'lineColor': '#3EA3FB',
                            'lineWidth': 2
                        },
                        'vertexSymbol': {
                            'markerType': 'ellipse',
                            'markerFill': '#f8f8f8',
                            'markerLineColor': '#000',
                            'markerLineWidth': 3,
                            'markerWidth': 10,
                            'markerHeight': 10
                        },
                    }).addTo(mapObj);
                }
                distanceTool.enable();
                break;
            case 'measureArea':
                //mousetool.measureArea();
                if (!areaTool) {
                    areaTool = new maptalks.AreaTool({
                        'symbol': {
                            'lineColor': '#3EA3FB',
                            'lineWidth': 2,
                            'polygonFill': '#ACD5F6',
                            'polygonOpacity': 0.5
                        },
                        'vertexSymbol': {
                            'markerType': 'ellipse',
                            'markerFill': '#f8f8f8',
                            'markerLineColor': '#3EA3FB',
                            'markerLineWidth': 3,
                            'markerWidth': 10,
                            'markerHeight': 10
                        }
                    }).addTo(mapObj);
                }
                areaTool.enable();
                break;

            case 'circleMeasure':
            case 'circle':
                //画圆
                //mousetool.circle({
                //    strokeColor: "#FF33FF", //线颜色
                //    strokeOpacity: 1.0, //线透明度
                //    strokeWeight: 3,    //线宽
                //    extData: { callback: callback }
                //});
                mousetool.setMode('Circle').setSymbol({
                    'lineColor': '#FF33FF',
                    'lineWidth': 3
                }).enable();
                break;
            case 'rectMeasure':
            case 'rectangle':
                //画矩形
                //mousetool.rectangle({
                //    strokeColor: "#6633CC", //线颜色
                //    strokeOpacity: 1.0, //线透明度
                //    strokeWeight: 3,    //线宽
                //    extData: { callback: callback }
                //});
                mousetool.setMode('Rectangle').setSymbol({
                    //'lineColor': '#6633CC',
                    'lineColor': '80d8ff',
                    'lineWidth': 3
                }).enable();
                break;
            case 'polygon':
                //画多边形
                //mousetool.polygon({
                //    strokeColor: "#6633CC", //线颜色
                //    strokeOpacity: 1.0, //线透明度
                //    strokeWeight: 3,    //线宽
                //    extData: { callback: callback }
                //});
                mousetool.setMode('Polygon').setSymbol({
                    //'lineColor': '#6633CC',
                    'lineColor': '80d8ff',
                    'lineWidth': 3
                }).enable();
                break;
            case 'polyline':
                //画折线
                //mousetool.polyline({
                //    strokeColor: "#3366FF", //线颜色
                //    strokeOpacity: 1.0, //线透明度
                //    strokeWeight: 3,    //线宽
                //    extData: { callback: callback }
                //}); break;

                _startMouseDrawLine(callback);
                break;
        }
    }
    function _clearMouseTool() {
        //禁用鼠标、测距、面积量算
        if (mousetool)
            mousetool.disable();
        if (distanceTool)
            distanceTool.clear().disable();
        if (areaTool)
            areaTool.clear().disable();

        _vLayers['temp'].layer.clear();
        _mouseCallback = null;
        _endMouseDrawLine();
        _mapApi.currentPoint = null;
        //当前点击的点
        _mapApi.currentZoomBox = null;
        //拉框信息
        _mapApi.currentSketchPoints = null;
        //多个点（多边形区域/路线）
        if (_mapApi.mouseCurrCursor == "trackPoint") {
            //若上次鼠标是轨迹点，则先取消轨迹点
            _mapApi.deletePoi('trackPointPOI');
            _mapApi.deletePoi("trackPointPOI_start");
            _mapApi.deletePoi("trackPointPOI_end");
        }

        //for (var i in _currentLabelList) {
        //    _currentLabelList[i].setMap(null);
        //}
        //_currentLabelList.splice(0, _currentLabelList.length);
    }

    function _mouseToolDrawComplete(e) {
        //鼠标绘制完成事件
        switch (_mapApi.mouseCurrCursor) {
            case 'marker':
                //layer add marker
                _vLayers['temp'].layer.addGeometry(e.geometry);
                break;
            case 'zoomIn':
                mapObj.zoomIn();
                mapObj.setCenter(e.geometry.getCoordinates());
                break;
            case 'zoomOut':
                mapObj.zoomOut();
                mapObj.setCenter(e.geometry.getCoordinates());
                break;
            case 'zoomToCenter':
                mapObj.setCenter(e.geometry.getCoordinates());
                break;
            case 'point':
                var marker = e.geometry;
                var callback = _mouseCallback;

                var coord = marker.getCoordinates();
                var lonlat = _coordConvertOut(coord.y, coord.x);
                _mapApi.currentPoint = [lonlat.lon, lonlat.lat];

                if (callback) {
                    callback([lonlat.lon, lonlat.lat]);
                }
                break;

            case 'circleMeasure':
            case 'circle':
                var circle = e.geometry;
                var callback = _mouseCallback;
                var circleCenter = circle.getCenter();

                var circlePoint = _coordConvertOut(circleCenter.y, circleCenter.x);

                if (_mapApi.mouseCurrCursor == 'circleMeasure') {
                    var r = circle.getRadius()
                        , d = r < 500 ? (2 * r).toFixed(2) + '米' : (2 * r / 1000.0).toFixed(2) + '公里'
                        , s = r < 178.5 ? (PI * r * r).toFixed(2) + '平方米' : (PI * r * r / 1000000.0).toFixed(2) + '平方公里'
                        , l = r < 160 ? (PI * 2 * r).toFixed(2) + '米' : (PI * 2 * r / 1000.0).toFixed(2) + '公里';

                    //console.debug('circle symbol', circle.getSymbol());
                    circle.updateSymbol({
                        'lineColor': '#FF33FF',
                        'lineWidth': 3,
                        'textName': '直径：' + d + '\n周长：' + l + '\n面积：' + s,
                        'textHorizontalAlignment': 'right',
                        'textHaloFill': '#fff',
                        'textHaloRadius': 2,
                        'textDx': -40,
                        'polygonFill': '#ffffff',
                        'polygonOpacity': 0.4
                    });

                    _vLayers['temp'].layer.addGeometry(circle);
                    //var markLabel = new AMap.Marker({
                    //    map: mapObj,
                    //    position: circleCenter,
                    //    content: '<div style="background-color:#fff;border:1px solid #000; white-space:nowrap">直径：' + d + '<br>周长：' + l + '<br>面积：' + s + '</div>',
                    //    offset: new AMap.Pixel(-40, -30)
                    //});
                    //_currentLabelList.push(markLabel);
                }
                //else {
                //    circle.setMap(null);
                //}

                if (callback) {
                    callback([circlePoint.lon, circlePoint.lat, circle.getRadius()]);
                }
                break;
            case 'rectZoomIn':
                //拉框放大
                var rect = e.geometry;
                mapObj.fitExtent(rect.getExtent(), 0);
                //自适应放大
                break;
            case 'rectZoomOut':
                //拉框缩小
                var rect = e.geometry;
                mapObj.zoomOut();
                mapObj.setCenter(rect.getCenter());
                break;
            case 'rectMeasure':
                //矩形量算
                var rect = e.geometry;
                var rectPath = rect.getShell();
                //获取矩形的四个点
                if (rectPath.length >= 4) {
                    var l1 = mapObj.getProjection().measureLenBetween(rectPath[0], rectPath[1]);
                    var l2 = mapObj.getProjection().measureLenBetween(rectPath[1], rectPath[2]);
                    var s1 = mapObj.getProjection().measureArea(rectPath);
                    var s = s1 < 100000 ? s1.toFixed(2) + '平方米' : (s1 / 1000000.0).toFixed(2) + '平方公里'
                        , l = l1 + l2 < 500 ? (2 * (l1 + l2)).toFixed(2) + '米' : (2 * (l1 + l2) / 1000.0).toFixed(2) + '公里';
                    //var centerPoint = [(rectPath[0].x + rectPath[2].x) / 2, (rectPath[0].y + rectPath[2].y) / 2]
                    //var markLabel = new AMap.Marker({
                    //    map: mapObj,
                    //    position: centerPoint,
                    //    content: '<div style="background-color:#fff;border:1px solid #000; white-space:nowrap">周长：' + l + '<br>面积：' + s + '</div>',
                    //    offset: new AMap.Pixel(-40, -20)
                    //});
                    //_currentLabelList.push(markLabel);
                    rect.updateSymbol({
                        'lineColor': '#6633CC',
                        'lineWidth': 3,
                        'textName': '周长：' + l + '\n面积：' + s,
                        'textHorizontalAlignment': 'right',
                        'textHaloFill': '#fff',
                        'textHaloRadius': 2,
                        'textDx': -40,
                        'polygonFill': '#ffffff',
                        'polygonOpacity': 0.4
                    });
                    _vLayers['temp'].layer.addGeometry(rect);
                }
                break;
            case 'rectangle':
                var rect = e.geometry;
                var rectPath = rect.getShell();
                //获取矩形的四个点
                var callback = _mouseCallback;
                if (rectPath.length >= 4) {

                    var minLng = maxLng = rectPath[0].x
                        , minLat = maxLat = rectPath[0].y;
                    var tmpLng, tmpLat;
                    for (i = 1; i < 4; i++) {
                        //去最大最小经纬度
                        tmpLng = rectPath[i].x,
                            tmpLat = rectPath[i].y;
                        if (tmpLng > maxLng)
                            maxLng = tmpLng;
                        else if (tmpLng < minLng)
                            minLng = tmpLng;

                        if (tmpLat > maxLat)
                            maxLat = tmpLat;
                        else if (tmpLat < minLat)
                            minLat = tmpLat;
                    }

                    if ((minLat < maxLat) && (minLng < maxLng)) {
                        var minPoint = _coordConvertOut(minLat, minLng);
                        //左下角的点
                        var maxPoint = _coordConvertOut(maxLat, maxLng);
                        //右上角的点

                        _mapApi.currentZoomBox = [[minPoint.lon, minPoint.lat], [maxPoint.lon, maxPoint.lat]];
                        if (callback)
                            callback(_mapApi.currentZoomBox);
                    }
                }
                break;
            case 'polygon':
                var polygon = e.geometry;
                var polygonPath = polygon.getShell();
                var callback = _mouseCallback;
                if (polygonPath.length > 2) {
                    var polygonPoints = [];
                    var tmpPloygonPoint;
                    for (i in polygonPath) {
                        tmpPloygonPoint = _coordConvertOut(polygonPath[i].y, polygonPath[i].x);
                        polygonPoints.push([tmpPloygonPoint.lon, tmpPloygonPoint.lat]);
                    }

                    _mapApi.currentSketchPoints = polygonPoints;
                    if (callback)
                        callback(_mapApi.currentSketchPoints);
                    polygonPoints = null;
                }

                polygonPath = null;
                break;
            //case 'polyline': //改为自定义画线
            //    var polyline = e.obj;
            //    var polylinePath = polyline.getPath();
            //    var callback = polyline.getExtData().callback;
            //    if (polylinePath.length >= 2) {
            //        var polylinePoints = [];
            //        var tmpPolylinePoint;
            //        for (i in polylinePath) {
            //            tmpPolylinePoint = _coordConvertOut(polylinePath[i].getLat(), polylinePath[i].getLng());
            //            polylinePoints.push([tmpPolylinePoint.lon, tmpPolylinePoint.lat]);
            //        }
            //        polyline.setMap(null);
            //        _mapApi.currentSketchPoints = polylinePoints;
            //        if (callback)
            //            callback(_mapApi.currentSketchPoints);
            //        polylinePoints = null;
            //    }
            //    else {
            //        polyline.setMap(null);
            //    }
            //    polylinePath = null;
            //    break;
            default:
                //try {
                //    e.obj.setMap(null);
                //}
                //catch (e) { }
                break;
        }
    }
    //#endregion

    /***** 自定义鼠标画线 begin*****/
    //#region 自定义鼠标画线
    //鼠标单击画线
    function _drawpolyline_click(e) {
        //console.log('drawpolyline_click');
        if (_drawnLineArr != null) {
            _drawnLineArr.push(e.coordinate);
            if (_drawingLine == null) {
                _drawingLine = new maptalks.LineString(_drawnLineArr,{
                    symbol: {
                        'lineColor': '#3366FF',
                        //线颜色
                        'lineWidth': 3,
                        'lineJoin': 'round',
                        //miter, round, bevel
                        'lineCap': 'round'//butt, round, square
                    },
                    cursor: CursorType.polyline
                });

                _movingLine = new maptalks.LineString({
                    symbol: {
                        'lineColor': '#3366FF',
                        //线颜色
                        'lineWidth': 3,
                        'lineJoin': 'round',
                        //miter, round, bevel
                        'lineCap': 'round'//butt, round, square
                    },
                    cursor: CursorType.polyline
                });
                _drawingLine.addTo(_vLayers['polyline'].layer);
                _movingLine.addTo(_vLayers['polyline'].layer);
            } else
                _drawingLine.setCoordinates(_drawnLineArr);
        }
    }
    //鼠标移动，线跟随鼠标效果
    function _drawpolyline_mousemove(e) {
        //console.log('drawpolyline_move');
        if (_movingLine != null) {
            if (_drawnLineArr.length >= 1) {
                var lastPoint = _drawnLineArr[_drawnLineArr.length - 1];
                _movingLine.setCoordinates([lastPoint, e.coordinate]);
            } else {
                _movingLine.setCoordinates([]);
            }
        }
    }
    //双击鼠标结束画线
    function _drawpolyline_doubleclick(e) {
        _completeMouseDrawLine();
    }

    function _startMouseDrawLine(callback) {
        if (_drawLineClickListener != null)
            return;
        mapObj.config('doubleClickZoom', false);
        //禁用双击放大
        _drawLineCallback = callback;
        _drawLineMouseMoveListener = mapObj.on('mousemove', _drawpolyline_mousemove);
        _drawLineClickListener = mapObj.on('click', _drawpolyline_click);
        _drawLineDoubleClickListener = mapObj.on('dblclick', _drawpolyline_doubleclick);
        //_drawLineRightClickListener = mapObj.on('rightclick', _drawpolyline_rightclick);
        _drawnLineArr = [];
    }

    function _completeMouseDrawLine() {
        if (_drawnLineArr != null && _drawnLineArr.length >= 2) {
            var polylinePoints = [];
            var tmpPolylinePoint;
            for (i in _drawnLineArr) {
                tmpPolylinePoint = _coordConvertOut(_drawnLineArr[i].y, _drawnLineArr[i].x);
                polylinePoints.push([tmpPolylinePoint.lon, tmpPolylinePoint.lat]);
            }
            _mapApi.currentSketchPoints = polylinePoints;
            if (_drawLineCallback != null)
                _drawLineCallback(_mapApi.currentSketchPoints);
            tmpPolylinePoint = null;
            polylinePoints = null;
        }
        //CS客户端获取路段点先不删除
        //_getLineIndex = 0;
        //if (_drawnLineArr != null) {
        //    _drawnLineArr.splice(0, _drawnLineArr.length); //_drawnLineArr=[];
        //}
        if (_drawingLine != null) {
            _drawingLine.remove();
            _drawingLine = null;
        }
        if (_movingLine != null) {
            _movingLine.remove();
            _movingLine = null;
        }
    }

    function _endMouseDrawLine() {
        _drawLineCallback = null,
            _getLineIndex = 0;
        if (_drawnLineArr != null) {
            _drawnLineArr.splice(0, _drawnLineArr.length);
            _drawnLineArr = null;
        }
        if (_drawingLine != null) {
            _drawingLine.remove();
            _drawingLine = null;
        }
        if (_movingLine != null) {
            _movingLine.remove();
            _movingLine = null;
        }
        if (_drawLineMouseMoveListener != null) {
            mapObj.off('mousemove', _drawLineMouseMoveListener);
            _drawLineMouseMoveListener = null;
        }

        if (_drawLineClickListener != null) {
            mapObj.off('click', _drawLineClickListener);
            _drawLineClickListener = null;
        }

        if (_drawLineRightClickListener != null) {
            mapObj.off('contextmenu', _drawLineRightClickListener);
            _drawLineClickListener = null;
        }
        if (_drawLineDoubleClickListener != null) {
            mapObj.off('dblclick', _drawLineDoubleClickListener);
            _drawLineClickListener = null;
        }
        mapObj.config('doubleClickZoom', true);
        //恢复双击放大
    }
    //绘制路线，撤销操作
    this.drawpolyline_sketchBack = function() {
        if (_drawnLineArr != null && _drawingLine != null) {
            //起始点撤销
            if (_drawnLineArr.length == 1) {
                _drawnLineArr.pop();
                _drawingLine.setPath(_drawnLineArr);
            }
            //兼容添加路段 _getLineIndex-1
            if (_drawnLineArr.length > _getLineIndex + 1) {
                _drawnLineArr.pop();
                _drawingLine.setCoordinates(_drawnLineArr);
            }
        }
    }
    //绘制路线，结束鼠标绘制线路
    this.drawpolyline_completeMouseDrawLine = function() {
        _completeMouseDrawLine();
    }

    //绘制路线，获取当前路段点
    this.drawpolyline_getLineCoordStr = function() {
        var points, tmpPolylinePoint;
        if (_drawnLineArr != null) {
            var length = _drawnLineArr.length;
            if (_getLineIndex < length - 1) {
                points = [];
                //兼容C/S 客户端 起始点返回
                //for (var i = _getLineIndex + 1; i < length; i++) {
                for (var i = _getLineIndex; i < length; i++) {
                    tmpPolylinePoint = _coordConvertOut(_drawnLineArr[i].y, _drawnLineArr[i].x);
                    points.push([tmpPolylinePoint.lon, tmpPolylinePoint.lat]);
                }
                _getLineIndex = length - 1;
                //下标
            }
        }
        return points;
    }
    //#endregion
    /***** 自定义鼠标画线 end*****/

    /***** 路线编辑工具 begin *****/
    //#region 路线编辑工具
    //开始编辑路线
    this.drawpolyline_startLineEdit = function(polylineName) {
        var polyline;
        if (polylineName == null) {
            if (polylineList.getCount() > 0) {
                var allLine = polylineList.getHashTable();
                for (i in allLine) {
                    polylineName = i;
                    polyline = allLine[i];
                    break;
                }
                allLine = null;
            } else {
                alert('没有可编辑的路线');
                return;
            }
        } else {
            polyline = polylineList.getValue(polylineName);
            if (polyline == null) {
                alert('未找到路线 ' + polylineName);
                return;
            }
        }

        if (polylineEditerList.containsKey(polylineName)) {
            return;
        }
        polylineEditerList.add(polylineName, polyline);
        polyline.startEdit();
    }
    //结束编辑路线
    this.drawpolyline_endLineEdit = function(polylineName) {
        var polyline = polylineEditerList.getValue(polylineName);
        if (polyline != null) {
            polyline.endEdit();
            polylineEditerList.remove(polylineName);

            var polylinePath = polyline.getCoordinates();
            var polylinePoints = [];
            var tmpPolylinePoint;
            for (i in polylinePath) {
                tmpPolylinePoint = _coordConvertOut(polylinePath[i].y, polylinePath[i].x);
                polylinePoints.push([tmpPolylinePoint.lon, tmpPolylinePoint.lat]);
            }
            tmpPolylinePoint = null;
            polylinePath = null;
            polyline = null;
            return polylinePoints;
        }

        return null;
    }
    //#endregion
    /***** 路线编辑工具 end*****/

    /***** 圆形编辑工具 begin*****/
    //#region 圆形编辑工具
    //function _drawcircle_editEvent(e) {
    //    if (e.type == 'move') {     //调整圆心位置时修改label位置
    //        var circle = e.target;
    //        if (circle != null) {
    //            var labelMarker = circle.getExtData().label;
    //            if (labelMarker != null) {
    //                labelMarker.setPosition(e.lnglat);
    //            }
    //        }
    //    }
    //    //return false;
    //}

    this.drawcircle_startCircleEdit = function(circleName) {
        var circle = circleList.getValue(circleName);
        if (circle == null) {
            alert('请确认地图上存在可编辑区域！');
            return false;
        }

        if (circleEditerList.containsKey(circleName)) {
            return false;
        }

        circleEditerList.add(circleName, circle);
        circle.startEdit();
        //mapObj.plugin(["AMap.CircleEditor"], function () {
        //    var circleEditor = new AMap.CircleEditor(mapObj, circle);
        //    circleEditor.on('move', _drawcircle_editEvent);
        //    circleEditerList.add(circleName, circleEditor);
        //    circleEditor.open();
        //});
    }

    this.drawcircle_endCircleEdit = function(circleName) {
        var circle = circleEditerList.getValue(circleName);
        if (circle != null) {
            circle.endEdit();
            circleEditerList.remove(circleName);
        } else {
            return null;
        }

        var circleCenter = circle.getCenter();
        var circlePoint = _coordConvertOut(circleCenter.y, circleCenter.x);

        return [circlePoint.lon, circlePoint.lat, circle.getRadius()];
    }

    this.clearCircleEditor = function() {
        if (circleEditerList != null) {
            var circles = circleEditerList.getHashTable();
            for (var i in circles) {
                var circle = circles[i];
                if (circle != null) {
                    circle.endEdit();
                }
            }
        }
        circleEditerList = new HashTable();
    }
    //#endregion
    /***** 圆形编辑工具 end*****/

    /***** 多边形编辑工具 begin*****/
    //#region 多边形编辑工具
    //function _drawpolygon_editEvent(e) {
    //    if (e.type == 'addnode' || e.type == 'adjust' || e.type == 'removenode') {     //调整多边形节点时修改label位置
    //        var polygon = e.target;
    //        if (polygon != null) {
    //            var labelMarker = polygon.getExtData().label;
    //            if (labelMarker != null) {
    //                var bounds = polygon.getBounds();
    //                labelMarker.setPosition(bounds.getCenter());
    //            }
    //        }
    //    }
    //    //return false;
    //}

    this.drawpolygon_startPolygonEdit = function(polygonName, isRectangle) {
        var polygon = polygonList.getValue(polygonName);
        if (polygon == null) {
            alert('请确认地图上存在可编辑区域！');
            return false;
        }

        if (polygonEditerList.containsKey(polygonName)) {
            return false;
            ;
        }

        polygonEditerList.add(polygonName, polygon);
        polygon.startEdit();
    }

    this.drawpolypon_endPolyponEdit = function(polygonName, isRectangle) {
        var polygon = polygonEditerList.getValue(polygonName);
        if (polygon != null) {
            polygon.endEdit();
            polygonEditerList.remove(polygonName);
        } else {
            return null;
        }
        var polygonPoints = [];

        if (isRectangle) {
            var rectPath = polygon.getShell();
            if (rectPath.length >= 4) {
                var minLng, maxLng, minLat, maxLat, minLng = maxLng = rectPath[0].x, minLat = maxLat = rectPath[0].y;
                var tmpLng, tmpLat;
                for (i = 1; i < 4; i++) {
                    //取最大最小经纬度
                    tmpLng = rectPath[i].x,
                        tmpLat = rectPath[i].y;
                    if (tmpLng > maxLng)
                        maxLng = tmpLng;
                    else if (tmpLng < minLng)
                        minLng = tmpLng;

                    if (tmpLat > maxLat)
                        maxLat = tmpLat;
                    else if (tmpLat < minLat)
                        minLat = tmpLat;
                }
            }

            if ((minLat < maxLat) && (minLng < maxLng)) {
                var minPoint = _coordConvertOut(minLat, minLng);
                //左下角的点
                var maxPoint = _coordConvertOut(maxLat, maxLng);
                //右上角的点

                polygonPoints.push([minPoint.lon, minPoint.lat]);
                polygonPoints.push([maxPoint.lon, maxPoint.lat]);
            }
            rectPath = null;
        } else {
            var polygonPaths = polygon.getCoordinates();
            if (polygonPaths.length > 0) {
                var polygonPath = polygonPaths[0];
                var tmpPolylonePoint;

                for (i in polygonPath) {
                    tmpPolylonePoint = _coordConvertOut(polygonPath[i].y, polygonPath[i].x);
                    polygonPoints.push([tmpPolylonePoint.lon, tmpPolylonePoint.lat]);
                }
                polygonPath = null;
            }
            polygonPaths = null;
        }

        tmpPolylonePoint = null;
        polygon = null;
        return polygonPoints;
    }

    this.clearPolylonEditor = function() {
        if (polygonEditerList != null) {
            var polygons = polygonEditerList.getHashTable();
            for (var i in polygons) {
                var polygon = polygons[i];
                if (polygon != null) {
                    polygon.endEdit();
                }
            }
        }
        polygonEditerList = new HashTable();
    }
    //#endregion
    /***** 多边形编辑工具 end*****/

    this.clearAllPolygonEditor = function() {
        _mapApi.clearPolylonEditor();
        _mapApi.clearCircleEditor();
    }

    //*****标注 begin*****/
    //#region 标注
    /**
     * 画标注
     * lxf 20191011 增加点击标注弹出pop内容
     * @param {string} name 标注名称
     * @param {number} x 精度
     * @param {number} y 纬度
     * @param {string} bmpName 标注图标文件
     * @param {bool} bFastMode 是否快速显示标注
     */
    this.showFlag = function(name, x, y, bmpName, bFastMode) {
        var icon = new MapFlagIcon(bmpName);
        var popContent = [];
        popContent.push('<table style="width: 320px" class="mapInfoWindow">');
        popContent.push("<tr>");
        popContent.push('<td class="label_td" nowrap="nowrap">标注名称</td>');
        popContent.push('<td>' + name + '</td>');
        popContent.push("</tr>");
        popContent.push("<tr>");
        popContent.push('<td class="label_td" nowrap="nowrap">经&nbsp;&nbsp;纬&nbsp;&nbsp;度</td>');
        popContent.push('<td>' + _formatNumber6(parseFloat(x)) + ',' + _formatNumber6(parseFloat(y)) + '</td>');
        popContent.push("</tr>");
        popContent.push("</table>");

        //var p = _coordConvertIn(y, x);
        var opt = new MarkerOption("flag",name,icon,x,y,null,null,name,popContent.join(''),false);
        drawMarker(opt, function(e) {
            if (e == null)
                return;
            var tmpOption;
            if (e.target != undefined) {
                tmpOption = _getExtData(e.target);
            } else {
                tmpOption = e;
            }
            var p = _coordConvertIn(tmpOption.gpslat, tmpOption.gpslng);
            _showInfoWindow(tmpOption.popContent, new maptalks.Coordinate(p.lon,p.lat));

            //return false;
            if (_mapApi.mouseCurrCursor == 'default' || _mapApi.mouseCurrCursor == 'pan' || _mapApi.mouseCurrCursor == 'trackPoint')
                return false;
        }, null, !!bFastMode);
    }

    /**
     * 画标注---+
     *
     * pengh 20210312 增加点击标注弹出自定义的infoWindow内容
     * @param {string} name 标注名称
     * @param {number} x 精度
     * @param {number} y 纬度
     * @param {string} pngName 标注图标文件
     * @param {bool} bFastMode 是否快速显示标注
     * @param {string} windowHmtl infoWindow Html内容
     */
    this.showFlagWithHtml = function(name, x, y, pngName, bFastMode, windowHtml) {
        var icon = icon = new MapFlagIcon(pngName);
        ;if (windowHtml == "") {
            var popContent = [];
            popContent.push('<table style="width: 320px" class="mapInfoWindow">');
            popContent.push("<tr>");
            popContent.push('<td class="label_td" nowrap="nowrap">标注名称</td>');
            popContent.push('<td>' + name + '</td>');
            popContent.push("</tr>");
            popContent.push("<tr>");
            popContent.push('<td class="label_td" nowrap="nowrap">经&nbsp;&nbsp;纬&nbsp;&nbsp;度</td>');
            popContent.push('<td>' + _formatNumber6(parseFloat(x)) + ',' + _formatNumber6(parseFloat(y)) + '</td>');
            popContent.push("</tr>");
            popContent.push("</table>");
            // var p = _coordConvertIn(y, x);
        }

        var opt = new MarkerOption("flag",name,icon,x,y,null,null,name,windowHtml,false);
        drawMarker(opt, function(e) {
            if (e == null)
                return;
            var tmpOption;
            if (e.target != undefined) {
                tmpOption = _getExtData(e.target);
            } else {
                tmpOption = e;
            }
            var p = _coordConvertIn(tmpOption.gpslat, tmpOption.gpslng);
            _showInfoWindow(tmpOption.popContent, new maptalks.Coordinate(p.lon,p.lat), false);

            //return false;
            if (_mapApi.mouseCurrCursor == 'default')
                return false;
        }, null, !!bFastMode);
    }

    this.getFlagNameByXY = function(x, y) {
        var lonlat = _coordConvertIn(y, x);
        var px = mapObj.coordToContainerPoint(new maptalks.Coordinate(lonlat.lon,lonlat.lat));
        var tmpPosition, tmpPx;
        var flags = markerArray["flag"].getHashTable();
        var flag;
        for (i in flags) {
            flag = flags[i];
            tmpPosition = flag.getCoordinates();
            tmpPx = mapObj.coordToContainerPoint(tmpPosition);
            if ((Math.abs(tmpPx.x - px.x) < 16) && (Math.abs(tmpPx.y - px.y) < 16)) {
                lonlat = _coordConvertOut(tmpPosition.y, tmpPosition.x);
                flags = null;
                return i + "|" + lonlat.lon + "|" + lonlat.lat;
            }
        }
        flags = null;
        return null;
    }

    this.deleteFlag = function(name) {
        deleteMarker("flag", name);
    }

    this.clearAllFlag = function() {
        removeAllMarker("flag");
    }
    //通过关键词获取匹配的标注
    function _getFlagListByKeyword(keyword) {
        if (!keyword)
            return [];
        var data = []
        var flags = markerArray["flag"].getHashTable();
        var opt;
        var reg = new RegExp(keyword,"i");
        for (var name in flags) {
            //i 是flag的显示名称
            if (reg.test(name)) {
                opt = _getExtData(flags[name]);
                data.push({
                    lon: opt.gpslng,
                    lat: opt.gpslat,
                    info: (name.replace(/,/g, ' - ') + ' - 地图标注')
                })
            }
        }
        flags = null;
        opt = null;
        return data;
    }
    //#endregion
    //*****标注end*****/

    /*****POI begin*****/
    //#region POI
    this.showPoi = function(id, text, popText, x, y, hintUrl, POILinkArry, poiColor, poiLevel, isTxtOnImg, isBound, showCallback) {
        var icon = new MapPoiIcon(poiColor,poiLevel,isTxtOnImg);

        //var p = _coordConvertIn(y, x);
        var opt = new MarkerOption("poi",id,icon,x,y,null,null,text,popText,isBound == true);
        drawMarker(opt, function(e) {
            tmpOption = _getExtData(e.target);
            //重置获取轨迹点
            if (getTrackPointType != '') {
                if (getTrackPointHandler && typeof getTrackPointHandler == 'function') {
                    //该轨迹点的index回调给Cgo8
                    getTrackPointHandler(trackPointIndexObj)
                }
                if (getTrackPointType == "start") {
                    getTrackPointType = "end"
                } else {
                    getTrackPointType = ""
                }
            }
            if (tmpOption && tmpOption.popContent != '') {
                var p = _coordConvertIn(tmpOption.gpslat, tmpOption.gpslng);
                _showInfoWindow(tmpOption.popContent, new maptalks.Coordinate(p.lon,p.lat));
            }
            //return false;
            if (_mapApi.mouseCurrCursor == 'default' || _mapApi.mouseCurrCursor == 'pan' || _mapApi.mouseCurrCursor == 'trackPoint')
                return false;
        }, showCallback);
    }

    this.deletePoi = function(id) {
        deleteMarker("poi", id);
    }

    this.clearAllPoi = function() {
        removeAllMarker("poi");
    }
    //#endregion
    /*****POI end*****/
    /*****区域路线begin*****/
    //#region 区域路线
    //清除所有区域（圆形、矩形、多边形）
    this.showCircle = function(circleName, centerX, centerY, radius, isZoom, lineColor, fillColor) {
        var p = _coordConvertIn(centerY, centerX);
        if (lineColor == undefined) {
            lineColor = '#3CA2FA';
        }

        if (fillColor == undefined) {
            fillColor = "#00b0ff"
        }
        var circle = new maptalks.Circle([p.lon, p.lat],radius,{
            symbol: {
                'lineColor': lineColor,
                //线颜色
                'lineWidth': 3,
                //线宽
                'textName': circleName,
                //显示文本
                'textHaloFill': '#fff',
                'textHaloRadius': 2,
                'polygonFill': fillColor,
                //填充色
                'polygonOpacity': 0.4 //填充透明度

            },
            extData: {
                name: circleName
            }
        });

        if (circleList.containsKey(circleName)) //已存在同名的则先移除
        {
            var delC = circleList.getValue(circleName);
            deleteCircle(delC);
        }

        circleList.add(circleName, circle);
        //新数组中增加新增加的圆
        circle.addTo(_vLayers['polygon'].layer);
        //添加到区域图层
        if (isZoom) {
            var extent = circle.getExtent();
            mapObj.fitExtent(extent, 0);
        }
    }

    var deleteCircle = function(circle) {
        var extData = _getExtData(circle);
        circle.remove();
        circleList.remove(extData.name);
        delete circle;
    }
    this.showRectangle = function(polygonName, arrayX, arrayY, isZoom, lineColor, fillColor) {
        var length = arrayX.length;
        if (length < 3)
            return;
        if (lineColor == undefined) {
            lineColor = '#3CA2FA';
        }

        if (fillColor == undefined) {
            fillColor = "#00b0ff"
        }
        var minLng, maxLng, minLat, maxLat;
        minLng = maxLng = arrayX[0],
            minLat = maxLat = arrayY[0];

        for (i = 1; i < length; i++) {
            //去最大最小经纬度
            if (arrayX[i] > maxLng)
                maxLng = arrayX[i];

            if (arrayY[i] > maxLat)
                maxLat = arrayY[i];

            if (arrayX[i] < minLng)
                minLng = arrayX[i];

            if (arrayY[i] < minLat)
                minLat = arrayY[i];
        }
        var tmpSouthWest = _coordConvertIn(minLat, minLng);
        //西南角 southWest
        var tmpNorthWest = _coordConvertIn(maxLat, minLng);
        //西北角 northWest
        var tmpNorthEast = _coordConvertIn(maxLat, maxLng);
        //东北角 norstEast
        var southWest = new maptalks.Coordinate(tmpSouthWest.lon,tmpSouthWest.lat);
        var northWest = new maptalks.Coordinate(tmpNorthWest.lon,tmpNorthWest.lat);
        var northEast = new maptalks.Coordinate(tmpNorthEast.lon,tmpNorthEast.lat);

        var width = mapObj.getProjection().measureLenBetween(northWest, northEast);
        //宽
        var height = mapObj.getProjection().measureLenBetween(northWest, southWest);
        //高

        //console.debug('矩形：', arrayX, arrayY, northWest, width, height);

        var polygon = new maptalks.Rectangle(northWest,width,height,{
            symbol: {
                'lineColor': lineColor,
                //线颜色
                'lineWidth': 3,
                //线宽
                'textName': polygonName,
                //显示文本
                'textHaloFill': '#fff',
                'textHaloRadius': 2,
                'polygonFill': fillColor,
                //填充色
                'polygonOpacity': 0.4 //填充透明度
            },
            extData: {
                name: polygonName
            }
        });

        if (polygonList.containsKey(polygonName)) //已存在同名的则先移除
        {
            var delP = polygonList.getValue(polygonName);
            deletePolygon(delP);
        }
        polygonList.add(polygonName, polygon);
        //新数组中增加新增加的多边形
        polygon.addTo(_vLayers['polygon'].layer);
        //添加到区域图层
        if (isZoom) {
            var extent = polygon.getExtent();
            mapObj.fitExtent(extent, 0);
        }
    }

    this.showPolygon = function(polygonName, arrayX, arrayY, isZoom, lineColor, fillColor) {
        var pathArr = [];
        var tmpLonLat;
        var length = arrayX.length;
        if (length < 3)
            return;
        if (lineColor == undefined) {
            lineColor = '#3CA2FA';
        }

        if (fillColor == undefined) {
            fillColor = "#00b0ff"
        }
        for (var i = 0; i < length; i++) {
            tmpLonLat = _coordConvertIn(arrayY[i], arrayX[i]);
            pathArr.push([tmpLonLat.lon, tmpLonLat.lat])
        }

        //var markLabel = new AMap.Marker({
        //    //content: polygonName,
        //    content: '<span style="background-color:#f4f4f4;white-space:nowrap;">' + polygonName + '</span>',
        //    offset: new AMap.Pixel(10, -10),
        //    visible: MapLayerSwitcher.polygon
        //});
        var polygon = new maptalks.Polygon(pathArr,{
            symbol: {
                'lineColor': lineColor,
                //线颜色
                'lineWidth': 3,
                //线宽
                'textName': polygonName,
                //显示文本
                'textHaloFill': '#fff',
                'textHaloRadius': 2,
                'polygonFill': fillColor,
                //填充色
                'polygonOpacity': 0.4 //填充透明度
            },
            extData: {
                name: polygonName
            }
        });

        if (polygonList.containsKey(polygonName)) //已存在同名的则先移除
        {
            var delP = polygonList.getValue(polygonName);
            deletePolygon(delP);
        }
        polygonList.add(polygonName, polygon);
        //新数组中增加新增加的多边形
        polygon.addTo(_vLayers['polygon'].layer);
        //添加到区域图层

        if (isZoom) {
            var extent = polygon.getExtent();
            mapObj.fitExtent(extent, 0);
        }
    }

    var deletePolygon = function(polygon) {
        var extData = _getExtData(polygon);
        polygon.remove();
        polygonList.remove(extData.name);
        delete polygon;
    }

    //按区域名称清除（包含圆形、矩形、多边形）
    this.clearPolygon = function(polygonName) {
        if (circleList.containsKey(polygonName)) //已存在同名的则移除
        {
            var delC = circleList.getValue(polygonName);
            deleteCircle(delC);
        }

        if (polygonList.containsKey(polygonName)) //已存在同名的则移除
        {
            var delP = polygonList.getValue(polygonName);
            deletePolygon(delP);
        }
    }

    this.clearAllPolygon = function() {
        var circleArray = circleList.getHashTable();
        for (i in circleArray) {
            deleteCircle(circleArray[i]);
        }

        var polygonArray = polygonList.getHashTable();
        for (j in polygonArray) {
            deletePolygon(polygonArray[j]);
        }
    }

    /**
     * 在地图上显示路线
     * @param {any} polylineName     路线名称
     * @param {any} arrayX           经度数组
     * @param {any} arrayY           纬度数组
     * @param {any} isZoom           是否在可视范围内显示
     * @param {any} lineColor        路线颜色
     * @param {any} isShowDirection  是否显示方向
     * @param {any} splitMarkerIndexArr  拆分点在path 数组中的下标
     */
    this.showPolyline = function(polylineName, arrayX, arrayY, isZoom, lineColor, isShowDirection, splitMarkerIndexArr, extraParams) {
        var pathArr = [];
        var tmpLonLat;
        var bShowDirect = false;
        var length = arrayX.length;
        if (length < 2)
            return;
        if (lineColor == undefined) {
            lineColor = '#3366FF';
        }
        if (isShowDirection) {
            bShowDirect = true;
        }

        if (!extraParams) {
            extraParams = {};
            extraParams.isShowDirectionImage = false;
        }

        for (var i = 0; i < length; i++) {
            tmpLonLat = _coordConvertIn(arrayY[i], arrayX[i]);
            pathArr.push([tmpLonLat.lon, tmpLonLat.lat])
        }

        //画路线拆分点
        if (splitMarkerIndexArr && splitMarkerIndexArr.length >= 1) {
            _drawSplitMarkers(pathArr, splitMarkerIndexArr)
        }

        var dg = getDegreeXY(pathArr[0][0], pathArr[0][1], pathArr[1][0], pathArr[1][1])

        //console.log('degree', dg);

        var polyline = new maptalks.LineString(pathArr,{
            symbol: {
                'linePatternFile': extraParams.isShowDirectionImage ? '../Images/polyline_direction.png' : '',
                //'lineDasharray': [10, 20],//虚线设置
                ////'linePatternDx': 0,
                'lineColor': lineColor,
                'lineWidth': extraParams.isShowDirectionImage ? 10 : 3,
                'lineJoin': 'round',
                //miter, round, bevel
                'lineCap': 'round',
                //butt, round, square
                'textName': polylineName,
                'textPlacement': 'vertex-first',
                //起始点显示路线名称
                //'textFill': '#444', //字体颜色
                'textHaloFill': '#fff',
                'textHaloRadius': 2,
                'textDy': -20,
                'textRotation': dg
            },
            arrowStyle: bShowDirect ? 'classic' : null,
            // we only have one arrow style now
            arrowPlacement: bShowDirect ? 'point' : null,
            //vertex-first, vertex-last, vertex-firstlast, point
            extData: {
                name: polylineName
            }
        });

        if (polylineList.containsKey(polylineName)) //已存在同名的则先移除
        {
            var delP = polylineList.getValue(polylineName);
            deletePolyline(delP);
        }
        polylineList.add(polylineName, polyline);
        //新数组中增加新增加的多边形
        polyline.addTo(_vLayers['polyline'].layer);
        if (isZoom) {
            var extent = polyline.getExtent();
            mapObj.fitExtent(extent, 0);
        }
    }

    function _drawSplitMarkers(path, arr) {
        _splitPointArr = arr;
        //画点
        for (i in arr) {
            //画拆分点
            let splitMarker = new maptalks.Marker(path[arr[i]],{
                zIndex: 121,
                symbol: {
                    markerFile: '../Images/poi/point.png',
                    markerWidth: 16,
                    markerHeigh: 16,
                    markerDx: 0,
                    markerDy: 8,
                    markerOpacity: 1
                },
                extData: {
                    index: arr[i]
                }
            }).addTo(_vLayers['polyline'].layer);

            _splitPolylineMarkerList.add(i, splitMarker)

            splitMarker.on('mouseenter', function(e) {
                //重新画关闭icon
                if (_splitPolylineCloseMarker) {
                    _splitPolylineCloseMarker.remove();
                    _splitPolylineCloseMarker = null
                }

                if (!_splitPolylineCloseMarker && _splitPolylineFlag) {
                    _splitPolylineCloseMarker = new maptalks.Marker(path[e.target.options.extData.index],{
                        symbol: {
                            markerFile: '../Images/remove.png',
                            markerWidth: 16,
                            markerHeigh: 16,
                            markerDx: 10,
                            markerDy: -10,
                            markerOpacity: 1
                        },
                        extData: {
                            index: e.target.options.extData.index
                        }
                    }).addTo(_vLayers['polyline'].layer);

                    _splitPolylineCloseMarker.on("click", function(a) {
                        e.target.remove();
                        a.target.remove();
                        //去除拆分点
                        _splitPointArr.forEach((item,index)=>{
                                if (item == e.target.options.extData.index) {
                                    _splitPointArr.splice(index, 1)
                                }
                            }
                        )
                        let splitPathArr = _splitPolyline(path, _splitPointArr)
                        if (_splitePolylinecallback) {
                            _splitePolylinecallback(splitPathArr, _splitPointArr)

                        }
                    })

                }

            })
        }

    }
    function _deleteSplitMarkers() {
        _splitPointArr = []
        let markerArr = _splitPolylineMarkerList.getValues();
        if (markerArr.length >= 1) {
            for (i in markerArr) {
                markerArr[i].remove();
            }
        }
        if (_splitPolylineCloseMarker) {
            _splitPolylineCloseMarker.remove();
        }
        _splitPolylineMarkerList.clear();
    }

    let _splitPolylineFlag = false
    let _splitPolylineMovingMarker = null;
    let _splitPolylineCloseMarker = null;
    let _splitPointArr = [];
    let _splitPolylineName = ""
    let _splitPolylineMarkerList = new HashTable();
    let _splitPolylineMarkerMouseoverListener = null;
    let _splitPolylineMarkerClickListener = null;
    let _splitPolylineMarkerMouseoutListener = null;
    let _splitePolylinecallback = null;

    /**
     * 拆分路线
     * @param {any} polylineName
     */
    this.polyline_startSplit = function(polylineName, callback) {
        _splitPolylineName = polylineName
        _splitePolylinecallback = callback;
        _splitPolylineFlag = true
        var path = null;
        var minDistance;
        var minIndex = 0;
        var tmpDistance;

        //获取要拆分的线段
        let polyline = polylineList.getValue(polylineName);

        if (!polyline) {
            alert("拆分的线段不存在！")
            return false;
        }

        //线段移动事件监听
        _splitPolylineMarkerMouseoverListener = function(e) {
            path = e.target.getCoordinates();
            //获取线段上离鼠标最近的点的 index
            for (i in path) {
                if (i == 0) {
                    minDistance = tmpDistance = mapObj.getProjection().measureLenBetween(e.coordinate, path[i]);
                    minIndex = i;
                } else {
                    tmpDistance = mapObj.getProjection().measureLenBetween(e.coordinate, path[i]);
                    if (tmpDistance < minDistance) {
                        minDistance = tmpDistance;
                        minIndex = i;
                    }
                }
            }
            //绘制移动的点
            if (e.target.containsPoint(path[minIndex])) {
                if (_splitPolylineMovingMarker) {
                    //鼠标在在线段上移动的时候，线段上要显示将要拆分的点
                    _splitPolylineMovingMarker.setCoordinates(path[minIndex]);
                } else {
                    _splitPolylineMovingMarker = new maptalks.Marker(path[minIndex],{
                        zIndex: 121,
                        'symbol': {
                            'markerFile': '../Images/poi/point.png',
                            'markerWidth': 16,
                            'markerHeight': 16,
                            'markerDx': 0,
                            'markerDy': 8,
                            'markerOpacity': 1
                        }
                    }).addTo(_vLayers['polyline'].layer);
                }

            }
        }
        //绑定
        polyline.on('mouseover', _splitPolylineMarkerMouseoverListener)

        //线段点击事件监听
        _splitPolylineMarkerClickListener = function() {
            if (minIndex == 0 || minIndex == path.length - 1) {
                alert("起点终点不允许拆分");
                return;
            }

            if (_splitPointArr.indexOf(parseInt(minIndex)) > -1) {
                alert("该拆分点已存在");
                return;
            }
            //画拆分点
            let splitMarker = new maptalks.Marker(path[minIndex],{
                zIndex: 121,
                symbol: {
                    markerFile: '../Images/poi/point.png',
                    markerWidth: 16,
                    markerHeigh: 16,
                    markerDx: 0,
                    markerDy: 8,
                    markerOpacity: 1
                },
                extData: {
                    index: minIndex
                }
            }).addTo(_vLayers['polyline'].layer);

            _splitPolylineMarkerList.add(minIndex, splitMarker)

            splitMarker.on('mouseenter', function(e) {
                //重新画关闭icon
                if (_splitPolylineCloseMarker) {
                    _splitPolylineCloseMarker.remove();
                    _splitPolylineCloseMarker = null
                }

                if (!_splitPolylineCloseMarker && _splitPolylineFlag) {
                    _splitPolylineCloseMarker = new maptalks.Marker(path[e.target.options.extData.index],{
                        zIndex: 121,
                        symbol: {
                            markerFile: '../Images/remove.png',
                            markerWidth: 16,
                            markerHeigh: 16,
                            markerDx: 10,
                            markerDy: -10,
                            markerOpacity: 1
                        },
                        extData: {
                            index: e.target.options.extData.index
                        }
                    }).addTo(_vLayers['polyline'].layer);

                    _splitPolylineCloseMarker.on("click", function(a) {
                        e.target.remove();
                        a.target.remove();
                        //去除拆分点
                        _splitPointArr.forEach((item,index)=>{
                                if (item == e.target.options.extData.index) {
                                    _splitPointArr.splice(index, 1)
                                }
                            }
                        )
                        let splitPathArr = _splitPolyline(path, _splitPointArr)
                        callback(splitPathArr, _splitPointArr)
                    })

                }

            })

            _splitPointArr.push(parseInt(minIndex));
            let splitPathArr = _splitPolyline(path, _splitPointArr)

            callback(splitPathArr, _splitPointArr)

        }
        //绑定
        polyline.on('click', _splitPolylineMarkerClickListener)

        _splitPolylineMarkerMouseoutListener = function() {
            if (_splitPolylineMovingMarker) {
                _splitPolylineMovingMarker.remove();
                _splitPolylineMovingMarker = null
            }
        }
        //去掉绘制的移动点
        polyline.on('mouseout', _splitPolylineMarkerMouseoutListener)
        return true;
    }
    //根据拆分点 拆分线段
    function _splitPolyline(path, arr) {
        //先加path 中的点  转换输出坐标
        let outPath = []
        for (i in path) {
            var lonlat = _coordConvertOut(path[i].y, path[i].x);
            outPath.push(lonlat);
        }
        let tmepPathArr = []
        let compare = function(v1, v2) {
            if (v1 < v2) {
                return -1;
            } else if (v2 < v1) {
                return 1
            } else {
                return 0
            }

        }
        let newArr = arr.sort(compare);
        let tempIndex = 0
        newArr.forEach(index=>{
                let tempArr = outPath.slice(tempIndex, index + 1)
                tempIndex = index
                tmepPathArr.push(tempArr)
            }
        )

        tmepPathArr.push(outPath.slice(tempIndex))
        return tmepPathArr
    }

    this.polyline_endSplit = function(polylineName) {
        _splitPolylineName = ""
        //获取要拆分的线段
        let polyline = polylineList.getValue(polylineName);
        if (!polyline) {
            return false;
        }
        _splitPolylineFlag = false;
        polyline.off('mouseover', _splitPolylineMarkerMouseoverListener)
        polyline.off('click', _splitPolylineMarkerClickListener)
        polyline.off('mouseout', _splitPolylineMarkerMouseoutListener)

        if (_splitPolylineCloseMarker) {
            _splitPolylineCloseMarker.remove();
        }

        _splitPolylineMovingMarker = null;
        _splitPolylineMarkerClickListener = null;
        _splitPolylineMarkerMouseoverListener = null;
        _splitPolylineMarkerMouseoutListener = null;
        _splitePolylinecallback = null;
        return true;

    }

    //计算画线时，线的名称旋转角度
    function getDegreeXY(x1, y1, x2, y2) {
        if (y1 == y2)
            return x2 >= x1 ? 0 : 180;
        //计算角度 纯数学运算
        var tmpDistance_x = mapObj.getProjection().measureLenBetween(new maptalks.Coordinate(x2,y1), new maptalks.Coordinate(x2,y2));
        //Y向距离
        var tmpDistance_c = mapObj.getProjection().measureLenBetween(new maptalks.Coordinate(x1,y1), new maptalks.Coordinate(x2,y2));
        //三角形斜边距离
        //console.log('x c', tmpDistance_x, tmpDistance_c);
        var r = Math.asin(tmpDistance_x * 1.0 / tmpDistance_c) * 180 / 3.141592653;

        if (x2 >= x1) {
            if (y2 > y1) {
                //第一象限
                r = -1 * r;
            } else {
                //第四象限
                r = r;
            }
        } else {
            if (y2 > y1) {
                //第二象限
                r = r - 180;
            } else {
                //第三象限
                r = 180 - r;
            }
        }
        return r;
    }

    function deletePolyline(polyline) {
        var extData = _getExtData(polyline);
        //移除编辑路线工具
        var lineEditor = polylineEditerList.getValue(extData.name);
        if (lineEditor != null) {
            lineEditor.endEdit();
            polylineEditerList.remove(extData.name);
        }

        polyline.remove();
        polylineList.remove(extData.name);
        delete polyline;
    }

    this.clearPolyline = function(polylineName) {
        if (polylineList.containsKey(polylineName)) //已存在同名的则移除
        {
            var delP = polylineList.getValue(polylineName);
            if (_splitPolylineName == polylineName) {
                //清除线段是拆分线段时
                _deleteSplitMarkers();
                //删除拆分点
            }
            deletePolyline(delP);
        }
    }
    this.clearAllPolyline = function() {
        var polylineArray = polylineList.getHashTable();
        for (i in polylineArray) {
            deletePolyline(polylineArray[i]);
        }
        _deleteSplitMarkers();
        //删除拆分点
    }
    //#endregion
    /*****区域路线end*****/
    /************画车begin***************/
    //#region 画车
    /// <summary>
    /// 显示车辆
    /// </summary>
    /// <param name="labeltext">显示车牌号</param>
    /// <param name="x">经度</param>
    /// <param name="y">纬度</param>
    /// <param name="direction">方向--int类型有效</param>
    /// <param name="iconType">图标类型</param>
    /// <param name="isZoom">是否居中</param>
    /// <param name="popContent">提示文本 </param>
    /// <param name="carStatus">车状态 1为报警车， "99"为空图标 ，（"11"为报警、ACC开且速度=0 ，"12"为正常、ACC开、空车且速度=0, "13"为正常、ACC开、 重车且速度=0），其他为正常车</param>
    /// <param name="alarmType">报警类型(无用)</param>
    /// <param name="isFill">是否重车 </param>
    /// <param name="accOn">是否点火</param>
    /// <param name="gpsValid">是否有GPS信号</param>
    /// <param name="vehicleId">车辆唯一ID</param>
    /// <param name="isShowTrack">是否显示轨迹</param>
    /// <param name="speed">速度</param>
    /// <param name="clickCallback">点击后回调函数 function(MarkerOption)</param>
    /// <param name="showCallback">画完车后回调函数 function(MarkerOption)</param>
    /// <param name="bFastMode">是否快速画车，true,马上画-用于双击车辆快速显示等功能</param>
    /// <param name="trackColor">轨迹线颜色</param>
    /// <param name="gpsTime">gps时间</param>
    /// <param name="textColor">文字颜色</param>
    this.showVehicle = function(labeltext, x, y, direction, iconType, isZoom, popContent, carStatus, alarmType, isFill, accOn, gpsValid, vehicleId, isShowTrack, speed, clickCallback, showCallback, bFastMode, trackColor, gpsTime, textColor) {
        var showVehicleOption = new ShowVehicleOption();
        showVehicleOption.labeltext = labeltext;
        showVehicleOption.x = x;
        showVehicleOption.y = y;
        showVehicleOption.direction = direction;
        showVehicleOption.iconType = iconType;
        showVehicleOption.isZoom = isZoom;
        showVehicleOption.popContent = popContent;
        showVehicleOption.carStatus = carStatus;
        showVehicleOption.alarmType = alarmType;
        showVehicleOption.isFill = isFill;
        showVehicleOption.accOn = accOn;
        showVehicleOption.gpsValid = gpsValid;
        showVehicleOption.vehicleId = vehicleId.toString();
        showVehicleOption.isShowTrack = isShowTrack;
        showVehicleOption.speed = speed;
        showVehicleOption.clickCallback = clickCallback;
        showVehicleOption.showCallback = showCallback;
        showVehicleOption.bFastMode = bFastMode;
        showVehicleOption.trackColor = trackColor;
        showVehicleOption.gpsTime = gpsTime;
        showVehicleOption.textColor = textColor;
        //文字颜色
        this.showVehicleNew(showVehicleOption);
        showVehicleOption = null;
    }
    //新的画车方式
    this.showVehicleNew = function(showVehicleOption) {
        //console.log('show vehicle New', showVehicleOption);
        //var position = _coordConvertIn(showVehicleOption.y, showVehicleOption.x);
        var icon = GetVehicleIcon(showVehicleOption.iconType, showVehicleOption.carStatus, showVehicleOption.gpsValid, showVehicleOption.accOn, showVehicleOption.isFill, showVehicleOption.direction, showVehicleOption.speed);
        var markOption = new MarkerOption("vehicle",showVehicleOption.vehicleId,icon,showVehicleOption.x,showVehicleOption.y,null,null,showVehicleOption.labeltext,showVehicleOption.popContent,showVehicleOption.isZoom,showVehicleOption.textColor,showVehicleOption.gpsTime,showVehicleOption.direction);
        //小尾巴功能option增加两个内部参数
        markOption.ticks = MapCommon.getTicks(showVehicleOption.gpsTime);
        markOption.speed = showVehicleOption.speed;

        if (showVehicleOption.isShowTrack) //画轨迹
        {
            if (!_bTrackMode) {
                //地图全局 画轨迹模式
                _mapApi.setTrackMode(true);
            }
            var trackColor = showVehicleOption.trackColor;
            if (trackColor == null || trackColor == '') {
                trackColor = (showVehicleOption.carStatus == "1" ? "#FF0000" : "#3366FF");
            }
            _showTrack(showVehicleOption.vehicleId, trackColor, markOption, function(e) {
                if (e == null)
                    return;
                var tmpOption;
                if (e.target != undefined) {
                    tmpOption = _getExtData(e.target);
                } else {
                    tmpOption = e;
                }
                if (showVehicleOption.clickCallback)
                    showVehicleOption.clickCallback(tmpOption);
                //停止事件冒泡
                //return false;
                if (_mapApi.mouseCurrCursor == 'default' || _mapApi.mouseCurrCursor == 'pan' || _mapApi.mouseCurrCursor == 'trackPoint')
                    return false;
            }, showVehicleOption.showCallback);
        } else {
            //画车
            drawMarker(markOption, function(e) {
                if (e == null)
                    return;
                var tmpOption;
                if (e.target != undefined) {
                    tmpOption = _getExtData(e.target);
                } else {
                    tmpOption = e;
                }
                _mapApi.clickedVehicleId = showVehicleOption.vehicleId;
                //if (_mapApi.isShowVehicleInfoWindow) {
                //    if (e.target.getExtData().popContent != '') {
                //        _showInfoWindow(e.target.getExtData().popContent, e.target.getPosition());
                //    }
                //}
                if (showVehicleOption.clickCallback)
                    showVehicleOption.clickCallback(tmpOption);

                //停止事件冒泡
                //return false;
                if (_mapApi.mouseCurrCursor == 'default' || _mapApi.mouseCurrCursor == 'pan' || _mapApi.mouseCurrCursor == 'trackPoint')
                    return false;
            }, showVehicleOption.showCallback, showVehicleOption.bFastMode);
        }
    }
    //设置当前车
    this.setTrackingVehicle = function(vehicleId) {
        if (vehicleId != _currVehicleId) {
            _currVehicleId = vehicleId;
            _mapApi.clickedVehicleId = _currVehicleId;
            //删除旧的当前车
            if (_currVehicleMarker != null) {
                if (_currVehicleMarker.getLayer() != null && MapParam.isOpenVehicleCluser) {
                    //旧的当前车若还显示在地图上则回归聚合点
                    _currVehicleMarker.remove().addTo(_clusterList["vehicle"]);
                }
                _currVehicleMarker = null;
            }
        }

        var marker = markerArray["vehicle"].getValue(vehicleId);
        if (marker != null) {
            _setTrackingMarker(vehicleId, marker);
        }
    }

    //设置当前车marker
    var _setTrackingMarker = function(vehicleId, marker) {
        if (marker == null) {
            return;
        }
        var p = marker.getCoordinates();
        var layer = marker.getLayer();
        //console.log('_setTrackingMarker layer', layer);
        if (layer != null) {
            if ((layer instanceof maptalks.ClusterLayer)) {
                //若在聚合图层则移除并添加到普通图层
                marker.remove().addTo(_vLayers['vehicle'].layer);
            }
        } else {
            marker.addTo(_vLayers['vehicle'].layer);
        }
        marker.bringToFront();

        if (_mapApi.userConfig) {
            //存在用户配置
            if (_mapApi.userConfig.trackingVehicleZoom == -1) {
                if (mapObj.getZoom() < MapParam.trackingVehicleZoom) {
                    //默认 -1
                    mapObj.setCenterAndZoom(p, MapParam.trackingVehicleZoom);
                } else {
                    mapObj.setCenter(p);
                }

            } else {
                if (_mapApi.userConfig.trackingVehicleZoom != 0) {
                    if (mapObj.getZoom() < _mapApi.userConfig.trackingVehicleZoom) {
                        //缩放
                        mapObj.setCenterAndZoom(p, _mapApi.userConfig.trackingVehicleZoom);
                    } else {
                        mapObj.setCenter(p);
                    }

                } else {
                    //不缩放 0
                    mapObj.setCenter(p);
                }
            }
        } else {
            //无用户配置
            if (mapObj.getZoom() < MapParam.trackingVehicleZoom) {
                mapObj.setCenterAndZoom(p, MapParam.trackingVehicleZoom);
                ;
            } else {
                mapObj.setCenter(p);
            }
        }

        _currVehicleMarker = marker;

        if (_mapApi.isShowCurrVehicleBg) //需要显示背景图
        {
            if (_currVehicleBgMarker == null) {
                var tmpCurrentIcon = new MapCurrentVehicleIcon();
                var newOffset = TMapCommon.getOffset(tmpCurrentIcon.iconSize, tmpCurrentIcon.offset);
                _currVehicleBgMarker = new maptalks.Marker(p,{
                    zIndex: 121,
                    'symbol': {
                        'markerFile': tmpCurrentIcon.path,
                        'markerWidth': tmpCurrentIcon.iconSize.width,
                        'markerHeight': tmpCurrentIcon.iconSize.height,
                        'markerDx': newOffset.x,
                        'markerDy': newOffset.y //'markerOpacity': 1
                    }

                });
                _currVehicleBgMarker.addTo(_vLayers['vehicle'].layer);
            } else {
                _currVehicleBgMarker.setCoordinates(p);
            }

            _currVehicleBgMarker.show();

            if (_currVehicleTimeout) {
                clearTimeout(_currVehicleTimeout);
                _currVehicleTimeout = null;
            }
            _currVehicleTimeout = setTimeout(function() {
                //marker.setTop(false);
                _currVehicleBgMarker.hide();
            }, 3000);
            //3秒后自动取消
        }
    }

    this.deleteVehicle = function(vehicleId, bFastMode) {
        //test
        //document.getElementById('ttt').value = 'called deleteVehicle ' + '\r\n' + document.getElementById('ttt').value;
        if (bFastMode == undefined)
            bFastMode = false;
        deleteMarker('vehicle', vehicleId, bFastMode);
    }
    this.deleteAllVehicle = function() {
        //test
        //document.getElementById('ttt').value = 'called deleteAllVehicle ' + '\n' + document.getElementById('ttt').value;

        removeAllMarker('vehicle');
    }

    var _showTrack = function(vehicleId, carStatus, markOption, clickCallback, showCallback) {
        if (!_trackList[vehicleId]) {
            _trackList[vehicleId] = {
                options: [],
                lines: [],
                lastDrawTime: 0,
                lastPoint: null,
                drawnIndex: 0,
                drawingCarStatus: "2",
                drawing: false,
                timeOut: null
            };
        }

        var vTrack = _trackList[vehicleId];
        var bPointValid = true;

        if (markOption.gpslng == 0.0 || markOption.gpslat == 0.0) {
            if (vTrack.lastPoint) {
                //markOption.lng = vTrack.lastPoint.lng;
                //markOption.lat = vTrack.lastPoint.lat;
                markOption.glng = vTrack.lastPoint.glng;
                markOption.glat = vTrack.lastPoint.glat;
            }
            bPointValid = false;
        }
        //if (carStatus != vTrack.needDrawCarStatus) {
        //    if (vTrack.lastPoint) {
        //        _drawTrackLine(vTrack);
        //    }
        //    vTrack.needDrawCarStatus = carStatus;
        //}

        //轨迹数组添加该点
        vTrack.options.push({
            option: markOption,
            carStatus: carStatus,
            callback: clickCallback,
            showCallback: showCallback
        });

        if (vTrack.lastPoint) {
            //已存在有效点 则可以进行画线，需两点才可能画线
            if (!vTrack.drawing) {
                if (vTrack.timeOut == null) {
                    vTrack.timeOut = setTimeout(function() {
                        if (vTrack.drawing) {
                            return;
                        }
                        _drawTrackLine(vTrack, vehicleId);
                        /*画轨迹*/

                    }, MapParam.drawVehicleTrackLineTime);
                    //100
                }
            }
        }
        vTrack.needDrawCarStatus = carStatus;

        if (bPointValid) {
            vTrack.lastPoint = {
                gpslng: markOption.gpslng,
                gpslat: markOption.gpslat
            };
        }
    }

    var _drawTrackLine = function(vTrack, vehicleId) {
        vTrack.drawing = true;

        if (vTrack.drawnIndex == vTrack.options.length - 1) {
            vTrack.drawing = false;
            if (console)
                //console.log('track completed');
                return;
        }
        try {
            var lineObj = null;
            var bNewLine;
            var pathPoints;
            var tmpOption;
            var p;
            if (vTrack.drawnIndex == 0) {
                bNewLine = true;
                pathPoints = [];
                p = _coordConvertIn(vTrack.options[0].option.gpslat, vTrack.options[0].option.gpslng)
                pathPoints.push([p.lon, p.lat]);
                vTrack.drawingCarStatus = vTrack.options[0].carStatus;
            } else if (vTrack.drawingCarStatus != vTrack.options[vTrack.drawnIndex + 1].carStatus) {
                bNewLine = true;
                pathPoints = [];
                //pathPoints.push([vTrack.options[vTrack.drawnIndex].option.lng, vTrack.options[vTrack.drawnIndex].option.lat])
                p = _coordConvertIn(vTrack.options[vTrack.drawnIndex].option.gpslat, vTrack.options[vTrack.drawnIndex].option.gpslng);
                pathPoints.push([p.lon, p.lat]);
                vTrack.drawingCarStatus = vTrack.options[vTrack.drawnIndex + 1].carStatus;
            } else {
                lineObj = vTrack.lines[vTrack.lines.length - 1];
                if (lineObj.pointCount < MapParam.trackLineMaxPointCount) {
                    pathPoints = lineObj.polyline.getCoordinates();
                    bNewLine = false;
                } else {
                    bNewLine = true;
                    pathPoints = [];
                    //pathPoints.push([vTrack.options[vTrack.drawnIndex].option.lng, vTrack.options[vTrack.drawnIndex].option.lat])
                    p = _coordConvertIn(vTrack.options[vTrack.drawnIndex].option.gpslat, vTrack.options[vTrack.drawnIndex].option.gpslng);
                    pathPoints.push([p.lon, p.lat]);
                }
            }

            var len = vTrack.options.length;
            for (var tmpIndex = vTrack.drawnIndex + 1; tmpIndex < len; tmpIndex++) {
                tmpOption = vTrack.options[tmpIndex];
                //线段变色、单条线段点数已满，这两种情况需要画到上个点轨迹
                //轨迹点遍历结束 画到当前点轨迹
                if (tmpOption.carStatus != vTrack.drawingCarStatus || pathPoints.length == vTrack.trackLineMaxPointCount) {
                    //画轨迹
                    if (bNewLine) {
                        let lineSymbol = {
                            //'linePatternFile':'../Images/direction.png',
                            'lineColor': vTrack.drawingCarStatus,
                            'lineWidth': defaultTrackLineWidth,
                            'lineJoin': 'round',
                            //miter, round, bevel
                            'lineCap': 'round',
                            //butt, round, square
                        };

                        //显示箭头的时候  用箭头替代轨迹点
                        if (MapParam.isShowAllTrackPoint && !showTrackDirction) {
                            //显示所有轨迹点

                            //有的浏览器 不支持es6 语法
                            lineSymbol = {
                                'lineColor': vTrack.drawingCarStatus,
                                'lineWidth': defaultTrackLineWidth,
                                'lineJoin': 'round',
                                //miter, round, bevel
                                'lineCap': 'round',
                                //butt, round, square
                                "markerType": "ellipse",
                                "markerPlacement": "point",
                                //vertex, point, vertex-first, vertex-last, center
                                "markerFill": vTrack.drawingCarStatus,
                                "markerLineColor": vTrack.drawingCarStatus,
                                "markerWidth": 10,
                                "markerHeight": 10
                            }
                        }

                        //lineString
                        polyline = new maptalks.LineString(pathPoints,{
                            symbol: lineSymbol,
                            enableSimplify: !MapParam.isShowAllTrackPoint,
                            //是否精简轨迹
                            arrowStyle: showTrackDirction ? 'classic' : null,
                            // we only have one arrow style now MapParam.isShowTrackDirection
                            arrowPlacement: showTrackDirction ? 'point' : null,
                            //vertex-first, vertex-last, vertex-firstlast, point
                            extData: {
                                startIndex: vTrack.drawnIndex,
                                vehicleId: vehicleId
                            }//extData, 线路的起始点、车辆id
                        });
                        polyline.on('mouseover', _trackLineMouseOverHandler);
                        vTrack.lines.push({
                            polyline: polyline,
                            pointCount: pathPoints.length,
                            startIndex: vTrack.drawnIndex,
                            carStatus: vTrack.drawingCarStatus
                        });
                        polyline.addTo(_vLayers['polyline'].layer);
                        //test
                        //if (showTestMsg)
                        //    showTestMsg('draw new line ');
                    } else {
                        lineObj.pointCount = pathPoints.length;
                        lineObj.polyline.setCoordinates(pathPoints);
                    }

                    var last = pathPoints[pathPoints.length - 1];
                    pathPoints = [];
                    pathPoints.push(last);
                    bNewLine = true;
                    vTrack.drawnIndex = tmpIndex - 1;

                    drawMarkerFast(vTrack.options[vTrack.drawnIndex].option, vTrack.options[vTrack.drawnIndex].callback);
                    //vTrack.lastDrawTime = (new Date()).getTime();
                }

                //pathPoints.push([tmpOption.option.lng, tmpOption.option.lat]);
                p = _coordConvertIn(tmpOption.option.gpslat, tmpOption.option.gpslng);
                pathPoints.push([p.lon, p.lat]);
                vTrack.drawingCarStatus = tmpOption.carStatus;
                //if (MapParam.isShowAllTrackPoint)--pengh  轨迹点在线上生成。
                //  _drawTrackPoint(tmpIndex - 1, vTrack.options[tmpIndex - 1].option, vTrack.options[tmpIndex - 1].callback);

                if (tmpIndex == len - 1) {
                    //画轨迹
                    if (bNewLine) {
                        let lineSymbol = {
                            //'linePatternFile': '../Images/direction.png',//
                            'lineColor': vTrack.drawingCarStatus,
                            'lineWidth': defaultTrackLineWidth,
                            'lineJoin': 'round',
                            //miter, round, bevel
                            'lineCap': 'round',
                            //butt, round, square
                        };

                        //显示箭头的时候  用箭头替代轨迹点
                        if (MapParam.isShowAllTrackPoint && !showTrackDirction) {
                            //显示所有轨迹点
                            lineSymbol = {
                                'lineColor': vTrack.drawingCarStatus,
                                'lineWidth': defaultTrackLineWidth,
                                'lineJoin': 'round',
                                //miter, round, bevel
                                'lineCap': 'round',
                                //butt, round, square
                                "markerType": "ellipse",
                                "markerPlacement": "point",
                                //vertex, point, vertex-first, vertex-last, center
                                "markerFill": vTrack.drawingCarStatus,
                                "markerLineColor": vTrack.drawingCarStatus,
                                "markerWidth": 10,
                                "markerHeight": 10
                            }
                        }

                        polyline = new maptalks.LineString(pathPoints,{
                            symbol: lineSymbol,
                            enableSimplify: !MapParam.isShowAllTrackPoint,
                            //是否精简轨迹
                            arrowStyle: showTrackDirction ? 'classic' : null,
                            // we only have one arrow style now
                            arrowPlacement: showTrackDirction ? 'point' : null,
                            //vertex-first, vertex-last, vertex-firstlast, point
                            extData: {
                                startIndex: vTrack.drawnIndex,
                                vehicleId: vehicleId
                            }//extData, 线路的起始点、车辆id
                        });
                        polyline.on('mouseover', _trackLineMouseOverHandler);
                        vTrack.lines.push({
                            polyline: polyline,
                            pointCount: pathPoints.length,
                            startIndex: vTrack.drawnIndex,
                            carStatus: vTrack.drawingCarStatus
                        });
                        polyline.addTo(_vLayers['polyline'].layer);
                    } else {
                        lineObj.pointCount = pathPoints.length;
                        lineObj.polyline.setCoordinates(pathPoints);
                    }
                    vTrack.drawnIndex = tmpIndex;
                    drawMarkerFast(vTrack.options[vTrack.drawnIndex].option, vTrack.options[vTrack.drawnIndex].callback);

                    //vTrack.lastDrawTime = (new Date()).getTime();
                    break;
                }

            }
            vTrack.drawing = false;
            vTrack.timeOut = null;
            if (vTrack.drawnIndex < vTrack.options.length - 1) {
                vTrack.timeOut = setTimeout(function() {
                    if (vTrack.drawing) {
                        return;
                    }
                    _drawTrackLine(vTrack, vehicleId);
                }, MapParam.drawVehicleTrackLineTime);
            }
        } catch (e) {
            vTrack.drawing = false;
            if (console)
                console.error(e);
        }
    }

    //画轨迹点 --废弃
    var _drawTrackPoint = function(index, vehicleMarkerOption, clickCallback) {
        var vehicleId = vehicleMarkerOption.key;
        var markerId = 'tkpt_' + vehicleId + '_' + index;
        var icon = MapParam.trackPointIcon;
        var callback = function(e) {
            setTimeout(function() {
                clickCallback(e);
                if (_trackPointCallback) {
                    _trackPointCallback(vehicleId, index);
                }
            }, 0);
            //return false;
            if (_mapApi.mouseCurrCursor == 'default' || _mapApi.mouseCurrCursor == 'pan' || _mapApi.mouseCurrCursor == 'trackPoint')
                return false;
        }
        var markerOption = new MarkerOption("poi",markerId,icon,vehicleMarkerOption.gpslng,vehicleMarkerOption.gpslat,null,null,"",vehicleMarkerOption.popContent,false);
        drawMarkerFast(markerOption, callback, null);
        //_HandlingMarkers.push({ handle: 'draw', type: markerOption.type, id: markerOption.key, option: markerOption, callback: callback, showCallback: null });
    }

    //#region 获取轨迹点
    var getTrackPointType = "";
    //取轨迹点去计算里程  start  起始轨迹点  end  结束轨迹点
    var getTrackPointHandler = null;
    //取点回调
    var trackPointIndexObj = {};
    // start  起始轨迹点  end  结束轨迹点
    this.getTrackPoint = function(callback) {
        getTrackPointType = "start";
        trackPointIndexObj = {};
        getTrackPointHandler = callback
    }
    //#endregion

    var _findingTrackPoint = false;

    //追踪鼠标附件的轨迹点
    var _trackLineMouseOverHandler = function(e) {
        //document.getElementById('ttt').value = e.pixel + '\n'+ document.getElementById('ttt').value;
        if (_mapApi.mouseCurrCursor != 'trackPoint')
            return false;
        if (_findingTrackPoint)
            return false;
        _findingTrackPoint = true;
        try {
            var extData = _getExtData(e.target);
            var path = e.target.getCoordinates();
            var minDistance;
            var minIndex = 0;
            var tmpDistance;
            for (i in path) {
                if (i == 0)
                    minDistance = tmpDistance = mapObj.getProjection().measureLenBetween(e.coordinate, path[i]);
                else {
                    tmpDistance = mapObj.getProjection().measureLenBetween(e.coordinate, path[i]);
                    if (tmpDistance < minDistance) {
                        minDistance = tmpDistance;
                        minIndex = i;
                    }
                }
            }
            minIndex = extData.startIndex + parseInt(minIndex);
            if (_trackList[extData.vehicleId] != null) {
                var option = _trackList[extData.vehicleId].options[minIndex].option;
                //20221212  修改  显示轨迹点 (添加获取开始轨迹点和结束轨迹点 用于计算里程)
                if (getTrackPointType == "start") {
                    _mapApi.showPoi("trackPointPOI_start", "", "", option.gpslng, option.gpslat, '', '', 'start', '6', false, false);
                    trackPointIndexObj.start = minIndex;
                } else if (getTrackPointType == 'end') {
                    _mapApi.showPoi("trackPointPOI_end", "", "", option.gpslng, option.gpslat, '', '', 'end', '6', false, false);
                    trackPointIndexObj.end = minIndex;
                } else {
                    _mapApi.showPoi("trackPointPOI", "", option.popContent, option.gpslng, option.gpslat, '', '', 'red', '2', false, false);
                    if (_mapApi.getInfoWindowOpenState()) {
                        var p = _coordConvertIn(option.gpslat, option.gpslng);
                        _showInfoWindow(option.popContent, new maptalks.Coordinate(p.lon,p.lat));
                    }
                }
            }
        } catch (e) {}
        _findingTrackPoint = false;
        //return false;
        if (_mapApi.mouseCurrCursor == 'default' || _mapApi.mouseCurrCursor == 'pan' || _mapApi.mouseCurrCursor == 'trackPoint')
            return false;
    }

    //设置轨迹的宽度 --pengh 20210331
    this.setTrackLineWidth = function(width) {
        //修改轨迹线默认宽度
        defaultTrackLineWidth = width;
        try {
            for (var key in _trackList) {
                var vTrack = _trackList[key];
                if (vTrack) {
                    if (vTrack.lines.length > 0) {
                        for (i in vTrack.lines) {
                            //获取每条polyline
                            vTrack.lines[i].polyline.updateSymbol({
                                'lineWidth': width
                            });
                        }
                    }
                }
            }
        } catch (e) {
        }
    }

    //是否显示轨迹方向
    this.showTrackLineDirection = function(flag) {
        showTrackDirction = flag
    }

    //清理单车所有轨迹
    this.clearTrack = function(vehicleId) {
        //test
        //if (showTestMsg)
        //    showTestMsg('called clearTrack ' + vehicleId);

        //deleteMarker('vehicle', vehicleId); //20170928 清除轨迹线时不清除车辆兼容旧GIS
        var clearlines = [];
        try {
            var vTrack = _trackList[vehicleId];
            if (vTrack) {
                if (vTrack.timeOut != null) {
                    //清除画轨迹的定时器
                    clearTimeout(vTrack.timeOut);
                    vTrack.timeOut = null;
                }

                //清除轨迹点
                var pointCount = vTrack.options.length;
                if (MapParam.isShowAllTrackPoint) {
                    //删除轨迹点
                    for (var i = 0; i < pointCount; i++) {
                        deleteMarker('poi', 'tkpt_' + vehicleId + '_' + i, true);
                    }
                }
                if (vTrack.lines.length > 0) {
                    for (i in vTrack.lines) {
                        clearlines.push(vTrack.lines[i].polyline);
                    }
                    _vLayers['polyline'].layer.removeGeometry(clearlines);
                    clearlines.splice(0, clearlines.length);
                }

                vTrack.lines = [];
                vTrack.points = [];
                delete _trackList[vehicleId];
            }
        } catch (e) {
        }
    }
    //清理单车轨迹到某个点
    this.clearTrackTo = function(vehicleId, dotIndex) {
        //test
        //document.getElementById('ttt').value = 'called clearTrackTo ' + '\r\n' + document.getElementById('ttt').value;

        var vTrack = _trackList[vehicleId];
        if (vTrack) {
            if (vTrack.timeOut != null) {
                //清除画轨迹的定时器
                clearTimeout(vTrack.timeOut);
                vTrack.timeOut = null;
            }
            var clearCount = vTrack.options.length - dotIndex - 1;
            if (clearCount <= 0)
                return;
            if (MapParam.isShowAllTrackPoint) {
                //删除轨迹点
                for (var i = dotIndex + 1; i < vTrack.options.length; i++) {
                    deleteMarker('poi', 'tkpt_' + vehicleId + '_' + i, true);
                }
            }

            vTrack.options.splice(dotIndex + 1, clearCount);
            //var lines = vTrack.lines;
            var lineCount = vTrack.lines.length;
            var line;
            var clearLines = [];

            for (var i = lineCount - 1; i >= 0; i--) {
                line = vTrack.lines[i];

                if (line.startIndex >= dotIndex) {
                    clearLines.push(line.polyline);

                } else {
                    if (line.startIndex + line.pointCount - 1 > dotIndex) {
                        var path = line.polyline.getCoordinates();
                        path.splice(dotIndex - line.startIndex + 1, line.startIndex + line.pointCount - dotIndex - 1);
                        line.polyline.setCoordinates(path);
                    }
                    break;
                }
            }

            if (clearLines.length > 0) {
                _vLayers['polyline'].layer.removeGeometry(clearLines);
                vTrack.lines.splice(lineCount - clearLines.length, clearLines.length);
                clearLines.splice(0, clearLines.length);
            }

            vTrack.drawnIndex = dotIndex;
            var tmpOption = vTrack.options[dotIndex];
            if (tmpOption.option.gpslng == 0.0 || tmpOption.option.gpslat == 0.0) {
                vTrack.lastPoint = null;
            } else {
                vTrack.lastPoint = {
                    gpslng: tmpOption.option.gpslng,
                    gpslat: tmpOption.option.gpslat
                };
            }
            vTrack.drawingCarStatus = tmpOption.option.carStatus;
        }
    }
    //清理所有轨迹
    this.clearAllTrack = function() {
        for (i in _trackList) {
            this.clearTrack(i);
        }
    }
    //#endregion
    /************画车end***************/
        //#region marker 绘制和移除
        //marker
    var deleteMarker = function(type, id, bFastMode) {
            if (_bTrackMode || bFastMode) {
                deleteMarkerFast(type, id);
            } else {
                _HandlingMarkers.push({
                    handle: 'del',
                    type: type,
                    id: id
                });
                //console.log('push Markers', 'del', type, id, new Date());
            }
        }

    var removeAllMarker = function(type) {
        if (_bTrackMode) {
            removeAllMarkerFast(type);
        } else {
            _HandlingMarkers.push({
                handle: 'delAll',
                type: type,
                id: null
            });
            //console.log('push Markers', 'delAll', type, null, new Date());
        }
    }

    //画点
    var drawMarker = function(markerOption, clickCallback, showCallback, bFastMode) {

        if (_bTrackMode || bFastMode) {
            drawMarkerFast(markerOption, clickCallback, showCallback);
        } else {
            _HandlingMarkers.push({
                handle: 'draw',
                type: markerOption.type,
                id: markerOption.key,
                option: markerOption,
                callback: clickCallback,
                showCallback: showCallback
            });
            //console.log('push Markers','---draw---', markerOption.type, markerOption.key, new Date());
        }
    }

    var _execHandleMarkers = function() {
        //test
        //document.getElementById('ttt').value = '_execHandleMarkers ' + new Date() + '\n' + document.getElementById('ttt').value;
        //console.log(' exe map markers count', _HandlingMarkers.length, markerArray["vehicle"].getCount());
        if (_HandlingMarkers.length > 0) {
            if (document.visibilityState == "hidden") {
                //console.log("页面隐藏状态，暂停更新地图");
                _handleMarkersTimeout = setTimeout(_execHandleMarkers, _iHandlingWaitTime);
                return;
            }
            //document.getElementById('ttt').value = _HandlingMarkers.length + '\r\n' + document.getElementById('ttt').value;
            var tmpAllHandles = _HandlingMarkers.splice(0, _HandlingMarkers.length);
            var tmpHandle;
            var type;
            var centerLngLat = null;
            var showCallback = null;
            var showMarkerOption = null;
            var iNeedHCV = 0;
            //是否需要特殊处理当前车，0 不需要处理， 1 remove 2 Add
            var delInfoWindowId = "";
            var clickCallback = null;
            var clickMarkerOption = null;
            var bInfoWindowOpen = _mapApi.getInfoWindowOpenState();

            var updateCount = 0;
            for (var i = tmpAllHandles.length - 1; i >= 0; i--) {
                tmpHandle = tmpAllHandles[i];
                type = tmpHandle.type;

                switch (tmpHandle.handle) {
                    case 'delAll':
                        if (markerArray[type].getCount() > 0) {
                            var delKeys = markerArray[type].getHashTable();

                            for (j in delKeys) {
                                if (!_removeingMarkers[type].containsKey(j) && !_updateingMarkers[type].containsKey(j) && !_drawingMarkers[type].containsKey(j)) {
                                    //若是当前车直接从地图上移除
                                    if (type == "vehicle") {
                                        if (_currVehicleId != null && j == _currVehicleId) {
                                            delKeys[j].remove();
                                            _currVehicleMarker = null;
                                            iNeedHCV = 1;
                                        }

                                        if (_infoWindowObjId == j) {
                                            //隐藏信息窗
                                            delInfoWindowId = j;
                                        }
                                    }
                                    _removeingMarkers[type].add(j, delKeys[j]);
                                    markerArray[type].remove(j);
                                }
                            }

                        }
                        break;
                    case 'del':
                        if (!_removeingMarkers[type].containsKey(tmpHandle.id) && !_updateingMarkers[type].containsKey(tmpHandle.id) && !_drawingMarkers[type].containsKey(tmpHandle.id)) {
                            var delMarker = markerArray[type].getValue(tmpHandle.id);
                            if (delMarker != null) {
                                //若是当前车直接从地图上移除
                                if (type == "vehicle") {
                                    if (_currVehicleId != null && tmpHandle.id == _currVehicleId) {
                                        delMarker.remove();
                                        _currVehicleMarker = null;
                                        iNeedHCV = 1;
                                    }

                                    if (_infoWindowObjId == tmpHandle.id) {
                                        //隐藏信息窗
                                        delInfoWindowId = tmpHandle.id;
                                    }
                                }
                                _removeingMarkers[type].add(tmpHandle.id, delMarker);
                                markerArray[type].remove(tmpHandle.id);
                            } else {
                                //没有画在地图上的也要做标记 避免清理车辆没清除
                                _removeingMarkers[type].add(tmpHandle.id, null);
                            }
                        }
                        break;
                    case 'draw':
                        var markerOption = tmpHandle.option;
                        var p = _coordConvertIn(markerOption.gpslat, markerOption.gpslng);
                        var lnglat = new maptalks.Coordinate(p.lon,p.lat);
                        if (!_removeingMarkers[type].containsKey(tmpHandle.id) && !_updateingMarkers[type].containsKey(tmpHandle.id) && !_drawingMarkers[type].containsKey(tmpHandle.id)) {

                            var markerObj = markerArray[type].getValue(tmpHandle.id);
                            if (markerObj != null) {
                                //原来已存在的点，直接进行更新; 待优化 相同的不更新
                                //markerArray[type].remove(tmpHandle.id);
                                var oldOption = _getExtData(markerObj);
                                if (!MarkerOptionCompare(oldOption, markerOption)) {
                                    var markerSymbol = TMapCommon.getSymbol(markerOption, _mapApi.userConfig, 12);
                                    //两个点gps时间的时间差(有的cgo8 markerOption 没有传)
                                    //var interval = null;
                                    //if (markerOption.gpsTime && oldOption.gpsTime) {
                                    //    interval = parseInt(new Date(markerOption.gpsTime) - new Date(oldOption.gpsTime))
                                    //}
                                    //if (MapParam.carMoveAnimation && markerOption.key == _mapApi.clickedVehicleId && (interval > 0 && interval <= 30000) && markerOption.speed != 0) { //开启车辆缓动效果且是当前车;时间差不超过30s;不是停车点;其余直接跳过
                                    //    var op = _coordConvertIn(oldOption.gpslat, oldOption.gpslng);
                                    //    var olnglat = new maptalks.Coordinate(op.lon, op.lat);

                                    //    _moveCar(olnglat, lnglat, markerObj, markerSymbol, interval)
                                    //    markerObj.config({
                                    //        extData: markerOption
                                    //    })
                                    //} else {
                                    //    markerObj.setCoordinates(lnglat);
                                    //    //修改maker配置信息
                                    //    markerObj.setSymbol(markerSymbol).config({
                                    //        extData: markerOption
                                    //    });
                                    //}

                                    if (MapParam.carMoveAnimation && markerOption.type == 'vehicle') {
                                        //若有开启车辆缓动则特殊处理缓动模式的车辆更新
                                        _updateVehicleMarkerInMoveMode(markerObj, oldOption, markerOption, markerSymbol, lnglat);
                                    } else {
                                        markerObj.setCoordinates(lnglat);
                                        //修改maker配置信息
                                        markerObj.setSymbol(markerSymbol).config({
                                            extData: markerOption
                                        });
                                    }

                                    if (markerOption.type == "vehicle" && MapParam.isShowVehicleRealTrack) //已开启小尾巴功能，画小尾巴处理
                                    {
                                        markerOption.vlineTick = oldOption.vlineTick;
                                        markerOption.vlinePoints = oldOption.vlinePoints;
                                        _vline_draw(markerOption);
                                    }

                                }
                                _updateingMarkers[type].add(tmpHandle.id, oldOption);

                                if (!showCallback && tmpHandle.showCallback) {
                                    //画车后的回调
                                    showCallback = tmpHandle.showCallback;
                                    showMarkerOption = markerOption;
                                }

                                //updateCount++;
                            } else {
                                //var newOffset = TMapCommon.getOffset(markerOption.icon.iconSize, markerOption.icon.offset);
                                //var textSize = TMapCommon.getTextSize(markerOption.labeltxt, '<br>', 12);
                                var markerSymbol = TMapCommon.getSymbol(markerOption, _mapApi.userConfig, 12);
                                markerObj = new maptalks.Marker(lnglat,{
                                    extData: markerOption,
                                    zIndex: (markerOption.type == "vehicle" ? 120 : 100),
                                    symbol: markerSymbol//    [
                                    //    {
                                    //        'markerFile': markerOption.icon.path,
                                    //        'markerWidth': markerOption.icon.iconSize.width,
                                    //        'markerHeight': markerOption.icon.iconSize.height,
                                    //        'markerDx': newOffset.x,
                                    //        'markerDy': newOffset.y
                                    //    },
                                    //    {
                                    //        // box's symbol
                                    //        'markerType': 'square', //矩形
                                    //        'markerFill': '#eeeeee',  //填充色
                                    //        'markerFillOpacity': 0.8, //透明度
                                    //        'markerLineColor': '#ddd',//边框颜色
                                    //        'markerLineWidth': 1,
                                    //        'markerWidth': textSize.width,   //根据文字获取动态宽度
                                    //        'markerHeight': textSize.height, //根据文字获取动态高度
                                    //        'markerDx': newOffset.x,
                                    //        'markerDy': newOffset.y,
                                    //        'markerVerticalAlignment': 'bottom'
                                    //    },
                                    //    {
                                    //        'textName': markerOption.labeltxt,
                                    //        'textWrapCharacter': '<br>',
                                    //        'textSize': 12,
                                    //        'textFaceName': 'microsoft yahei',
                                    //        'textFill': markerOption.textColor == '' ? '#000' : markerOption.textColor,
                                    //        'textWeight': 'bold',
                                    //        'textHaloFill': '#fff',
                                    //        'textHaloRadius': 1,
                                    //        'textDy': newOffset.y + 2,
                                    //        'textVerticalAlignment': 'bottom'
                                    //    }
                                    //]
                                    //,visible: MapLayerSwitcher[markerOption.type]
                                });

                                if (tmpHandle.callback) {
                                    markerObj.on('click', tmpHandle.callback);
                                }

                                markerArray[type].add(tmpHandle.id, markerObj);
                                _drawingMarkers[type].add(tmpHandle.id, markerObj);
                                //若是当前车则直接在地图上添加
                                if (type == "vehicle" && _currVehicleId != null && _currVehicleId == tmpHandle.id) {
                                    _setTrackingMarker(tmpHandle.id, markerObj);
                                    iNeedHCV = 2;
                                }
                            }

                            //当前车视野处理，不在视野范围内时拉回视野进行居中显示
                            if (centerLngLat == null && (markerOption.isbound || (_infoWindowObjId == markerOption.key && bInfoWindowOpen))) {
                                var extent = mapObj.getExtent();
                                if (!extent.contains(lnglat)) {
                                    centerLngLat = lnglat;
                                }
                            }

                            if (!showCallback && tmpHandle.showCallback) {
                                //画车后的回调
                                showCallback = tmpHandle.showCallback;
                                showMarkerOption = markerOption;
                            }

                            if (clickMarkerOption == null && _infoWindowObjId == markerOption.key && bInfoWindowOpen) {
                                clickCallback = tmpHandle.callback;
                                if (clickCallback) {
                                    clickMarkerOption = markerOption;
                                }
                            }
                        }

                        break;
                }
            }

            tmpAllHandles = [];
            //更新地图上的所有marker
            for (i in _markerType) {
                type = _markerType[i];
                if (_updateingMarkers[type].getCount() > 0) {
                    _updateingMarkers[type].clear();
                }
                //当前车特殊处理
                if (iNeedHCV == 1 && type == 'vehicle') {
                    _removeingMarkers[type].remove(_currVehicleId);
                } else if (iNeedHCV == 2 && type == 'vehicle') {
                    _drawingMarkers[type].remove(_currVehicleId);
                }

                if (_clusterList[type] != undefined) {
                    //开启了点聚合
                    if (_removeingMarkers[type].getCount() > 0) {
                        //删除标记 有删除操作时将聚合点的集合设置成当前type所有点集合
                        var tmpMarkers = _removeingMarkers[type].getHashTable();
                        var removeingMarkerArray = [];
                        var marker;
                        for (i in tmpMarkers) {
                            marker = tmpMarkers[i];
                            if (marker != null) {
                                removeingMarkerArray.push(marker);
                                if (type == "vehicle" && MapParam.isShowVehicleRealTrack) {
                                    //移除小尾巴
                                    _vline_del(_getExtData(marker));
                                }
                            }

                        }
                        if (removeingMarkerArray.length > 0) {
                            _clusterList[type].removeGeometry(removeingMarkerArray);
                            //console.log(' remove markers count', type, _removeingMarkers[type].getCount(), markerArray[type].getCount());
                            removeingMarkerArray.splice(0, removeingMarkerArray.length);
                        }
                        removeingMarkerArray = null;
                        _removeingMarkers[type].clear();
                    }

                    if (_drawingMarkers[type].getCount() > 0) {
                        if (type == "vehicle" && MapParam.isShowVehicleRealTrack) {
                            //画小尾巴
                            var tmpMarkers = _drawingMarkers[type].getHashTable();
                            for (i in tmpMarkers) {
                                _vline_draw(_getExtData(tmpMarkers[i]));
                            }
                        }

                        _clusterList[type].addGeometry(_drawingMarkers[type].getValues());
                        //console.log(' draw markers count', type, _drawingMarkers[type].getCount(), markerArray[type].getCount());

                        _drawingMarkers[type].clear();
                    }

                } else {
                    //未开启聚合点
                    if (_removeingMarkers[type].getCount() > 0) {
                        //删除标记
                        var tmpMarkers = _removeingMarkers[type].getHashTable();
                        var removeingMarkerArray = [];
                        var marker;
                        for (i in tmpMarkers) {
                            marker = tmpMarkers[i];
                            if (marker != null) {
                                removeingMarkerArray.push(marker);
                                if (type == "vehicle" && MapParam.isShowVehicleRealTrack) {
                                    //移除小尾巴
                                    _vline_del(_getExtData(marker));
                                }
                            }
                        }
                        if (removeingMarkerArray.length > 0) {
                            _vLayers[type].layer.removeGeometry(removeingMarkerArray);
                            //console.log(' remove markers count', type, _removeingMarkers[type].getCount(), markerArray[type].getCount());
                            removeingMarkerArray.splice(0, removeingMarkerArray.length);
                        }
                        _removeingMarkers[type].clear();

                    }

                    if (_drawingMarkers[type].getCount() > 0) {
                        if (type == "vehicle" && MapParam.isShowVehicleRealTrack) {
                            //画小尾巴
                            var tmpMarkers = _drawingMarkers[type].getHashTable();
                            for (i in tmpMarkers) {
                                _vline_draw(_getExtData(tmpMarkers[i]));
                            }
                        }

                        _vLayers[type].layer.addGeometry(_drawingMarkers[type].getValues());
                        _drawingMarkers[type].clear();
                    }

                }
            }

            if (centerLngLat) {
                mapObj.setCenter(centerLngLat);
            }

            if (showCallback) {
                //画车后的回调
                showCallback(showMarkerOption);
            } else if (clickCallback != null) {
                clickCallback(clickMarkerOption);
            } else if (delInfoWindowId != "") {
                _mapApi.closeInfoWindow();
            }
        }

        _handleMarkersTimeout = setTimeout(_execHandleMarkers, _iHandlingWaitTime);
    }

    //#region 车辆缓动相关处理
    var _movingVehicleMarker;
    var _movingVehicleMarkerOption;
    var _movingMarkerSymbol;
    var _movingPlayer;
    var _movingVehicleStatus = 0;
    //0 未动/已完成， 1在移动未完成
    var _movingLonlat;
    var _movingFinishIconPath;
    /**
     * 开启缓动模式时的更新车辆marker
     * @param {any} markerObj 当前的marker对象
     * @param {any} oldOption 前个点的markeroption
     * @param {any} currOption 当前点的markeroption
     * @param {any} markerSymbol 当前点的symbol
     * @param {any} lnglat 当前点的经纬度对象
     */
    var _updateVehicleMarkerInMoveMode = function(markerObj, oldOption, currOption, markerSymbol, lnglat) {
        //console.log('_updateVehicleMarkerInMoveMode', currOption.key, _mapApi.clickedVehicleId, currOption.speed);
        //车辆已被切换则需要结束之前的动画；
        //或者之前动画的车辆与现在即将要更新的车辆是同一辆则需要结束动画 再判断新的是否要增加动画
        _checkAndEndMovingVehicle(currOption.key);

        var bNeedMoving = currOption.key == _mapApi.clickedVehicleId && currOption.speed > 0;
        var interval = 0;
        var distance = 0;
        var oldLnglat;
        //上个点的经纬度
        //只有当前车且速度>0才判断时间和距离，减少画其他车时的计算量
        if (bNeedMoving) {
            if (currOption.gpsTime && oldOption.gpsTime) {
                //上个点与当前要花的点的Gps时间间隔
                interval = parseInt(new Date(currOption.gpsTime) - new Date(oldOption.gpsTime));
            }

            if (interval <= 1 && interval > 30000)
                //时间1-30秒
                bNeedMoving = false;
            if (bNeedMoving) {
                var oldPoint = _coordConvertIn(oldOption.gpslat, oldOption.gpslng);
                oldLnglat = new maptalks.Coordinate(oldPoint.lon,oldPoint.lat);
                distance = mapObj.getProjection().measureLenBetween(oldLnglat, lnglat);

                if (distance <= 10 || distance > interval * 100 / 3.6)
                    //距离10-1000米，以100码的速度*跑的间隔不超过1公里
                    bNeedMoving = false;
            }

        }

        //判断当前车是否要增加动画: 当前车，两点间的时间间隔不超过30秒，速度> 0
        if (bNeedMoving) {
            //暂不支持地图弹窗一起缓动
            setTimeout(function() {
                if (_infoWindowObjId == _mapApi.clickedVehicleId) {
                    _mapApi.closeInfoWindow();
                }
            });

            _movingVehicleMarker = markerObj;
            _movingVehicleMarkerOption = currOption;
            _movingMarkerSymbol = markerSymbol;
            _movingFinishIconPath = markerSymbol[0].markerFile;
            _movingLonlat = lnglat;

            //获取两个点之间偏移量  距离
            let x = lnglat.x - oldLnglat.x;
            let y = lnglat.y - oldLnglat.y;
            let offset = {
                x: x,
                y: y
            };

            let iconPath = _movingFinishIconPath;

            //计算旋转方向 旋转方向
            let angle = getAngle(oldLnglat, lnglat);
            if (iconPath.indexOf("default") > 0) {
                if (iconPath.indexOf("speed0") > 0 || iconPath.indexOf("offline") > 0) {
                    var newPath = iconPath;
                } else {
                    let index = iconPath.lastIndexOf(".");
                    var newPath = iconPath.slice(0, index - 2) + angle + ".png";
                }
            } else {
                let index = iconPath.lastIndexOf("/");
                var newPath = iconPath.slice(0, index + 1) + angle + ".png";
            }
            markerSymbol[0].markerFile = newPath;
            markerObj.setSymbol(markerSymbol).config({
                extData: currOption
            });
            _movingVehicleStatus = 1;
            //let offset = lnglat.getMax().sub(oldLnglat).multi(1 / 2)
            _movingPlayer = markerObj.bringToFront().animate({
                //animation translate distance
                translate: [offset['x'], offset['y']]//按给定的偏移量平移或移动几何图形。
            }, {
                duration: interval,
                //let map focus on the marker
                focus: false
            }, function(frame) {
                if (frame.state.playState === 'finished') {
                    //console.log('moving finished');
                    _movingVehicleMarker.setCoordinates(_movingLonlat);
                    //修改maker配置信息
                    _movingMarkerSymbol[0].markerFile = _movingFinishIconPath;
                    _movingVehicleMarker.setSymbol(_movingMarkerSymbol).config({
                        extData: _movingVehicleMarkerOption
                    });
                    if (_movingVehicleMarkerOption.key == _mapApi.clickedVehicleId) {
                        var bounds = mapObj.getExtent();
                        if (!bounds.contains(_movingLonlat)) {
                            mapObj.setCenter(_movingLonlat);
                        }
                    }
                    _movingVehicleStatus = 0;
                } else {
                    if (_movingVehicleMarkerOption.key == _mapApi.clickedVehicleId) {
                        let currlnglat = _movingVehicleMarker.getCoordinates();
                        var bounds = mapObj.getExtent();
                        if (!bounds.contains(currlnglat)) {
                            mapObj.setCenter(currlnglat);
                        }
                    }
                    //移动infoWindow
                    //let lnglat = movingMarkerObj.getCoordinates();
                    //_infoWindow.show(lnglat)
                    //let content = _infoWindow.getContent();
                    //content = content.replace("正在解析地理位置.....", addressResult)
                    //_infoWindow.setContentAndCoord(content, lnglat)
                    //if (_infoWindow.isVisible())
                    //    _infoWindow.show(_movingVehicleMarker.getCoordinates());
                }
            });
        } else {
            markerObj.setCoordinates(lnglat);
            //修改maker配置信息
            markerObj.setSymbol(markerSymbol).config({
                extData: currOption
            });
        }
    }
    /**
     * 根据车辆ID检查目前地图上车辆的缓动动画是否需要进行停止，若需要则进行停止动画
     * @param {any} vehicleId
     */
    var _checkAndEndMovingVehicle = function(vehicleId) {
        //车辆已被切换则需要结束之前的动画；
        //或者之前动画的车辆与现在即将要更新的车辆是同一辆则需要结束动画 再判断新的是否要增加动画
        if (_movingVehicleStatus == 1 && _movingVehicleMarkerOption != null && (_movingVehicleMarkerOption.key != _mapApi.clickedVehicleId || _movingVehicleMarkerOption.key == vehicleId)) {
            //结束之前车辆的缓动
            if (_movingPlayer) {
                //console.log('begin finish');
                _movingPlayer.finish();
                //已确认finish会触发动画的finish事件
                //console.log('end finish');
            }
            _movingVehicleStatus = 0;
        }
    }
    //#endregion

    var deleteMarkerFast = function(type, id) {
        var marker = markerArray[type].getValue(id);
        if (marker != null) {
            if (type == "vehicle" && MapParam.isShowVehicleRealTrack) //已开启小尾巴功能，移除小尾巴处理
            {
                _vline_del(_getExtData(marker));
            }

            markerArray[type].remove(id);
            marker.remove();
        }
    }

    var removeAllMarkerFast = function(type) {
        var mMarkers = markerArray[type].getValues();
        if (mMarkers.length == 0)
            return;

        if (type == "vehicle" && MapParam.isShowVehicleRealTrack) //已开启小尾巴功能，移除小尾巴处理
        {
            var vlineList = _vlineList.getHashTable();
            for (var i in vlineList) {
                vlineList[i].remove();
            }
            _vlineList.clear();
            vlineList = null;
        }

        markerArray[type].clear();
        //if (_clusterList[type]) //车辆点聚集
        //{
        //    _clusterList[type].setMarkers(markerArray[type]);
        //}
        //else {
        if (_clusterList[type])
            //若有聚合点
            _clusterList[type].removeGeometry(mMarkers);
        _vLayers[type].layer.removeGeometry(mMarkers);
        mMarkers = [];
    }

    //立即修改marker 文字和边框、当前车缩放级别----pengh 20210622
    this.updateMarkerOption = function(userConfig) {
        _mapApi.userConfig = userConfig;
        let vehicles = markerArray['vehicle'].getValues();
        if (vehicles.length != 0) {
            vehicles.forEach((marker)=>{
                    marker.updateSymbol({
                        'textFill': userConfig.vehicle.textColor,
                        'markerLineWidth': userConfig.vehicle.isShowBorder ? 1 : 0,
                        'markerFillOpacity': userConfig.vehicle.isShowBorder ? 1 : 0,
                        //透明度
                    });
                }
            )
        }

        let flags = markerArray['flag'].getValues();
        if (flags.length != 0) {
            flags.forEach((marker)=>{
                    marker.updateSymbol({
                        'textFill': userConfig.flag.textColor,
                        'markerLineWidth': userConfig.flag.isShowBorder ? 1 : 0
                    });
                }
            )
        }
        let pois = markerArray['poi'].getValues();
        if (pois.length != 0) {
            pois.forEach((marker)=>{
                    marker.updateSymbol({
                        'textFill': userConfig.poi.textColor,
                        'markerLineWidth': userConfig.poi.isShowBorder ? 1 : 0
                    });
                }
            )
        }
    }

    let movingMarkerObj = null;
    //移动的点对象
    let movingEventListener = null;
    let movingFlag = false
    let movingAnimateObj = null;

    function _moveCar(oldlnglat, lnglat, markerObj, markerSymbol, interval) {
        if (movingFlag)
            return;
        movingFlag = true

        setTimeout(function() {
            _infoWindow.hide();
        }, 50)
        //移动过程中隐藏infowindow

        if (!interval) {
            //画车的时候没有传gpsTime  interval为undefined
            interval = _iHandlingWaitTime
        }
        movingMarkerObj = markerObj
        //获取两个点之间偏移量  距离
        let x = lnglat.x - oldlnglat.x;
        let y = lnglat.y - oldlnglat.y;
        let offset = {
            x: x,
            y: y
        }

        let iconPath = markerSymbol[0].markerFile

        //计算旋转方向 旋转方向
        let angle = getAngle(oldlnglat, lnglat)
        if (iconPath.indexOf("default") > 0) {
            if (iconPath.indexOf("speed0") > 0 || iconPath.indexOf("offline") > 0) {
                var newPath = iconPath;
            } else {
                let index = iconPath.lastIndexOf(".")
                var newPath = iconPath.slice(0, index - 2) + angle + ".png";
            }
        } else {
            let index = iconPath.lastIndexOf("/")
            var newPath = iconPath.slice(0, index + 1) + angle + ".png";
        }
        markerSymbol[0].markerFile = newPath
        movingMarkerObj.setSymbol(markerSymbol)
        //let offset = lnglat.getMax().sub(oldLnglat).multi(1 / 2)
        movingAnimateObj = movingMarkerObj.bringToFront().animate({
            //animation translate distance
            translate: [offset['x'], offset['y']]//按给定的偏移量平移或移动几何图形。
        }, {
            duration: interval,
            //let map focus on the marker
            focus: false
        }, function(frame) {

            if (frame.state.playState === 'finished') {
                movingFlag = false;
            }
            ////移动infoWindow
            //let lnglat = movingMarkerObj.getCoordinates();
            ////_infoWindow.show(lnglat)
            //let content = _infoWindow.getContent();
            //content = content.replace("正在解析地理位置.....", addressResult)
            // _infoWindow.setContentAndCoord(content, lnglat)
            // mapObj.setCenter(lnglat);

        });

        if (!movingEventListener) {
            movingEventListener = movingMarkerObj.addEventListener("animating", function() {//_infoWindow.hide();
                //移动infoWindow
                // _showInfoWindow("", lnglat)
                //_infoWindow.show(lnglat);
            })
        }

    }

    function getAngle(olnglat, lnglat) {
        let rad = Math.PI / 180
            , lat1 = olnglat.y * rad
            , lat2 = lnglat.y * rad
            , lng1 = olnglat.x * rad
            , lng2 = lnglat.x * rad;
        const a = Math.sin(lng2 - lng1) * Math.cos(lat2);
        const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lng2 - lng1);
        return radiansToDegrees(Math.atan2(a, b))

    }

    function radiansToDegrees(radians) {
        const degrees = radians % (2 * Math.PI);
        let direction = Math.ceil(degrees * 180 / Math.PI)
        //角度 取整
        if (direction < 0) {
            direction = 360 + direction
        }
        var d = Math.round(direction / 22.5);
        if (d >= 16 || d < 0)
            d = 0;
        let iconname = "";
        if (d < 10)
            iconname = "0" + d.toString();
        else
            iconname = d.toString();

        return iconname
    }

    //画点-不缓存
    var drawMarkerFast = function(markerOption, clickCallback, showCallback) {
        //if (movingAnimateObj) {
        //    movingAnimateObj.pause(); //停止车辆缓动动画
        //    movingFlag = false;
        //}
        //检查并判断是否停止缓动
        if (markerOption.type == 'vehicle') {
            _checkAndEndMovingVehicle(markerOption.key);
        }

        var p = _coordConvertIn(markerOption.gpslat, markerOption.gpslng);
        var lnglat = new maptalks.Coordinate(p.lon,p.lat);
        if (markerArray[markerOption.type].containsKey(markerOption.key)) {
            //更新点
            var markerObj = markerArray[markerOption.type].getValue(markerOption.key);
            if (markerObj) {

                var oldOption = _getExtData(markerObj);

                if (!MarkerOptionCompare(oldOption, markerOption)) {

                    var markerSymbol = TMapCommon.getSymbol(markerOption, _mapApi.userConfig, 12);
                    markerObj.setCoordinates(lnglat);
                    //修改maker配置信息
                    markerObj.setSymbol(markerSymbol).config({
                        extData: markerOption
                    });

                    if (markerOption.type == "vehicle" && MapParam.isShowVehicleRealTrack) //已开启小尾巴功能，画小尾巴处理
                    {
                        markerOption.vlineTick = oldOption.vlineTick;
                        markerOption.vlinePoints = oldOption.vlinePoints;
                        _vline_draw(markerOption);
                    }
                }
            }
        } else {
            //添加点
            //var newOffset = TMapCommon.getOffset(markerOption.icon.iconSize, markerOption.icon.offset);
            var markerSymbol = TMapCommon.getSymbol(markerOption, _mapApi.userConfig, 12);
            var marker = new maptalks.Marker(lnglat,{
                //draggable: true,
                extData: markerOption,
                zIndex: (markerOption.type == "vehicle" ? 120 : 100),
                symbol: markerSymbol
            });

            if (clickCallback) {
                marker.on('click', clickCallback);
            }

            markerArray[markerOption.type].add(markerOption.key, marker);
            //保存状态
            if (_clusterList[markerOption.type] == undefined) {
                marker.addTo(_vLayers[markerOption.type].layer);
            } else {
                _clusterList[markerOption.type].addMarker([marker]);
            }
            //test
            //if(markerOption.key == '-990')
            //document.getElementById('ttt').value = markerOption.labeltxt + markerOption.key + markerOption.icon.path + '\r\n' + document.getElementById('ttt').value;

        }

        if (markerOption.type == "vehicle" && MapParam.isShowVehicleRealTrack) //已开启小尾巴功能，画小尾巴处理
        {
            _vline_draw(markerOption);
        }

        if (markerOption.isbound) {
            var extent = mapObj.getExtent();
            if (!extent.contains(lnglat)) {
                mapObj.setCenter(lnglat);
            }
        }

        if (showCallback) {
            showCallback(markerOption);
        } else {
            if (_infoWindowObjId == markerOption.key && _mapApi.getInfoWindowOpenState()) {
                if (clickCallback) {
                    clickCallback(markerOption);
                } else {
                    _mapApi.closeInfoWindow();
                }
            }
        }
    }
    //#endregion

    /**小尾巴处理 begin */
        //#region 小尾巴处理
    var _vlineList = new HashTable();
    //key 路线id value:路线对象
    //画小尾巴
    function _vline_draw(markerOption) {
        if (markerOption.ticks == 0 || markerOption.speed == 0) {
            //传入时间为null 或 格式错误
            if (markerOption.vlinePoints != null && markerOption.vlinePoints.length > 0) {
                //需要清理
                _vline_del(markerOption);
            }
            return;
        }

        if (markerOption.vlinePoints == null) {
            markerOption.vlinePoints = [];
        }

        if (markerOption.vlineTick == null) {
            markerOption.vlineTick = 0;
        }

        var len = markerOption.vlinePoints.length;
        if (len > 0) {
            var lastPoint = markerOption.vlinePoints[len - 1];
            if (markerOption.vlineTick > markerOption.ticks) {
                //时间倒退, 清理
                _vline_del(markerOption);
                return;
            }

            if (markerOption.vlineTick == markerOption.ticks) {
                //GPS时间相同，经纬度没变-跳过，经纬度变化-清空
                if (lastPoint[0] == markerOption.gpslng && lastPoint[1] == markerOption.gpslat) {
                    return;
                }
                _vline_del(markerOption);
                return;
            }
        }
        //记录最新的经纬度 和 GPS时间
        //var p = _coordConvertIn(markerOption.gpslat, markerOption.gpslng);
        markerOption.vlinePoints.push([markerOption.gpslng, markerOption.gpslat]);
        markerOption.vlineTick = markerOption.ticks;

        if (len + 1 > MapParam.vehicleRealTrackCount) {
            markerOption.vlinePoints.shift();
        }

        if (markerOption.vlinePoints.length >= 2) {
            //可画线
            var lineId = 'vline_' + markerOption.key;
            var vline = _vlineList.getValue(lineId);

            var linePoints = [];
            var p;
            //转换坐标
            for (var i in markerOption.vlinePoints) {
                p = _coordConvertIn(markerOption.vlinePoints[i][1], markerOption.vlinePoints[i][0]);
                linePoints.push([p.lon, p.lat]);
            }

            if (vline == null) {
                //新画线
                vline = new maptalks.LineString(linePoints,{
                    symbol: {
                        lineColor: '#0000ff',
                        //线颜色
                        lineWidth: 2,
                        //线宽
                        lineJoin: 'round',
                        lineCap: 'round'
                    },
                    extData: {
                        lineId: lineId
                    }
                });
                _vlineList.add(lineId, vline);
                var currZoom = mapObj.getZoom();
                if (currZoom > MapParam.vehicleCluserMaxZoom) {
                    vline.addTo(_vLayers['polyline'].layer);
                }
                vline = null;

            } else {
                //更新线段
                vline.setCoordinates(linePoints);
                vline = null;
            }

            linePoints = null;
        }

    }
    //移除小尾巴
    function _vline_del(markerOption) {
        if (markerOption.vlinePoints == null || markerOption.vlinePoints.length == 0) {
            return;
        }
        markerOption.vlinePoints.splice(0, markerOption.vlinePoints.length);
        //移除所有点

        var lineId = 'vline_' + markerOption.key;
        var vline = _vlineList.getValue(lineId);
        if (vline != null) {
            _vlineList.remove(lineId);
            vline.remove();
            vline = null;
        }
    }
    //#endregion
    /**小尾巴处理 end */

        //#region 弹出信息窗处理
    var _showInfoPositionTimeout = null;
    var addressResult = null;
    var _showInfoWindow = function(popText, lnglat, bShowLocation, markerId, addressText) {
        let addAddressText = false;

        if (bShowLocation == undefined)
            bShowLocation = true;
        //默认显示地理位置
        if (markerId == undefined)
            markerId = "";
        //if (_infoWindow.getIsOpen())
        //_infoWindow.close();
        if (bShowLocation) {
            var id = '_aMapinfoLocation' + Math.random();
            var popTextBefore = popText
                , popTextAfter = ''
                , //显示在地理位置解析之后的文本
                index = popText.indexOf("<div class='popupAfter'>");
            if (index > 0) {
                popTextBefore = popText.substr(0, index);
                popTextAfter = popText.substr(index);
                var i = popTextAfter.indexOf(">")
                popTextAfter = popTextAfter.substr(0, i + 1) + ' <span id="' + id + '" style="color:#1C86EE">正在解析地理位置.....</span> ' + popTextAfter.substr(i + 1);
                addAddressText = true;
                //--pengh 修改   往<div class='popupAfter'> 后插入  <span id="' + id + '" style="color:#1C86EE">正在解析地理位置.....</span></br>
            }

            if (!addAddressText) {
                //如果在popupAfter 中插入了  这边就不插入了
                var content = '<div>' + popTextBefore + '<span id="' + id + '" style="color:#1C86EE">正在解析地理位置.....</span>' + (popTextAfter != '' ? popTextAfter : '') + '</div>';
            } else {
                var content = '<div>' + popTextBefore + (popTextAfter != '' ? popTextAfter : '') + '</div>';
            }

            //<span id="' + id + '" style="color:#1C86EE">正在解析地理位置.....</span>
            //console.debug('info window', lnglat, content);

            _infoWindow.setContentAndCoord(content, lnglat);

            //if (!_infoWindow.isVisible()) {
            //    _infoWindow.show(lnglat);
            //}
            //else {
            //    _infoWindow.show(lnglat); //只改变位置，暂时也是show
            //}

            if (_showInfoPositionTimeout != null) {
                clearTimeout(_showInfoPositionTimeout);
            }

            //cgo8 有直接传位置就直接用cgo8的位置信息  不调用后台解析
            if (addressText != '' && addressText != undefined) {
                var o = document.getElementById(id);
                o.innerHTML = addressText
            } else {
                //获取地理位置
                var _showInfoPositionTimeout = setTimeout(function() {
                    var p = _coordConvert(lnglat.y, lnglat.x, _currentPrjCode, _gcjPrjCode);
                    _getAddressFromServer(p.lon, p.lat, function(result) {
                        var o = document.getElementById(id);
                        if (o != null) {
                            o.innerHTML = result;
                            addressResult = result;
                        }
                    });
                }, 20);
            }

        } else {
            _infoWindow.setContentAndCoord('<div>' + popText + '</div>', lnglat);
            //if (!_infoWindow.isVisible()) {
            //    _infoWindow.show(lnglat);
            //}
            //else {
            //    _infoWindow.show(lnglat); //只改变位置，暂时也是show
            //}
        }
        _infoWindowObjId = markerId;

        if (typeof MapPopEvent != "undefined") {
            MapPopEvent.setMapPop();
        }

    }
    //popText: 弹出框内容html
    //x: GPS经度
    //y: GPS纬度
    //bShowLocation: 是否显示地理位置
    //addressText: 地理位置信息
    this.showInfoWindow = function(popText, x, y, bShowLocation, veihcleId, addressText) {
        var position = _coordConvertIn(y, x);
        _showInfoWindow(popText, new maptalks.Coordinate(position.lon,position.lat), bShowLocation, veihcleId, addressText);
    }
    ;

    this.getInfoWindowOpenState = function() {
        if (_infoWindow == null) {
            return false;
        }
        return _infoWindow.isVisible();
    }

    this.closeInfoWindow = function() {
        if (_infoWindow != null) {
            _infoWindow.hide();
        }
    }
    ;
    //#endregion

    /***************地理位置解析 begin*****************/
    //#region 地理位置解析
    this.getAddress = function(lon, lat, callback) {
        //var position = GpsConvert.WGS84_to_GCJ02(lat, lon);
        var position = _coordConvert(lat, lon, _outPrjCode, _gcjPrjCode);
        _getAddressFromServer(position.lon, position.lat, callback);
    }

    var _addressRequests = [];
    var _addressResults = [];
    var _bOnAddressRequest = [];
    //是否正在请求地理位置，同一时间控制只有一个在请求
    this.getMultiAddress = function(queryType, queryId, lon, lat) {
        var position = _coordConvert(lat, lon, _outPrjCode, _gcjPrjCode);
        if (!_addressRequests[queryType]) {
            _addressRequests[queryType] = [];
            _addressResults[queryType] = [];
            _bOnAddressRequest[queryType] = false;
        }
        _addressRequests[queryType].push({
            qtype: queryType,
            qId: queryId,
            lon: position.lon,
            lat: position.lat
        });
        if (!_bOnAddressRequest[queryType]) {
            _bOnAddressRequest[queryType] = true;
            _executeMultiAddressRequest(queryType);
        }
    }

    this.getMultiAddressResult = function(queryType) {
        var resultArray = _addressResults[queryType];
        if (resultArray && resultArray.length > 0) {
            var result = resultArray.splice(0, resultArray.length);
            return result;
        } else
            return null;
    }

    this.clearMultiAddress = function(queryType) {
        if (_addressRequests[queryType]) {
            _addressRequests[queryType].splice(0, _addressRequests[queryType].length);
            delete _addressRequests[queryType];
        }

        if (_addressResults[queryType]) {
            _addressResults[queryType].splice(0, _addressResults[queryType].length);
            delete _addressResults[queryType];
        }
        if (_bOnAddressRequest[queryType])
            delete _bOnAddressRequest[queryType];
    }

    var _executeMultiAddressRequest = function(queryType) {
        if (_addressRequests[queryType] && _addressRequests[queryType].length > 0) {
            var request = _addressRequests[queryType].shift();
            //解析
            _getAddressFromServer(request.lon, request.lat, function(address, addressComponent, roadName) {
                if (_addressResults[request.qtype]) {
                    _addressResults[request.qtype].push({
                        qId: request.qId,
                        address: address,
                        addressComponent: addressComponent,
                        roadName: roadName
                    });
                    _executeMultiAddressRequest(request.qtype);
                }
            });
        } else {
            if (_bOnAddressRequest[queryType])
                _bOnAddressRequest[queryType] = false;
        }
    }

    let cacheLocData = null;
    let cacheLonlat = ""

    /**
     * 地理位置解析执行队列
     * pengh
     * */
    class TaskQueue {
        constructor() {
            this.max = 2;
            //最大并发数
            this.taskList = []
            //用shift方法实现先进先出
            setTimeout(()=>{
                    //这里初始化队列后自动执行，后续有新任务添加则需要手动执行。
                    this.run()
                }
            )

        }

        addTask(task) {
            this.taskList.push(task);
        }

        run() {
            const length = this.taskList.length;
            if (!length) {
                return;
            }
            const min = Math.min(length, this.max);
            // 控制并发数量
            for (let i = 0; i < min; i++) {

                const task = this.taskList.shift();
                let {glon, glat, loctype, mtype, callback} = task;
                try {
                    this.max--;
                    //开始占用一个任务的空间
                    if (glon == '0' || glat == '0') {
                        callback("无数据")
                        this.max++;
                        //任务完成，释放空间
                        this.run();
                        //自动进行下一个任务
                        return;
                    }

                    if (`${glon},${glat}` == cacheLonlat) {
                        callback(cacheLocData.address, cacheLocData.addressComponent ? cacheLocData.addressComponent : [], cacheLocData.roadName ? cacheLocData.roadName : '')
                        this.max++;
                        //任务完成，释放空间
                        this.run();
                        //自动进行下一个任务
                        return;
                    }

                    ServerLocationQueryPromise(glon, glat, loctype, mtype).then(data=>{

                            //回调
                            callback(data.address, data.addressComponent ? data.addressComponent : [], data.roadName ? data.roadName : '');
                            //添加缓存
                            cacheLonlat = `${glon},${glat}`
                            cacheLocData = data;
                        }
                    ).catch(err=>{
                            callback("无数据")
                            //清除缓存
                            cacheLonlat = '';
                            cacheLocData = null;
                        }
                    ).finally(()=>{
                            this.max++;
                            //任务完成，释放空间
                            this.run();
                            //自动进行下一个任务
                        }
                    )
                } catch (e) {
                    console.log(e)
                }

            }
        }
    }

    let taskQueue = new TaskQueue();

    function _getAddressFromServer(glon, glat, callback) {
        //callback包含参数 address
        if (g_EnableJGMapGeo && glon > 98.16 && glon < 98.36 && glat > 39.77 && glat < 39.92) {
            //ServerLoctionQuery(glon, glat, "GCJ02", 'JGMap', callback)
            let loctype = 'GCJ02';
            let mtype = 'JGMap';

            taskQueue.addTask({
                glon,
                glat,
                loctype,
                mtype,
                callback
            })
            taskQueue.run();
        } else {
            //ServerLoctionQuery(glon, glat, "GCJ02", MapParam.addressApi, callback)
            let loctype = 'GCJ02';
            let mtype = MapParam.addressApi;
            //调用后台接口解析
            taskQueue.addTask({
                glon,
                glat,
                loctype,
                mtype,
                callback
            })

            taskQueue.run();
        }
    }

    //#endregion
    /***************地理位置解析 end*******************/

    /**************地物查询begin*****************/
    //#region 地物查询
    this.searchPlaceByKeyword = function(keyword, callback) {
        if (!keyword || typeof callback != 'function') {
            return;
        }
        if (MapParam.addressApi == 'AMapWeb' || MapParam.addressApi == 'AMapWeb2') {
            //高德 正版
            //if (!placeSearch) { //按需加载
            //    placeSearch = new AMap.PlaceSearch({ pageSize: 50 });
            //}
            //var extent = mapObj.getExtent();
            //var bounds = new AMap.Bounds([extent.xmin, extent.ymin], [extent.xmax, extent.ymax]);
            //placeSearch.searchInBounds(keyword, bounds, function (status, result) {
            //    var data = _getFlagListByKeyword(keyword);
            //    if (status === 'complete' && result.info === 'OK') {
            //        if (result.poiList.count > 0) {
            //            var pois = result.poiList.pois;
            //            var tmpLocation;
            //            for (i in pois) {
            //                tmpLocation = _coordConvert(pois[i].location.getLat(), pois[i].location.getLng(), _gcjPrjCode, _outPrjCode);
            //                data.push({ lon: tmpLocation.lon, lat: tmpLocation.lat, info: (pois[i].name + ' - ' + pois[i].address).replace(/,/g, ' - ') })
            //            }
            //        }
            //    }
            //    if (callback) {
            //        callback(data);
            //    }
            //})

            //1000
            //获取地图中心点城市
            var center = mapObj.getCenter();
            //调用地理位置解析-- 先获取城市
            http("../geo/regeoc", {
                lng: center.x,
                lat: center.y
            }).then(res=>{
                    if (res.status == 1) {
                        //success
                        let city = res.addressComponent[1];
                        ServerPlaceSearchByKeywords(city, keyword, callback);
                    } else {
                        callback([])
                    }
                }
            )

        } else if (MapParam.addressApi == 'BaiduMapJs' || MapParam.addressApi == 'BaiduMapWeb') {
            //百度 正版
            if (BMap) {
                var extent = mapObj.getExtent();
                var bounds = new BMap.Bounds(new BMap.Point(extent.xmin,extent.ymin),new BMap.Point(extent.xmax,extent.ymax))
                var center = bounds.getCenter();
                //map对象  point 对象   "字符串"
                placeSearch = new BMap.LocalSearch(center,{
                    onSearchComplete: function(results) {
                        var data = [];
                        if (placeSearch.getStatus() == 0) {
                            // 判断状态是否正确
                            for (var i = 0; i < results.getCurrentNumPois(); i++) {
                                let poi = results.getPoi(i);
                                let tmpGD = GpsConvert.BD09_to_GCJ02(poi.point.lat, poi.point.lng);
                                tmpLocation = _coordConvert(tmpGD.lat, tmpGD.lon, _gcjPrjCode, _outPrjCode);
                                data.push({
                                    lon: tmpLocation.lon,
                                    lat: tmpLocation.lat,
                                    info: (poi.title + ' - ' + poi.address).replace(/,/g, ' - ')
                                });

                                //测试坐标是否正确
                                //var p = _coordConvertIn(tmpLocation.lat, tmpLocation.lon);
                                //_mapApi.showPoi("trackPointPOI" + i, "", '', p.lon, p.lat, '', '', 'red', '2', false, false);
                            }
                            if (callback) {
                                callback(data);
                            }
                        }
                    }
                })
                placeSearch.search(keyword);
            } else {
                //获取地图中心点城市
                var center = mapObj.getCenter();
                //调用地理位置解析-- 先获取城市
                http("../geo/regeoc", {
                    lng: center.x,
                    lat: center.y
                }).then(res=>{
                        if (res.status == 1) {
                            //success
                            let city = res.addressComponent[1];
                            ServerPlaceSearchByKeywords(city, keyword, callback);
                        } else {
                            callback([])
                        }
                    }
                )
            }

        } else {
            //js api 无法使用
            //获取地图中心点城市
            var center = mapObj.getCenter();

            //调用地理位置解析-- 先获取城市
            http("../geo/regeoc", {
                lng: center.x,
                lat: center.y
            }).then(res=>{
                    if (res.status == 1) {
                        //success
                        let city = res.addressComponent[1];
                        ServerPlaceSearchByKeywords(city, keyword, callback);
                    } else {
                        callback([])
                    }
                }
            )
        }
    }

    //优先城市查询
    this.searchPlaceLimitCityByKeyword = function(city, keyword, callback) {
        if (!keyword || typeof callback != 'function') {
            return;
        }

        if (MapParam.addressApi == 'AMapWeb' || MapParam.addressApi == 'AMapWeb2') {
            //jsAPI 个人 100   企业1000 商用 10000
            //var placeSearch = new AMap.PlaceSearch({
            //    city: city,
            //    type: "汽车服务|汽车销售|汽车维修|摩托车服务|餐饮服务|购物服务|生活服务|体育休闲服务|医疗保健服务|住宿服务|风景名胜|商务住宅|政府机构及社会团体|科教文化服务|交通设施服务|金融保险服务|公司企业|道路附属设施|地名地址信息|公共设施",
            //    page: 50
            //})
            //placeSearch.search(keyword, function (status, result) {
            //    var data = _getFlagListByKeyword(keyword);
            //    if (status === 'complete' && result.info === 'OK') {
            //        if (result.poiList.count > 0) {
            //            var pois = result.poiList.pois;
            //            var tmpLocation;
            //            for (i in pois) {
            //                tmpLocation = _coordConvert(pois[i].location.getLat(), pois[i].location.getLng(), _gcjPrjCode, _outPrjCode);
            //                data.push({ lon: tmpLocation.lon, lat: tmpLocation.lat, info: (pois[i].name + ' - ' + pois[i].address).replace(/,/g, ' - ') })
            //            }
            //        }
            //    }
            //    if (callback) {
            //        callback(data);
            //    }
            //})
            ServerPlaceSearchByKeywords(city, keyword, callback);
        } else if (MapParam.addressApi == 'BaiduMapJs' || MapParam.addressApi == 'BaiduMapWeb') {
            //jsAPI 个人 100   企业2000 商用 50000
            //百度
            if (BMap) {
                //正版还是使用jsAPI
                placeSearch = new BMap.LocalSearch(city,{
                    onSearchComplete: function(results) {
                        var data = [];
                        if (placeSearch.getStatus() == 0) {
                            // 判断状态是否正确
                            for (var i = 0; i < results.getCurrentNumPois(); i++) {
                                let poi = results.getPoi(i);
                                let tmpGD = GpsConvert.BD09_to_GCJ02(poi.point.lat, poi.point.lng);
                                tmpLocation = _coordConvert(tmpGD.lat, tmpGD.lon, _gcjPrjCode, _outPrjCode);
                                data.push({
                                    lon: tmpLocation.lon,
                                    lat: tmpLocation.lat,
                                    info: (poi.title + ' - ' + poi.address).replace(/,/g, ' - ')
                                });
                            }

                            if (callback) {
                                callback(data);
                            }
                        }
                    }
                })
                placeSearch.search(keyword);
            } else {
                //console.log("配置了  isLegal 为true ，但是百度地图没有加载，可能key有问题！")
                ServerPlaceSearchByKeywords(city, keyword, callback);
            }
        } else {
            //非正版用云端
            ServerPlaceSearchByKeywords(city, keyword, callback);
        }
    }

    function ServerPlaceSearchByKeywords(city, keyword, callback) {
        //直接调用城市查询后台接口
        http("../place/PlaceSearchByCityC", {
            keyword: keyword,
            city: city,
            //bounds: `${extent.xmin},${extent.ymin}|${extent.xmax},${extent.ymax}`,
            cityLimit: false,
            pageSize: 20,
            pageNum: 1
        }).then(res=>{
                if (res.status == 1) {
                    let pois = res.pois;
                    pois = pois.map(v=>{
                            //WGS84
                            tmpLocation = _coordConvert(v.latitude, v.longitude, _gcjPrjCode, _outPrjCode);
                            return {
                                lat: tmpLocation.lat,
                                lon: tmpLocation.lon,
                                info: `${v.name}-${v.address}`
                            }
                        }
                    )
                    callback(pois)
                } else {
                    callback([])
                }
            }
        ).catch(error=>{
                callback([])
            }
        )
    }

    this.zoomToLngLat = function(lng, lat, name) {
        this.showPoi("zoomToLngLatPOI", name, "", lng, lat, "", "", "red", "1", false, true);
    }
    //#endregion
    /**************地物查询end******************/

    //实时天气查询
    this.getRealTimeWeather = function(lng, lat, adcode, callback) {

        if (MapParam.addressApi == 'AMapWeb' || MapParam.addressApi == 'AMapWeb2') {
            //传入adcode 通过adcode查询
            if (adcode) {
                //加载天气查询插件
                AMap.plugin('AMap.Weather', function() {
                    //创建天气查询实例
                    var weather = new AMap.Weather();
                    //执行实时天气信息查询
                    weather.getLive(adcode, function(data) {
                        if (data) {
                            callback(data)
                        } else {
                            callback("无数据")
                        }
                    });
                });
            } else {
                //通过lnglat查询adcode
                AMap.plugin('AMap.Geocoder', function() {
                    var geocoder = new AMap.Geocoder()
                    let tmpGD = GpsConvert.WGS84_to_GCJ02(lat, lng);
                    var lnglat = [tmpGD.lon, tmpGD.lat]
                    geocoder.getAddress(lnglat, function(status, result) {
                        if (result.info === 'OK') {
                            // result为对应的地理位置详细信息
                            var adcode = result.regeocode.addressComponent.adcode;
                            //加载天气查询插件
                            AMap.plugin('AMap.Weather', function() {
                                //创建天气查询实例
                                var weather = new AMap.Weather();
                                //执行实时天气信息查询
                                weather.getLive(adcode, function(err, data) {
                                    if (data) {
                                        callback(data)
                                    } else {
                                        callback("无数据")
                                    }
                                });
                            });
                        } else {
                            callback("无数据")
                        }
                    })
                })
            }
        } else if (MapParam.addressApi == 'BaiduMapJs' || MapParam.addressApi == 'BaiduMapWeb') {
            ////使用百度地图  百度地图获取天气只有web api  参数 adcode
            let tmpBD = GpsConvert.WGS84_to_BD09(lat, lng);

            //直接调用后台接口
            http("../comm/GetRealtimeWeatherInfo", {
                lng: tmpBD.lon,
                lat: tmpBD.lat
            }).then(data=>{
                    let res = {
                        adcode: data.data.location.id,
                        city: data.data.location.city,
                        province: data.data.location.province,
                        temperature: data.data.now.temp,
                        weather: data.data.now.text,
                        winddirection: data.data.now.wind_dir,
                        windpower: data.data.now.wind_class,
                        reportTime: ""
                    }

                    callback(res)
                }
            ).catch(error=>{
                    callback("无数据")
                }
            )
        } else {
            callback("无数据")
        }

    }

    //#region 路径分析/导航
    var _driving;
    var _drivingRouteCallback = null;
    var _openDrivePointWindowCallback = null;
    var _driverPointIndex = 1;
    var _drivingRoute = null;
    //对外的回调路线
    var _drivingPloyline = null;
    //导航路线
    var _driveStart = null;
    //导航起点 (gps经纬度)
    var _drivePoint = null;
    //导航途经点 (gps经纬度)
    var _driveEnd = null;
    //导航终点 (gps经纬度)
    var _currOpenPointType = 1;
    //当前打开途经点管理的类型, 0-起点，1-途经点，2-终点
    this.showDirectionBar = function(routeCallback, openDrivePointWindowCallback) {
        //路线保存回调
        if (routeCallback && typeof (routeCallback) == 'function') {
            _drivingRouteCallback = routeCallback;
        } else {
            _drivingRouteCallback = null;
        }
        //途经点管理回调
        if (openDrivePointWindowCallback && typeof (openDrivePointWindowCallback) == 'function') {
            _openDrivePointWindowCallback = openDrivePointWindowCallback;
            $(".cm-policy-drivepoint").show();
        } else {
            _openDrivePointWindowCallback = null;
            $(".cm-policy-drivepoint").hide();
        }

        $("#DrivingPolicy").show();
    }
    //设置途经点并返回地图标注点的名字
    function _setDrivePoint(name, point) {
        if (_drivePoint == null) {
            _drivePoint = [];
        }
        if (name != '途经点') {
            //名称重复判断
            name = '经:' + name;
            for (var i in _drivePoint) {
                if (_drivePoint[i][0] == name) {
                    alert('已存在此途经点名称，请选择其他途经点');
                    return "";
                }
            }

            _drivePoint.push([name, point]);
        } else {
            name = name + _driverPointIndex.toString();
            _driverPointIndex++;
            //index+1
            _drivePoint.push([name, point]);
        }
        var showName = name;
        if (showName.length > 20)
            showName = showName.substr(0, 20) + '...';
        $('#DrivingPolicy_Point').append('<span>' + showName + '<input type="button" value ="X " onclick="DrivingPolicy.deletePoint(' + (_drivePoint.length - 1).toString() + ')" /></span>');

        return name;
    }

    /*
     * 鼠标绘制途经点（内部）
     */
    this.setPoint = function(name) {
        if (name == '途经点') {
            if (_drivePoint && _drivePoint.length > 15) {
                alert('添加失败，最多支持16个途经点');
                return;
            }
        }
        _mapApi.setMouseTool('point', function(point) {
            //var gcjPoint = _coordConvertIn(point[1], point[0]);
            if (name == "起点")
                _driveStart = point;
            if (name == "终点")
                _driveEnd = point;
            if (name == '途经点') {
                name = _setDrivePoint("途经点", point);
            }
            if (name != "")
                _mapApi.showFlag(name, point[0], point[1], "PIN7-32.png", true);
            _mapApi.setMouseTool('pan');
        });
    }

    this.deleteDrivingPoint = function(index) {
        if (_drivePoint && _drivePoint.length > index) {
            var name = _drivePoint[index][0];
            _mapApi.deleteFlag(name);

            _drivePoint.splice(index, 1);
            var html = [];
            //更新地图途经点，更新途经点界面
            for (var i = 0; i < _drivePoint.length; i++) {
                name = _drivePoint[i][0];
                if (name.length > 20)
                    name = name.substr(0, 20) + '...';
                html.push('<span>' + name + '<input type="button" value ="X " onclick="DrivingPolicy.deletePoint(' + i + ')" /></span>');
            }
            $('#DrivingPolicy_Point').html(html.join(''));
        }
    }

    this.drivePolice = function(policy, showResultPanel) {
        var wgsPoint = null;

        if (_driveStart == null || _driveEnd == null) {
            alert('请设置起点和终点');
            return false;
        }
        if (!_driving) {
            _driving = new AMap.Driving({
                hideMarkers: true,
                map: null,
                panel: 'DrivingResult'
            });
        }

        $('#DrivingResult').css("display", showResultPanel ? "block" : "none");

        //if(showResultPanel)
        //_driving.panel = showResultPanel ? 'DrivingResult': null

        switch (policy) {
            case "LEAST_TIME":
                _driving.setPolicy(AMap.DrivingPolicy.LEAST_TIME);
                break;
            //最快捷
            case "LEAST_FEE":
                _driving.setPolicy(AMap.DrivingPolicy.LEAST_FEE);
                break;
            //最经济
            case "LEAST_DISTANCE":
                _driving.setPolicy(AMap.DrivingPolicy.LEAST_DISTANCE);
                break;
            //最短距离
            case "REAL_TRAFFIC":
                _driving.setPolicy(AMap.DrivingPolicy.REAL_TRAFFIC);
                break;
            //最佳路况
        }
        _driving.clear();
        _drivingRoute = null;
        if (_drivingPloyline) {
            _drivingPloyline.remove();
            _drivingPloyline = null;
        }
        //起点终点处理
        var pStart = _coordConvert(_driveStart[1], _driveStart[0], _outPrjCode, _gcjPrjCode)
            , pEnd = _coordConvert(_driveEnd[1], _driveEnd[0], _outPrjCode, _gcjPrjCode);

        //途经点处理
        var opt = {};
        if (_drivePoint && _drivePoint.length > 0) {
            var waypoints = [];
            var tmpGcj;
            for (var i = 0; i < _drivePoint.length; i++) {
                tmpGcj = _coordConvert(_drivePoint[i][1][1], _drivePoint[i][1][0], _outPrjCode, _gcjPrjCode);
                waypoints.push(new AMap.LngLat(tmpGcj.lon,tmpGcj.lat));
            }
            opt.waypoints = waypoints;
        }
        _driving.search(new AMap.LngLat(pStart.lon,pStart.lat), new AMap.LngLat(pEnd.lon,pEnd.lat), opt, function(status, result) {
            if (status === 'complete' && result.info === 'OK') {
                //if (!_drivingRouteCallback)
                //    return;
                var routes = result.routes;

                _drivingRoute = [];
                var tmpMapPath = [];
                var p;
                for (var i = 0; i < routes.length; i++) {
                    for (var j = 0; j < routes[i].steps.length; j++) {
                        for (var k = 0; k < routes[i].steps[j].path.length; k++) {
                            //tmpMapPath.push([routes[i].steps[j].path[k].lng, routes[i].steps[j].path[k].lat]);
                            //wgsPoint = GpsConvert.GCJ02_to_WGS84(routes[i].steps[j].path[k].lat, routes[i].steps[j].path[k].lng);
                            p = _coordConvert(routes[i].steps[j].path[k].lat, routes[i].steps[j].path[k].lng, _gcjPrjCode, _currentPrjCode);
                            tmpMapPath.push([p.lon, p.lat]);
                            wgsPoint = _coordConvert(routes[i].steps[j].path[k].lat, routes[i].steps[j].path[k].lng, _gcjPrjCode, _outPrjCode);
                            _drivingRoute.push([wgsPoint.lon, wgsPoint.lat]);
                        }
                    }
                }

                if (_drivingRoute.length > 0) {
                    _drivingPloyline = new maptalks.LineString(tmpMapPath,{
                        symbol: {
                            'lineColor': '#1BAC26',
                            'lineWidth': 6,
                            'lineJoin': 'round',
                            //miter, round, bevel
                            'lineCap': 'round'//butt, round, square
                        }
                    }).addTo(_vLayers['polyline'].layer);

                    $("#btnDrivingSetPath").show();
                } else {
                    $("#btnDrivingSetPath").hide();
                }
            }
        });
    }

    this.clearDriving = function() {
        //if (polylineList.containsKey("导航路线")) //移除路线
        //{
        //    var delP = polylineList.getValue("导航路线");
        //    deletePolygon(delP);
        //}

        if (_driving) {
            _driving.clear();
        }

        _mapApi.deleteFlag('起点');
        _mapApi.deleteFlag('终点');
        _driveStart = null;
        _driveEnd = null;
        _drivingRoute = null;
        if (_drivingPloyline) {
            _drivingPloyline.remove();
            _drivingPloyline = null;
        }

        if (_drivePoint && _drivePoint.length > 0) {
            for (var i = 0; i < _drivePoint.length; i++) {
                _mapApi.deleteFlag(_drivePoint[i][0]);
            }
            _driverPointIndex = 1;
        }
        _drivePoint = null;
        $('#DrivingPolicy_Point').html('');
        $("#btnDrivingSetPath").hide();
    }

    //#region 导航回调事件
    //获取导航的路线经纬度数组回调,[[119.26,26.031],[119.26,26.032]]
    this.drivingRouteCallback = function() {
        if (_drivingRouteCallback && _drivingRoute) {
            _drivingRouteCallback(_drivingRoute);
        } else {
            return _drivingRoute
        }
    }

    /**
     * 打开导航途经点管理页面的事件回调
     * @param {any} type 0-起点，1-途经点，2-终点
     * */
    this.openDrivePointWindowCallback = function(type) {
        _currOpenPointType = type;
        if (_openDrivePointWindowCallback) {
            _openDrivePointWindowCallback();
        }
    }
    /**
     * 设置途经点（外部调用）
     * @param {any} pointName 途经点名称
     * @param {any} wgsLon 途经点GPS经度
     * @param {any} wgsLat 途经点GPS纬度
     */
    this.setDrivePoint = function(pointName, wgsLon, wgsLat) {
        if (_currOpenPointType == 0) {
            //起点
            _driveStart = [wgsLon, wgsLat];
            _mapApi.showFlag("起点", wgsLon, wgsLat, "PIN7-32.png", true);
        } else if (_currOpenPointType == 2) {
            //终点
            _driveEnd = [wgsLon, wgsLat];
            _mapApi.showFlag("终点", wgsLon, wgsLat, "PIN7-32.png", true);
        } else {
            //途经点
            if (_drivePoint && _drivePoint.length > 15) {
                alert('添加失败，最多支持16个途经点');
                return;
            }

            var name = _setDrivePoint(pointName, [wgsLon, wgsLat]);
            if (name != '')
                _mapApi.showFlag(name, wgsLon, wgsLat, "PIN7-32.png", true);
        }
        //定位到地图中心
        _mapApi.setCenter(wgsLon, wgsLat);
    }

    //#endregiom

    /**
     * 通过起点终点获取路径规划结果
     * 独立接口，与路径规划UI无关
     * @param {number} startLng 起点经度
     * @param {number} startLat 起点纬度
     * @param {number} endLng   终点经度
     * @param {number} endLat   终点纬度
     * @param {string} policy   导航策略（LEAST_TIME：最快捷，LEAST_FEE：最经济，LEAST_DISTANCE：最短距离，REAL_TRAFFIC：最佳路况）
     * @param {function} callback 回调函数，直接透传高德返回结果 callback(status, result);
     */
    this.getDrivePoliceData = function(startLng, startLat, endLng, endLat, policy, callback) {
        var driving = new AMap.Driving({
            hideMarkers: true
        });

        //var startPoint = GpsConvert.WGS84_to_GCJ02(startLat, startLng),
        //    endPoint = GpsConvert.WGS84_to_GCJ02(endLat, endLng);
        var startPoint = _coordConvert(startLat, startLng, _outPrjCode, _gcjPrjCode)
            , endPoint = _coordConvert(endLat, endLng, _outPrjCode, _gcjPrjCode);
        switch (policy) {
            case "LEAST_TIME":
                driving.setPolicy(AMap.DrivingPolicy.LEAST_TIME);
                break;
            //最快捷
            case "LEAST_FEE":
                driving.setPolicy(AMap.DrivingPolicy.LEAST_FEE);
                break;
            //最经济
            case "LEAST_DISTANCE":
                driving.setPolicy(AMap.DrivingPolicy.LEAST_DISTANCE);
                break;
            //最短距离
            case "REAL_TRAFFIC":
                driving.setPolicy(AMap.DrivingPolicy.REAL_TRAFFIC);
                break;
            //最佳路况
        }

        //var points = [];
        //points.push(new AMap.LngLat(startPoint.lon, startPoint.lat));
        //points.push(new AMap.LngLat(endPoint.lon, endPoint.lat));
        driving.search(new AMap.LngLat(startPoint.lon,startPoint.lat), new AMap.LngLat(endPoint.lon,endPoint.lat), {}, function(status, result) {
            points = null;

            var startPoiLngLat = new AMap.LngLat(startPoint.lon,startPoint.lat);
            var endPoiLngLat = new AMap.LngLat(endPoint.lon,endPoint.lat);
            //添加起点 和终点的直线距离
            let lineDistance = startPoiLngLat.distance(endPoiLngLat)

            //【起点 至 导航起点】 + 【导航距离】 + 【导航终点 至 终点】
            var navigationDistance = result.routes[0].distance;
            //导航距离
            let steps = result.routes[0].steps;

            //导航起点坐标
            let drivingStartLngLat = result.routes[0].steps[0].start_location;
            let navigationDistance2 = startPoiLngLat.distance(drivingStartLngLat)
            //起点至导航起点的距离

            ////导航终点坐标
            let drivingEndLngLat = result.routes[0].steps[steps.length - 1].end_location;
            let navigationDistance3 = endPoiLngLat.distance(drivingEndLngLat)
            //导航终点至终点的距离
            let totalDistance = parseFloat(navigationDistance) + parseFloat(navigationDistance2) + parseFloat(navigationDistance3)

            let distanceResult = {
                "lineDistance": lineDistance,
                "totalDistance": totalDistance
            }

            if (callback) {
                callback(status, result, distanceResult);
            }
        });
    }
    //#endregion
    //#endregion 路径分析/导航

    /**
     *  天气预警
     * */

    let localAdcode = null;
    //全国行政区中心对象
    let weatherAlarmTimer = null;
    this.openWeatherAlarm = async function() {
        mapToolStatus.layer.weatherAlarm = true;

        if (!weatherAlarmTimer) {
            _getWeatherAlarm();
            //定时获取天气预警
            weatherAlarmTimer = setInterval(()=>{
                    _getWeatherAlarm()
                }
                , 10 * 1000 * 30)
            //5min
        }
    }

    this.closeWeatherAlarm = function() {
        mapToolStatus.layer.weatherAlarm = false

        clearInterval(weatherAlarmTimer)
        weatherAlarmTimer = null;
        removeAllMarker("poi");
    }

    async function _getWeatherAlarm() {
        let wAlarmList = []
        if (!localAdcode) {
            await http("../comm/GetDistrictsInfo").then(data=>{
                    localAdcode = {}
                    _getAdcodeObj(data.data)
                    //生成全国行政区对象
                }
            ).catch(error=>{
                    console.log("获取行政区：" + error.info)
                }
            )
        }

        //获取天气预警列表
        await http("../comm/GetWeatherAlarmInfo").then((data)=>{
                wAlarmList = data.data;
            }
        ).catch(error=>{
                console.log("获取天气预警接口：" + error.info)
            }
        )

        wAlarmList.forEach(item=>{
                if (filterDateString(item.public_time)) {
                    //列表中可能包含前几天的预警  这边过滤掉  只取今天的
                    //画图标
                    showWeatherAlarmIcon(item, function() {});
                }
            }
        )
    }

    //过滤不是今天的日期字符串
    function filterDateString(daystr) {
        return new Date().toDateString() == new Date(daystr).toDateString();
    }

    //封装axios 请求
    function http(url, data) {
        return new Promise((resolve,reject)=>{
                $.ajax({
                    url: url,
                    dataType: "jsonp",
                    jsonp: "callback",
                    type: 'get',
                    data,
                    timeout: 120000,
                    success: function(data) {
                        if (data.status == "1") {
                            resolve(data)
                        } else {
                            reject(data);
                        }
                    },
                    error: function(e) {
                        reject({
                            info: url + "接口请求错误"
                        });
                    }
                });

            }
        )
    }

    //画天气预警图标
    function showWeatherAlarmIcon(item, showCallback) {
        var icon = new MapWeatherAlarmIcon(item.type,item.levelCode);
        if (!icon.path)
            return;
        //获取坐标
        let lng = localAdcode[item.geocode] ? localAdcode[item.geocode].lng : null;

        if (!lng)
            return;
        let x = localAdcode[item.geocode].lng;
        let y = localAdcode[item.geocode].lat;

        //拼接内容
        let content = '<div class="wa-container"> <div class="title-div"><div class="wa-title">' + item.title + '</div><span  title="关闭" style="padding:10px;font-size:17px;cursor: pointer" onclick = "parent.window.Global.RealTime.handleMapTool(\'close\')" >×</span ></div>';
        if (item.levelCode == "Orange") {
            content += '<div class="orange-level">' + item.type + '-' + item.level + '</div>';
        } else if (item.levelCode == 'Yellow') {
            content += '<div class="yellow-level">' + item.type + '-' + item.level + '</div>';
        } else if (item.levelCode == 'Blue') {
            content += '<div class="blue-level">' + item.type + '-' + item.level + '</div>';
        } else {
            content += '<div class="red-level">' + item.type + '-' + item.level + '</div>';
        }
        content += '<div class="wa-content"> ' + item.desc + '</div ></div>'

        var opt = new MarkerOption("poi",item.geocode,icon,x,y,null,null,"",content,false);

        drawMarker(opt, function(e) {
            var tmpOption = _getExtData(e.target);
            if (tmpOption && tmpOption.popContent != '') {
                var p = _coordConvertIn(tmpOption.gpslat, tmpOption.gpslng);
                _showInfoWindow(tmpOption.popContent, new maptalks.Coordinate(p.lon,p.lat), false);
            }
            //return false;
            if (_mapApi.mouseCurrCursor == 'default' || _mapApi.mouseCurrCursor == 'pan' || _mapApi.mouseCurrCursor == 'trackPoint')
                return false;
        }, showCallback);
    }

    //生成行政区对象;
    function _getAdcodeObj(districts) {
        if (districts.length > 0) {
            districts.forEach(item=>{
                    localAdcode[item.DivisonCode] = {
                        name: item.DivisonName,
                        lng: item.Lon,
                        lat: item.Lat
                    }
                    //_getAdcodeObj(item.districts);
                }
            )
        }
    }

    //#region 导出/打印地图
    //保存地图
    this.saveMap = function(callback) {

        try {
            //if (typeof (callback) != 'function') {
            //    return;
            //}
            let dataUrl = mapObj.toDataURL({
                'mimeType': 'image/png',
                // or 'image/png'
                'save': true,
                // to pop a save dialog
                'fileName': 'map'// file name
            });
        } catch (e) {
            if (typeof (callback) != 'function') {
                var r = {
                    result: -1,
                    url: ''
                };
                callback(r);
            }
        }
    }
    ;

    this.printMap = function() {
        window.focus();
        window.print();
    }
    //#endregion

    //#region 坐标转换
    //外部坐标转换为地图当前坐标系坐标
    function _coordConvertIn(y, x, noFormat) {
        return _coordConvert(y, x, _outPrjCode, _currentPrjCode, noFormat);
    }

    //当前坐标转换为外部坐标
    function _coordConvertOut(y, x, noFormat) {
        return _coordConvert(y, x, _currentPrjCode, _outPrjCode, noFormat);
    }

    function _coordConvert(y, x, fromCode, toCode, noFormat) {
        x = parseFloat(x),
            y = parseFloat(y);
        //外部传入的可能是字符串 需进行转义
        if (fromCode == toCode)
            return {
                'lat': y,
                'lon': x
            };

        var fun = fromCode.replace(':', '') + '_' + toCode.replace(':', '');
        return GpsConvert[fun](y, x, noFormat);
    }

    //#endregion

    function _formatNumber6(num) {
        //保留6位小数
        return Math.round(num * 1000000) / 1000000;
    }

    this.destroy = function() {
        mapObj.remove();

        //清除定时器
        clearTimeout(_handleMarkersTimeout);
        clearTimeout(_currVehicleTimeout);
        for (i in _trackList) {
            clearTimeout(_trackList[i].timeOut);
        }

        //释放自定义变量
        mapObj = null;
        toolBar = null;
        scaleTool = null;
        overViewTool = null;
        mapTypeTool = null;
        geoCoder = null;
        placeSearch = null;
        _markerType = null;
        markerArray = null;
        circleList = null;
        polygonList = null;
        polylineList = null;
        trackArray = null;
        //key Array，key为车辆ID Array为轨迹点数组
        _trackList = null;
        //vehicleId为key
        _infoWindow = null;
        _clusterList = null;
        _vLayers = null;
        _HandlingMarkers = null;
        _iHandlingWaitTime = null;
        _drawingMarkers = null;
        _updateingMarkers = null;
        _removeingMarkers = null;
        _drawCallback = null;
        _searchCallback = null;
        mousetool = null;
        distanceTool = null;
        areaTool = null;
        _currVehicleTimeout = null;
        //取消当前车定时器
        _handleMarkersTimeout = null;
        _currVehicleBgMarker = null;
        //当前车的背景-marker
        _currVehicleId = null;
        _mapApi = null;
        this.mouseCurrCursor = null;
        this.currentPoint = null;
        //当前点击的点
        this.currentZoomBox = null;
        //拉框信息
        this.currentSketchPoints = null;
        //多个点（多边形区域/路线）
        this.clickedVehicleId = null;
        //当前点击的车辆ID
        this.isMapClicked = null;
        this.isShowCurrVehicleBg = null;
        _bTrackMode = null;
        //是否画轨迹模式，地图全局 画轨迹模式 此模式下不进行车辆聚合，快速画车
        //localSearchData = null; //地物查询结果集
    }

    //#region maptalks 扩展
    /**
     * 几何图形/map/layer等设置extData
     * @param {any} geometry 几何图形/map/layer等对象
     * @param {any} extData 扩展对象
     */
    function _setExtData(geometry, extData) {
        if (geometry.config != undefined)
            geometry.config({
                'extData': extData
            });
    }

    /**
     * 几何图形/map/layer等获取extData
     * @param {any} geometry 几何图形/map/layer等对象
     */
    function _getExtData(geometry) {
        if (geometry.config != undefined)
            return geometry.config().extData;
        return null;
    }

    /**
     * 几何图形/map/layer等设置某个属性
     * @param {any} geometry 几何图形/map/layer等对象
     * @param {any} key 属性key
     * @param {any} value 要设置的值
     */
    function _setConfig(geometry, key, value) {
        if (geometry.config != undefined)
            geometry.config({
                key: value
            });
    }

    /**
     * 几何图形/map/layer等获取某个属性
     * @param {any} geometry 几何图形/map/layer等对象
     * @param {any} key 属性key
     * @param {any} value 要设置的值
     */
    function _getConfig(geometry, key) {
        if (geometry.config != undefined)
            return (geometry.config())[key];
        return null;
    }
    //#endregion
};

;/**
 * 描述: 地图对CS 客户端接口
 * 作者: liuxf
 * 版本: v1.0 build 2017-07-19 by liuxf
 * 日志:
 * V1.7.4 2018-07-24
 * 增加路径分析功能的外部开放接口showDirectionBar、clearPath
 * V1.1 2018-4-24
 *      新增接口getApiVersion、zoomTo、zoomToBound、setCircleMesTool、setRectangleMesTool
 *      绘制路线与编辑路线sketchBack、getLineCoordStr、setNodeDragTool、setNodeDeleTool、getEditLineCoordStr接口
 * V1.0 2017-07-19 初始版本，支持旧GIS主要接口
 */
function getApiVersion() {
    return 3.0;
}
//地图是否成功加载
function isMapLoadedSuccess() {
    if (mapApi != null && mapApi.initCompleted)
        return true;
    return false;
}
/***
 **begin 地图工具栏 -- 地图鼠标类型
 **/
//点击放大工具
function setClickZoomInTool() {
    mapApi.setMouseTool('zoomIn');
}
//点击缩小工具
function setClickZoomOutTool() {
    mapApi.setMouseTool('zoomOut');
}

//拉框放大工具
function setzoomintool() {
    mapApi.setMouseTool('rectZoomIn');
}
//拉框缩小工具
function setzoomouttool() {
    mapApi.setMouseTool('rectZoomOut');
}
//漫游工具
function setpantool() {
    mapApi.setMouseTool('pan');
}
//获取CarID工具(未实现)
function setgetCarIDTool() {
    mapApi.setMouseTool('getvehicle');
}
//测距工具
function setmeasuretool() {
    mapApi.setMouseTool('rule');
}
//地图选点工具（画标注、）
function setpointtool(pointtype) {
    //if (pointtype == undefined) {
    //    pointtype = 'point';
    //}
    mapApi.setMouseTool('point', null);
}

//居中
function setZoomToCenter() {
    mapApi.setMouseTool('zoomToCenter');
}
//矩形量算工具
function setRectangleMesTool() {
    mapApi.setMouseTool('rectMeasure');
}
//画圆量算工具
function setCircleMesTool() {
    mapApi.setMouseTool('circleMeasure');
}
//多边形面积量算工具
function setPolygonMesTool() {
    mapApi.setMouseTool('measureArea');
}
//绘制矩形(拉框)工具
function setZoomBoxExTool() {
    mapApi.setMouseTool('rectangle', null);
}
//画多边形工具
function setregiontool() {
    mapApi.setMouseTool('polygon', null);
}
//画线工具
function setpathtool() {
    mapApi.setMouseTool('polyline', null);
}

//显示轨迹点
function setShowHintTool() {
    mapApi.setMouseTool('trackPoint');
}

//画线工具（未使用）
function drawLine() {
    alert('drawLine');
    return;
    if (pMap)
        pMap.SetPointTool(showfg);
}
//画线工具2（未使用）
function newdrawline() {
    alert('newdrawline');
    return;
    if (pMap)
        pMap.SetPathTool(alertPs);
}
//画多边形工具（未使用）
function drawpolygon() {
    alert('drawpolygon');
    return;
    if (pMap)
        pMap.SetPolygonTool(alertPs);
}

/***
 **end 地图鼠标类型
 **/

/***
 **begin 基础功能
 ***/
//获取地图级别
function getZoom() {
    return mapApi.getZoom();
}
//指定级别和经纬度居中
function zoomTo(zoom, x, y) {
    zoom = parseInt(zoom),
        x = parseFloat(x),
        y = parseFloat(y);
    mapApi.setZoomAndCenter(zoom, x, y);
}
//全图
function zoomToMaxExtent() {
    mapApi.setZoomAndCenter(4, 106.17, 38.36);
    //居中到中国中心点 第四级
}
//按指定矩形缩放，sw 西南，ne 东北
function zoomToBound(swX, swY, neX, neY) {
    mapApi.zoomToBound(swX, swY, neX, neY);
    return 0;
}

//获取最后点标记的位置
function getcurrentpoint() {
    var currentTool = mapApi.mouseCurrCursor;
    var ret = null;
    //if (currentTool == "line") {
    //    ret = pMap.getCurrentLineClickPoint();
    //}
    //else
    if (currentTool == "point") {
        if (mapApi.currentPoint != null)
            ret = mapApi.currentPoint.join(';');

    }
    return ret;
}

//得到框选点
function getzoomboxpoints() {
    var currentTool = mapApi.mouseCurrCursor;
    var ret = null;
    if (currentTool == "rectangle") {
        if (mapApi.currentZoomBox != null)
            ret = mapApi.currentZoomBox.join(';');
    }
    return ret;
}

//获取路线/多边形区域点（多个点）
function getSketchPoints() {
    //var currentTool = mapApi.mouseCurrCursor;
    var ret = null;
    //if (currentTool == "polygon" || currentTool == "polyline") {
    if (mapApi.currentSketchPoints != null)
        ret = mapApi.currentSketchPoints.join(';');
    //}
    return ret;
}

//绘制路线，撤销操作
function sketchBack() {
    mapApi.drawpolyline_sketchBack();
}
//绘制路线，获取当前路段点
function getLineCoordStr() {
    var ret = null;
    var points = mapApi.drawpolyline_getLineCoordStr();
    if (points != null)
        ret = points.join(';');
    return ret;
}

//结束鼠标绘制线路
function completeMouseDrawLine() {
    mapApi.drawpolyline_completeMouseDrawLine();
}

//路线编辑
//拖动节点工具,传入路线名称 若未传名称则取地图上第一条路线
function setNodeDragTool(id) {
    mapApi.drawpolyline_startLineEdit(id);
}
//删除节点工具,传入路线名称 若未传名称则取地图上第一条路线
function setNodeDeleTool(id) {
    mapApi.drawpolyline_startLineEdit(id);
}
//获取编辑之后的路线，按名称匹配，获取后此路线退出编辑模式
function getEditLineCoordStr(id) {
    var ret;
    var points = mapApi.drawpolyline_endLineEdit(id);
    if (points != null) {
        ret = points.join(';');
    }
    points = null;
    return ret;
}
//路线编辑 end

function getCarID() {
    return mapApi.currentVehicleId;
}

//获取当前地图中心点、级别和地图类型
function getMapView() {
    return mapApi.getMapView();
}
//设置当前地图中心点、级别
function setMap(mapExtent) {
    mapApi.setMap(mapExtent);
}

function getmapurl() {
    //var ddl = document.getElementById('DropDownList1');
    //var result = "";
    //for (var i = 0; i < ddl.length; i++) {
    //    result += ddl[i].value + ";" + ddl[i].text + ",";
    //}
    //return result;
    return g_maplist + ',';
}
function getMapList() {
    //var ddl = document.getElementById('DropDownList1');
    //var result = "";
    //for (var i = 0; i < ddl.length; i++) {
    //    result += ddl[i].value + ";" + ddl[i].text + ",";
    //}
    //return result.substring(0, result.length - 1);
    return g_maplist;
}
//无效
function map_Down() {
    mapApi.isMapClicked = true;
}
//无效
function map_Out() {
    mapApi.isMapClicked = false;
}
//无效
function getMapClicked() {
    return mapApi.isMapClicked;
}

//********路径分析 begin *********************
function showDirectionBar() {
    DrivingPolicy.showDrivingPolicy();
}

var changeButtonCss = function(obj) {
    $(".policySelected").removeClass("policySelected");
    $(obj).addClass("policySelected");
}
//打开路径分析窗口
var DrivingPolicy = {
    showDrivingPolicy: function(routeCallback, openDrivePointCallback) {
        mapApi.showDirectionBar(routeCallback, openDrivePointCallback);
    },
    //设置起点终点
    setPoint: function(obj, name) {
        //changeButtonCss(obj);
        mapApi.setPoint(name);
    },
    //导航
    drivePolice: function(obj) {
        //changeButtonCss(obj);
        var police = $('#police option:selected').val();
        var bChecked = $('#chkDrivingResultInList').is(':checked');
        mapApi.drivePolice(police, bChecked);
    },
    //漫游
    pantool: function(obj) {
        //changeButtonCss(obj);
        setpantool();
    },
    //清除路径分析
    clearDriving: function(obj) {
        //changeButtonCss(obj);
        mapApi.clearDriving();
    },
    //关闭路径分析窗口
    closeDrivingPolicy: function(obj) {
        //changeButtonCss(obj);
        mapApi.clearDriving();
        $("#DrivingPolicy").hide();
    },
    //设置路线按钮
    drivingRouteCallback: function() {
        mapApi.drivingRouteCallback();
    },
    //打开选择途经点按钮
    openStartPointWindowCallback: function() {
        mapApi.openDrivePointWindowCallback(0);
    },
    //打开选择途经点按钮
    openDrivePointWindowCallback: function() {
        mapApi.openDrivePointWindowCallback(1);
    },
    //打开选择途经点按钮
    openEndPointWindowCallback: function() {
        mapApi.openDrivePointWindowCallback(2);
    },
    //删除途经点
    deletePoint: function(index) {
        mapApi.deleteDrivingPoint(index);
    }
}

//********路径分析 end *********************
/***
 **end 基础功能
 ***/

/*****地图标注 - flag 、POI begin ******/
//画标注
function showflag(name, x, y, bmpName) {
    mapApi.showFlag(name, x, y, bmpName);
}

//清除所有标注
function clearallflag() {
    mapApi.clearAllFlag();
}
//未使用
function deleteflagbyxy(x, y) {
    alert('deleteflagbyxy');
    //return mapApi.deleteFlagXY(x, y);
}
function getflagnamebyxy(x, y) {
    return mapApi.getFlagNameByXY(x, y);
}
function deleteflag(name) {
    mapApi.deleteFlag(name);
}
//*****************
//在地图上显示一个POI

///id:其中0应做特殊处理<
///text:显示名字文本
///popText:显示提示框文本
///lon:经度
///lat:纬度
///hintUrl: 无
///poiLinkArry：无
///poiColor:图标颜色 poiLevel为5是特定字符 如"NormalOff"为正常停车图标，
///         1、2、3为"RED"红色 "BLUE"蓝色  4为"START"起点 "END"终点
///poiLevel:图标级别 5为车辆图标，1为大图标，2为中图标，3为小图标, 4为起点终点图标
///isTxtOnImg:是否文字在图标上显示
/***********/
function showPOI(id, text, popText, lon, lat, hintUrl, POILinkArry, poiColor, poiLevel, isTxtOnImg) {
    mapApi.showPoi(id, text, popText, lon, lat, hintUrl, POILinkArry, poiColor, poiLevel, isTxtOnImg);
}

function DeletePOI(id) {
    mapApi.deletePoi(id);
}
function clearAllPOI() {
    mapApi.clearAllPoi();
}
/*****地图标注 - flag end ******/

/********* 区域、路线begin*********/
//画圆
function showCircle(circleName, centerX, centerY, radius, isZoom) {
    mapApi.showCircle(circleName, centerX, centerY, radius, isZoom);
}
function showpolygon(polygonName, strArrayX, strArrayY, isZoom) {
    showpolygonForCS(polygonName, strArrayX, strArrayY, isZoom);
}
function showpolygonForCS(polygonName, strArrayX, strArrayY, isZoom) {
    var arrayX = strArrayX.split(",");
    var arrayY = strArrayY.split(",");
    mapApi.showPolygon(polygonName, arrayX, arrayY, isZoom);
}
;function showpath(pathName, strArrayX, strArrayY, isZoom, isShowDirection) {
    showpathForCS(pathName, strArrayX, strArrayY, isZoom, isShowDirection);
}
function showpathForCS(pathName, strArrayX, strArrayY, isZoom, isShowDirection) {
    var arrayX = strArrayX.split(",");
    var arrayY = strArrayY.split(",");
    mapApi.showPolyline(pathName, arrayX, arrayY, isZoom, isShowDirection);
}

//通过区域名称移除区域（圆形、矩形、多边形）
function clearPolygon(polygonName) {
    mapApi.clearPolygon(polygonName);
}
//清除所有区域（圆形、矩形、多边形）
function clearallpolygon() {
    mapApi.clearAllPolygon();
}

//通过路线名称移除单条路线
function clearPath(pathName) {
    mapApi.clearPolyline(pathName);
}

function clearAllPath() {
    mapApi.clearAllPolyline();
}

/*********区域、路线end****************/

/*******画车、轨迹 begin***************/
//在地图上绘制车辆
function _showCarClickCallback(markerOption) {
    mapApi.showInfoWindow(markerOption.popContent, markerOption.gpslng, markerOption.gpslat, true, markerOption.key);
    var carIdBtn = document.getElementById('btnGetCarID');
    if (carIdBtn) {
        carIdBtn.click();
    }
}

function _showCarShowCallback(markerOption) {
    mapApi.showInfoWindow(markerOption.popContent, markerOption.gpslng, markerOption.gpslat, true, markerOption.key);
}

//新增参数：trackColor-轨迹线颜色，只有在isShowTrack=true时有效，格式为标准的颜色码 如#FF0000代表红色
function showCar(labeltext, x, y, direction, iconType, isZoom, popContent, carStatus, alarmType, isFill, accOn, gpsValid, vehicleId, isShowTrack, speed, trackColor, gpsTime, textColor) {
    //test
    //if (showTestMsg)
    //    showTestMsg('showcar');

    if (typeof (direction) !== "number")
        direction = 0;
    var showVehicleOption = new ShowVehicleOption();
    showVehicleOption.labeltext = labeltext;
    showVehicleOption.x = x;
    showVehicleOption.y = y;
    showVehicleOption.direction = direction;
    showVehicleOption.iconType = iconType;
    showVehicleOption.isZoom = isZoom;
    showVehicleOption.popContent = popContent;
    showVehicleOption.carStatus = carStatus;
    showVehicleOption.alarmType = alarmType;
    showVehicleOption.isFill = isFill;
    showVehicleOption.accOn = accOn;
    showVehicleOption.gpsValid = gpsValid;
    showVehicleOption.vehicleId = vehicleId.toString();
    showVehicleOption.isShowTrack = isShowTrack;
    showVehicleOption.speed = speed;
    showVehicleOption.clickCallback = _showCarClickCallback;
    //showVehicleOption.showCallback = _showCarShowCallback;
    showVehicleOption.trackColor = trackColor;
    showVehicleOption.bFastMode = false;
    //
    showVehicleOption.gpsTime = gpsTime;
    showVehicleOption.textColor = textColor || '';
    mapApi.showVehicleNew(showVehicleOption);

}
//设置地图为轨迹回放模式
function setTrackMode() {
    mapApi.setTrackMode();
}
//设置是否显示所有轨迹点
//isShowAllTrackPoint- true:显示，false 不显示
function setIsShowAllTrackPoint(isShowAllTrackPoint) {
    mapApi.setIsShowAllTrackPoint(isShowAllTrackPoint);
}
//设置当前车
function settrackingcar(vehicleId) {
    mapApi.setTrackingVehicle(vehicleId);
}

//删除车辆
function deleteCar(vehicleId) {
    mapApi.deleteVehicle(vehicleId);
}

//删除所有车辆
function deleteAllCar() {
    mapApi.deleteAllVehicle();
}

function clearTrack(vehicleId) {
    mapApi.clearTrack(vehicleId.toString());
}

function clearAllTrack() {
    mapApi.clearAllTrack();
}

function clearTrackTo(vehicleId, dotIndex) {
    mapApi.clearTrackTo(vehicleId.toString(), parseInt(dotIndex));
}
/*******画车、轨迹 end***************/

/*******地理位置解析begin*************/
var _spatialQueryResult;
//地理位置查询
function excuteSpatialQuery(lng, lat) {
    excuteSpatialQueryById('', lng, lat);
}
//地理位置查询
function excuteSpatialQueryById(queryId, lng, lat, callback) {
    _spatialQueryResult = null;
    mapApi.getAddress(lng, lat, function(result) {
        if (result == '无数据') {
            _spatialQueryResult = '0:::无数据::: ::: :::' + queryId;
        } else {
            _spatialQueryResult = '1:::' + result + ':::' + lng + ':::' + lat + ':::' + queryId;
        }
        document.getElementById('btnSpatialEvent').click();
    });
}
//获取地理位置解析结果
function getSpatialQueryResult() {
    return _spatialQueryResult;
}
//批量解析请求
function excuteTrackPointQuerty(queryType, requesId, lon, lat) {
    mapApi.getMultiAddress(queryType, requesId, lon, lat);
}
//获取批量地理位置解析结果
function getTrackPointQueryInfo(queryType) {
    var reslObj = mapApi.getMultiAddressResult(queryType);
    //console.log("query result:", queryType, reslObj);
    if (reslObj) {
        var resl = [];
        for (var i = 0; i < reslObj.length; i++) {
            resl.push(reslObj[i].qId + "|" + reslObj[i].address);
        }
        var strResl = resl.join("::");
        return strResl;
    } else
        return "";
}
//清除指定类型的批量地理位置解析请求
function stopPlayTrackLine(queryType) {
    if (console)
        console.log("clearMultiAddress", queryType);
    mapApi.clearMultiAddress(queryType);
}
//清除指定类型的批量地理位置解析请求
function clearMultiAddress(queryType) {
    mapApi.clearMultiAddress(queryType);
}
/*******地理位置解析end***************/

/*******地物查询begin***************/
var _searchPlaceResult;
function excuteAttributionQuery(keyword) {
    _searchPlaceResult = null;
    //mapApi.searchPlaceByKeyword(keyword, function (result) {
    //    _searchPlaceResult = result.join(':::');
    //    var resl = [];
    //    for (var i = 0; i < result.length; i++) {
    //        resl.push(result[i].info + ',' + result[i].lat + ',' + result[i].lon);
    //    }
    //    _searchPlaceResult = resl.join(':::');
    //    result.splice(0, result.length);
    //    resl.splice(0, resl.length);
    //    document.getElementById('btnAttributionlEvent').click();
    //})

    mapApi.searchPlaceLimitCityByKeyword("呼尔浩特", keyword, function(result) {
        _searchPlaceResult = result.join(':::');
        var resl = [];
        for (var i = 0; i < result.length; i++) {
            resl.push(result[i].info + ',' + result[i].lat + ',' + result[i].lon);
        }
        _searchPlaceResult = resl.join(':::');
        result.splice(0, result.length);
        resl.splice(0, resl.length);
        document.getElementById('btnAttributionlEvent').click();
    })
}

function getAttributionQueryResult() {
    return _searchPlaceResult;
}
//根据经纬定位地物位置地图
function zoonmToLngLat(lng, lat, name) {
    mapApi.zoomToLngLat(lng, lat, name);
}
/*******地物查询end*****************/

/*******地图切换begin*****************/

function MapChangeBaseLayer(layerId, layerName) {
    mapApi.changeBaseLayer(layerId, layerName);
    //showTestMsg('MapChangeBaseLayer,' + layerName + ',' + layerType);
    //if (mapApi != null) {
    //    mapApi.destroy();
    //    mapApi = null;
    //}
    //switch (layerType) {
    //    case "百度地图": switchMap_BD(); break;
    //    case "高德地图": switchMap_GD(); break;
    //}
    //mapApi.init("map", 119.3, 26.03, 13);
}

function switchMap_BD() {//var i = document.getElementsByTagName("meta");
//i[1]["content"] = "IE=7";

//mapApi = new BMapApi();
}

function switchMap_GD() {//var i = document.getElementsByTagName("meta");
//i[1]["content"] = "IE=Edge,chrome=1";

//mapApi = new AMapApi();
}

/*******地图切换end*****************/
;
